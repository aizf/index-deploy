<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>nodejs安装</title>
    <link href="/2020/07/27/notes/nodejs/nodejs%E5%AE%89%E8%A3%85/"/>
    <url>/2020/07/27/notes/nodejs/nodejs%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h2 id="nodesource"><a href="#nodesource" class="headerlink" title="nodesource"></a>nodesource</h2><p><a href="https://github.com/nodesource/distributions/blob/master/README.md#debinstall" target="_blank" rel="noopener">https://github.com/nodesource/distributions/blob/master/README.md#debinstall</a></p><h2 id="nvm"><a href="#nvm" class="headerlink" title="nvm"></a>nvm</h2><p><a href="https://github.com/nvm-sh/nvm" target="_blank" rel="noopener">https://github.com/nvm-sh/nvm</a></p>]]></content>
    
    
    <categories>
      
      <category>nodejs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>nodejs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pm2</title>
    <link href="/2020/07/27/notes/nodejs/pm2/"/>
    <url>/2020/07/27/notes/nodejs/pm2/</url>
    
    <content type="html"><![CDATA[<p>PM2是一个守护进程管理器，它将帮助您管理和保持应用程序在线。</p><p><a href="https://pm2.keymetrics.io/docs/usage/quick-start/" target="_blank" rel="noopener">https://pm2.keymetrics.io/docs/usage/quick-start/</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><div class="hljs"><pre><code class="hljs sh">npm install pm2 -g<span class="hljs-comment"># or</span>npm install pm2 -D</code></pre></div><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><div class="hljs"><pre><code class="hljs sh">pm2 start app.js</code></pre></div><p>可选参数：</p><ul><li><code>--name &lt;app_name&gt;</code>，指定一个名字</li><li><code>--watch</code>，热更新</li><li><code>--max-memory-restart &lt;200MB&gt;</code>，设置应用程序重新加载的内存阈值</li><li><code>--log &lt;log_path&gt;</code>，指定log文件位置</li><li><code>-- arg1 arg2 arg3</code>，额外参数</li><li><code>--restart-delay &lt;delay in ms&gt;</code>，设置自动重新启动之间的延迟</li><li><code>--time</code>，为日志添加时间前缀</li><li><code>--no-autorestart</code>，不自动重启</li><li><code>--cron &lt;cron_pattern&gt;</code>，为强制重新启动指定cron</li><li><code>--no-daemon</code>，前台模式</li><li><code>-i</code>，集群模式</li></ul><h2 id="管理进程"><a href="#管理进程" class="headerlink" title="管理进程"></a>管理进程</h2><p><code>pm2 restart|reload|stop|delete app_name|all|id</code></p><h2 id="集群模式-Cluster-mode"><a href="#集群模式-Cluster-mode" class="headerlink" title="集群模式(Cluster mode)"></a>集群模式(Cluster mode)</h2><p><code>pm2 start app.js -i max</code></p><blockquote><p><code>0</code>和<code>max</code>将使用LB启动最大进程，具体取决于可用的cpu</p></blockquote><p><code>pm2 scale app +3</code></p><blockquote><p>增加三个workers</p></blockquote><p><code>pm2 scale app 2</code></p><blockquote><p>调整workers数量至2</p></blockquote><h2 id="显示信息"><a href="#显示信息" class="headerlink" title="显示信息"></a>显示信息</h2><p><code>pm2 [list|ls|status]</code></p><blockquote><p>展示所有的进程</p></blockquote><p><code>pm2 logs</code></p><blockquote><p>显示进程的logs</p></blockquote><h2 id="Ecosystem-File"><a href="#Ecosystem-File" class="headerlink" title="Ecosystem File"></a>Ecosystem File</h2><p><a href="https://pm2.keymetrics.io/docs/usage/application-declaration/#ecosystem-file" target="_blank" rel="noopener">https://pm2.keymetrics.io/docs/usage/application-declaration/#ecosystem-file</a></p><h2 id="热升级"><a href="#热升级" class="headerlink" title="热升级"></a>热升级</h2><ol><li><code>npm install pm2@latest -g</code></li><li><code>pm2 update</code></li></ol>]]></content>
    
    
    <categories>
      
      <category>nodejs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>nodejs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>padding,magin设置百分比</title>
    <link href="/2020/07/22/notes/web/CSS/padding,magin%E8%AE%BE%E7%BD%AE%E7%99%BE%E5%88%86%E6%AF%94/"/>
    <url>/2020/07/22/notes/web/CSS/padding,magin%E8%AE%BE%E7%BD%AE%E7%99%BE%E5%88%86%E6%AF%94/</url>
    
    <content type="html"><![CDATA[<p>padding,margin的百分比是相对于父元素宽度，如果父元素有宽度，相对于父元素宽度，如果没有，找其父辈元素的宽度，均没设宽度时，相对于屏幕的宽度。</p>]]></content>
    
    
    <categories>
      
      <category>css</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTPS页面发送HTTP请求</title>
    <link href="/2020/07/15/notes/web/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/HTTPS%E9%A1%B5%E9%9D%A2%E5%8F%91%E9%80%81HTTP%E8%AF%B7%E6%B1%82/"/>
    <url>/2020/07/15/notes/web/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/HTTPS%E9%A1%B5%E9%9D%A2%E5%8F%91%E9%80%81HTTP%E8%AF%B7%E6%B1%82/</url>
    
    <content type="html"><![CDATA[<p>混合内容，是因为同时加载了 HTTP 和 HTTPS 内容以显示同一个页面，且通过 HTTPS 加载的初始请求是安全的。现代浏览器会针对此类型的内容显示警告，以向用户表明此页面包含不安全的资源。</p><p>浏览器会<strong>根据不同的混合内容类型</strong>进行警告或拦截。</p><h2 id="HTTPS-的优势"><a href="#HTTPS-的优势" class="headerlink" title="HTTPS 的优势"></a>HTTPS 的优势</h2><ul><li>身份验证<ul><li>HTTPS 让浏览器检查并确保其已打开正确的网站，并且没有被重定向到恶意的网站。</li></ul></li><li>数据完整性<ul><li>HTTPS 让浏览器检测是否有攻击者更改了浏览器接收的任何数据。</li></ul></li><li>保密性<ul><li>HTTPS 可防止攻击者窃取浏览器的请求，跟踪访问的网站或窃取已发送或接收的信息。</li></ul></li></ul><h2 id="混合内容类型与相关安全威胁"><a href="#混合内容类型与相关安全威胁" class="headerlink" title="混合内容类型与相关安全威胁"></a>混合内容类型与相关安全威胁</h2><p>混合内容有两种：主动混合内容和被动混合内容</p><p><strong>被动混合内容</strong>指的是<strong>不与页面其余部分进行交互</strong>的内容，从而使中间人攻击在拦截或更改该内容时能够执行的操作受限。<strong>被动混合内容包括图像、视频和音频内容</strong>，以及无法与页面其余部分进行交互的其他资源。大多数浏览器仍向用户渲染此类型的混合内容，但是也会显示警告，因为这些内容会给您的网站和用户带来安全风险和隐私风险。</p><p><strong>主动混合内容</strong>作为整体<strong>与页面进行交互</strong>，并且几乎允许攻击者对页面进行任何操作。 主动混合内容包括浏览器<strong>可下载和执行的脚本、样式表、iframe、flash 资源及其他代码</strong>。许多浏览器都会默认阻止此类型的内容。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developers.google.com/web/fundamentals/security/prevent-mixed-content/what-is-mixed-content?hl=zh-cn#_11" target="_blank" rel="noopener">https://developers.google.com/web/fundamentals/security/prevent-mixed-content/what-is-mixed-content?hl=zh-cn#_11</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>浏览器</tag>
      
      <tag>http</tag>
      
      <tag>https</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链接不添加协议</title>
    <link href="/2020/07/14/notes/web/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/%E9%93%BE%E6%8E%A5%E4%B8%8D%E6%B7%BB%E5%8A%A0%E5%8D%8F%E8%AE%AE/"/>
    <url>/2020/07/14/notes/web/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/%E9%93%BE%E6%8E%A5%E4%B8%8D%E6%B7%BB%E5%8A%A0%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<p><a href="https://my.oschina.net/u/205403/blog/151919" target="_blank" rel="noopener">https://my.oschina.net/u/205403/blog/151919</a></p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"//www.ludou.org/logo.png"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">""</span> /&gt;</span></code></pre></div><p>以上不写协议的方式，浏览器照样可以正常引用相应的资源,这项解决方案称为protocol-relative URL，暂且可译作 协议相对 URL。</p><p>使用协议相对 URL，无论你是使用HTTPS，还是HTTP访问页面，浏览器都会以与你相同的协议请求页面中的资源，避免弹出警告信息</p>]]></content>
    
    
    
    <tags>
      
      <tag>http</tag>
      
      <tag>url</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跨域方法</title>
    <link href="/2020/07/14/notes/web/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/%E8%B7%A8%E5%9F%9F/"/>
    <url>/2020/07/14/notes/web/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/%E8%B7%A8%E5%9F%9F/</url>
    
    <content type="html"><![CDATA[<p>浏览器中有 同源策略 ，即一个域下的页面中，无法通过 Ajax 获取到其他域的接口。例如有一个接口<code>http://m.juejin.com/course/ajaxcourserecom?cid=459</code>，你自己的一个页面<code>http://www.yourname.com/page1.html</code>中的 Ajax 无法获取这个接口。</p><h2 id="1-怎样算是跨域"><a href="#1-怎样算是跨域" class="headerlink" title="1 怎样算是跨域"></a>1 怎样算是跨域</h2><p>url 哪些地方不同算作跨域？</p><ul><li>协议</li><li>域名</li><li>端口</li></ul><p>举例</p><p><code>http://www.123.com/index.html</code> 调用 <code>http://www.123.com/server.php</code> （非跨域）</p><p><code>http://www.123.com/index.html</code> 调用 <code>http://www.456.com/server.php</code> （主域名不同:<code>123/456</code>，跨域）</p><p><code>http://abc.123.com/index.html</code> 调用 <code>http://def.123.com/server.php</code> （子域名不同:abc/def，跨域）</p><p><code>http://www.123.com:8080/index.html</code> 调用 <code>http://www.123.com:8081/server.php</code> （端口不同:8080/8081，跨域）</p><p><code>http://www.123.com/index.html</code> 调用 <code>https://www.123.com/server.php</code> （协议不同:<code>http/https</code>，跨域）</p><h2 id="2-特例"><a href="#2-特例" class="headerlink" title="2 特例"></a>2 特例</h2><p>但是 HTML 中几个标签能逃避过同源策略——<code>&lt;script src=&quot;xxx&quot;&gt;</code>、<code>&lt;img src=&quot;xxxx&quot;/&gt;</code>、<code>&lt;link href=&quot;xxxx&quot;&gt;</code>，<code>iframe</code>这些标签的src/href可以加载其他域的资源，不受同源策略限制。</p><p>因此，这使得这三个标签可以做一些特殊的事情。</p><ul><li><code>&lt;img&gt;</code>可以做打点统计，因为统计方并不一定是同域的。除了能跨域之外，<code>&lt;img&gt;</code><strong>几乎没有浏览器兼容问题</strong>，它是一个非常古老的标签。</li><li><code>&lt;script&gt;</code>和<code>&lt;link&gt;</code>可以使用 <strong>CDN</strong>，CDN 基本都是其他域的链接。</li><li>另外<code>&lt;script&gt;</code>还可以实现 <strong>JSONP</strong>，能获取其他域接口的信息，接下来马上讲解。</li></ul><h2 id="3-解决方法"><a href="#3-解决方法" class="headerlink" title="3 解决方法"></a>3 解决方法</h2><h3 id="3-1-JSONP（json数据的包装故称之为jsonp，即json-padding）"><a href="#3-1-JSONP（json数据的包装故称之为jsonp，即json-padding）" class="headerlink" title="3.1 JSONP（json数据的包装故称之为jsonp，即json padding）"></a>3.1 JSONP（json数据的包装故称之为jsonp，即json padding）</h3><p>简而言之，<code>script</code>的src加载的<code>.js</code>的内容为<strong>函数嵌套data</strong>，定义一个全局函数，函数名与<code>.js</code>嵌套的函数名相同，从而得到数据。</p><p>只能<code>GET</code>，不能<code>POST</code></p><h4 id="3-1-1-把js原生封装成了一个通用组件"><a href="#3-1-1-把js原生封装成了一个通用组件" class="headerlink" title="3.1.1 把js原生封装成了一个通用组件"></a>3.1.1 把js原生封装成了一个通用组件</h4><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myjsonp</span>(<span class="hljs-params">URL,callback,callbackname</span>)</span>&#123;    <span class="hljs-comment">//给系统中创建一个全局变量，叫做callbackname，指向callback函数</span>    <span class="hljs-comment">//定义</span>    <span class="hljs-built_in">window</span>[callbackname] = callback;    <span class="hljs-comment">//创建一个script节点</span>    <span class="hljs-keyword">var</span> oscript = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">"script"</span>);    <span class="hljs-comment">//和image不一样，设置src并不会发出HTTP请求</span>    oscript.src = URL;    oscript.type = <span class="hljs-string">"text/javascript"</span>;    <span class="hljs-comment">//script标签的请求是在上树的时候发出，请求的是一个函数的执行语句</span>    <span class="hljs-built_in">document</span>.head.appendChild(oscript);    <span class="hljs-comment">//为了不污染页面，瞬间把script拿掉</span>    <span class="hljs-built_in">document</span>.head.removeChild(oscript);&#125;<span class="hljs-comment">//使用</span>myjsonp(<span class="hljs-string">"http://sclub.jd.com/productpage/p-1217508-s-0-t-3-p-1.htmcallback=abcdefg"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(data);&#125;,<span class="hljs-string">"abcdefg"</span>);</code></pre></div><h4 id="3-1-2-3、jquery中jsonp的用法"><a href="#3-1-2-3、jquery中jsonp的用法" class="headerlink" title="3.1.2 3、jquery中jsonp的用法"></a>3.1.2 3、jquery中jsonp的用法</h4><div class="hljs"><pre><code class="hljs js">$.ajax(<span class="hljs-string">"test.txt"</span>,&#123;    <span class="hljs-comment">//JSON跨域的时候要写一个dataType，注意不是type而是dataType</span>    <span class="hljs-string">"dataType"</span> : <span class="hljs-string">"jsonp"</span>,    <span class="hljs-comment">//要定义的函数名字，因为JSONP不缺执行，缺定义</span>    <span class="hljs-string">"jsonpCallback"</span> : <span class="hljs-string">"fun"</span>,    <span class="hljs-comment">//信息回来之后执行的事情</span>    <span class="hljs-string">"success"</span> : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>&#123;        <span class="hljs-built_in">console</span>.log(data);  <span class="hljs-comment">//这里得到了请求的数据</span>    &#125;&#125;);</code></pre></div><h3 id="3-2-服务器端设置-http-header"><a href="#3-2-服务器端设置-http-header" class="headerlink" title="3.2 服务器端设置 http header"></a>3.2 服务器端设置 http header</h3><p>跨域资源共享(Cross-origin resource sharing, CORS)</p><p>需要在服务器端设置,现在推崇的跨域解决方案是这一种</p><p><code>header(&#39;Access-Control-Allow-Origin:*&#39;);   //允许所有来源访问</code></p><p><code>header(&#39;Access-Control-Allow-Method:POST,GET&#39;);    //允许访问的方式</code></p><h3 id="3-3-代理"><a href="#3-3-代理" class="headerlink" title="3.3 代理"></a>3.3 代理</h3><p>例如<code>www.123.com/index.html</code>需要调用<code>www.456.com/server.php</code>，可以写一个接口<code>www.123.com/server.php</code>，由这个接口在后端去调用<code>www.456.com/server.php</code>并拿到返回值，然后再返回给<code>index.html</code>，这就是一个代理的模式。相当于绕过了浏览器端，自然就不存在跨域问题。</p><h2 id="4-Canvas-图片跨域"><a href="#4-Canvas-图片跨域" class="headerlink" title="4 Canvas 图片跨域"></a>4 Canvas 图片跨域</h2><p><strong>尽管不通过 CORS 就可以在 Canvas 画布中使用图片</strong>，但是这会污染画布。<strong>一旦画布被污染，你就无法读取其数据</strong>。例如，你不能再使用画布的 <code>toBlob()</code>, <code>toDataURL()</code> 或 <code>getImageData()</code> 方法，调用它们会抛出安全错误。这种机制可以避免未经许可拉取远程网站信息而导致的用户隐私泄露。</p><p>HTML 规范中图片有一个 <code>crossorigin</code> 属性，结合合适的 CORS 响应头，就可以实现在画布中使用跨域 <code>&lt;img&gt;</code> 元素的图像。</p><table><thead><tr><th>crossOrigin/CORS</th><th>同域</th><th>跨域无 CORS</th><th>跨域有 CORS</th></tr></thead><tbody><tr><td>default</td><td>支持</td><td>支持渲染，不支持 toDataURL</td><td>支持渲染，不支持 toDataURL</td></tr><tr><td>anonymous</td><td>N/A</td><td>不支持渲染，不支持 toDataURL</td><td>支持渲染，支持 toDataURL</td></tr><tr><td>use-credentials</td><td>N/A</td><td>同上</td><td>支持渲染，不支持 toDataURL</td></tr></tbody></table><p>通过上表，Canvas 可以正常的渲染跨域图片，但是跨域图片只有设置 <code>crossOrigin = &#39;anonymous&#39;</code> 的时候，才支持<code>canvas.toDataURl</code></p><h3 id="为什么不使用同域图片"><a href="#为什么不使用同域图片" class="headerlink" title="为什么不使用同域图片"></a>为什么不使用同域图片</h3><ol><li>cossOrigin 存在兼容性问题</li><li>现在的前端开发一般都是将静态资源放置到 CDN 上，例如：阿里云或者腾讯云服务，并且会有一个专门的域名来访问这些资源。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>跨域</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>web缓存</title>
    <link href="/2020/07/14/notes/web/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/%E7%BC%93%E5%AD%98(Cache)/"/>
    <url>/2020/07/14/notes/web/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/%E7%BC%93%E5%AD%98(Cache)/</url>
    
    <content type="html"><![CDATA[<h2 id="0-强缓存-弱缓存（协商缓存）"><a href="#0-强缓存-弱缓存（协商缓存）" class="headerlink" title="0 强缓存 弱缓存（协商缓存）"></a>0 强缓存 弱缓存（协商缓存）</h2><h3 id="0-1-强缓存"><a href="#0-1-强缓存" class="headerlink" title="0.1 强缓存"></a>0.1 强缓存</h3><p>不需要发送请求到服务端，直接读取浏览器本地缓存，在 Chrome 的 Network 中显示的 HTTP 状态码是 200 ，在 Chrome 中，强缓存又分为 Disk Cache (存放在硬盘中)和 Memory Cache (存放在内存中)，存放的位置是由浏览器控制的。</p><p>优先级：</p><p>Pragma &gt; Cache-Control &gt; Expires</p><p>Exprires的值为服务端返回的数据到期时间，但由于服务端时间和客户端时间可能有误差，这也将导致缓存命中的误差</p><p>Cache-Control有很多属性，不同的属性代表的意义也不同。</p><ul><li>max-age：单位是<strong>秒</strong>，缓存时间计算的方式是距离发起的时间的秒数，超过间隔的秒数缓存失效</li><li>no-cache：不使用强缓存，需要与服务器验证缓存是否新鲜</li><li>no-store：禁止使用缓存（包括协商缓存），每次都向服务器请求最新的资源</li><li>private：专用于个人的缓存，中间代理、CDN 等不能缓存此响应</li><li>public：响应可以被中间代理、CDN 等缓存</li><li>must-revalidate：在缓存过期前可以使用，过期后必须向服务器验证</li></ul><p>Pragma 只有一个属性值，就是 no-cache ，效果和 Cache-Control 中的 no-cache 一致，不使用强缓存，需要与服务器验证缓存是否新鲜，在 3 个头部属性中的优先级最高。</p><h3 id="0-2-弱缓存"><a href="#0-2-弱缓存" class="headerlink" title="0.2 弱缓存"></a>0.2 弱缓存</h3><p>当浏览器的强缓存失效的时候或者请求头中设置了不走强缓存</p><p>浏览器第一次请求数据时，服务器会将缓存标识与数据一起响应给客户端，客户端将它们备份至缓存中。再次请求时，客户端会将缓存中的标识发送给服务器，服务器根据此标识判断。若未失效，返回304状态码，浏览器拿到此状态码就可以直接使用缓存数据了。</p><p>Last-Modified和Etag</p><p>Last-Modified： <strong>服务器在响应</strong>请求时，会告诉浏览器资源的最后修改时间。</p><p>if-Modified-Since: <strong>浏览器再次请求</strong>服务器的时候，请求头会包含此字段</p><ul><li>如果真的被修改：那么开始传输响应一个整体，服务器返回：200 OK</li><li>如果没有被修改：那么只需传输响应header，服务器返回：304 Not Modified</li></ul><p>Etag<strong>服务器响应</strong>请求时，通过此字段告诉浏览器当前资源在服务器生成的唯一标识</p><p>If-None-Match： <strong>浏览器再次请求</strong>服务器时，浏览器的请求报文头部会包含此字段</p><h2 id="1-Web缓存"><a href="#1-Web缓存" class="headerlink" title="1 Web缓存"></a>1 Web缓存</h2><p>WEB缓存(cache)位于Web服务器和客户端之间。</p><p>带指纹资源(hash值): 永久缓存<br>非带指纹资源: 每次进行新鲜度校验</p><h3 id="1-1-与缓存相关的http扩展消息头"><a href="#1-1-与缓存相关的http扩展消息头" class="headerlink" title="1.1 与缓存相关的http扩展消息头"></a>1.1 与缓存相关的http扩展消息头</h3><p><code>Expires</code>：指示响应内容过期的时间，格林威治时间GMT</p><p><code>Cache-Control</code>：更细致的控制缓存的内容  <code>max-age</code>就是确定缓存的时间。不添加<code>Cache-Control</code>会对资源进行<strong>强制缓存</strong></p><p><code>Last-Modified</code>：响应中资源最后一次修改的时间</p><p><code>ETag</code>：响应中资源的校验值，在服务器上某个时段是唯一标识的。</p><p><code>Date</code>：服务器的时间</p><p><code>If-Modified-Since</code>：客户端存取的该资源最后一次修改的时间，同Last-Modified。</p><p><code>If-None-Match</code>：客户端存取的该资源的检验值，同ETag。</p><h3 id="1-2-缓存（cache）生效的过程"><a href="#1-2-缓存（cache）生效的过程" class="headerlink" title="1.2 缓存（cache）生效的过程"></a>1.2 缓存（cache）生效的过程</h3><ol><li>服务器收到请求时，会在<code>200OK</code>中回送该资源的<code>Last-Modified</code>和<code>ETag</code>头</li><li>客户端将该资源保存在<code>cache</code>中，并记录这两个属性。</li><li>当客户端需要发送相同的请求时，会在请求中携带<code>If-Modified-Since</code>和<code>If-None-Match</code>两个头。两个头的值分别是响应中<code>Last-Modified</code>和<code>ETag</code>头的值。</li><li>服务器通过这两个头判断本地资源未发生变化，客户端不需要重新下载，返回<code>304</code>响应</li></ol><h3 id="1-3-http的缓存机制"><a href="#1-3-http的缓存机制" class="headerlink" title="1.3 http的缓存机制"></a>1.3 http的缓存机制</h3><p>HTTP定义了3种缓存机制：</p><ol><li><code>Freshness</code>：允许一个回应消息可以在源服务器不被重新检查，并且可以由服务器和客户端来控制。例如，Expires回应头给了一个文档不可用的时间。Cache-Control中的max-age标识指明了缓存的最长时间;</li><li><code>Validation</code>：用来检查以一个缓存的回应是否仍然可用。例如，如果一个回应有一个<code>Last-Modified</code>回应头，缓存能够使用<code>If-Modified-Since</code>来判断是否已改变，以便判断根据情况发送请求;</li><li><code>Invalidation</code>： 在另一个请求通过缓存的时候，常常有一个副作用。例如，如果一个URL关联到一个缓存回应，但是其后跟着POST、PUT和DELETE的请求的话，缓存就会过期。</li></ol><h3 id="1-4-断点续传和多线程下载的原理"><a href="#1-4-断点续传和多线程下载的原理" class="headerlink" title="1.4 断点续传和多线程下载的原理"></a>1.4 断点续传和多线程下载的原理</h3><ol><li>HTTP协议的GET方法，支持只请求某个资源的某一部分;<ol><li>206 Partial Content 部分内容响应;</li><li>Range 请求的资源范围;</li><li>Content-Range 响应的资源范围;</li></ol></li></ol><h3 id="1-5-分层次缓存的打包方案，这是一个建议方案"><a href="#1-5-分层次缓存的打包方案，这是一个建议方案" class="headerlink" title="1.5 分层次缓存的打包方案，这是一个建议方案"></a>1.5 分层次缓存的打包方案，这是一个建议方案</h3><ul><li>webpack-runtime: 应用中的 webpack 的版本比较稳定，分离出来，保证长久的永久缓存</li><li>react/react-dom: react 的版本更新频次也较低</li><li>vendor: 常用的第三方模块打包在一起，如 lodash，classnames 基本上每个页面都会引用到，但是它们的更新频率会更高一些。另外对低频次使用的第三方模块不要打进来</li><li>pageA: A 页面，当 A 页面的组件发生变更后，它的缓存将会失效</li><li>pageB: B 页面</li><li>echarts: 不常用且过大的第三方模块单独打包</li><li>mathjax: 不常用且过大的第三方模块单独打包</li><li>jspdf: 不常用且过大的第三方模块单独打包</li></ul><p>因此为了更好的缓存效果以及按需加载，也有很多方案建议把所有的第三方模块进行单模块打包。</p><h3 id="1-6-强缓存和协商缓存"><a href="#1-6-强缓存和协商缓存" class="headerlink" title="1.6 强缓存和协商缓存"></a>1.6 强缓存和协商缓存</h3><ul><li>强缓存（200 from cache）时，浏览器如果判断本地缓存未过期，就直接使用，无需发起http请求</li><li>协商缓存（304）时，浏览器会向服务端发起http请求，然后服务端告诉浏览器文件未改变，让浏览器使用本地缓存</li></ul><h4 id="1-6-1-怎么区分"><a href="#1-6-1-怎么区分" class="headerlink" title="1.6.1 怎么区分"></a>1.6.1 怎么区分</h4><p>属于强缓存控制的：</p><div class="hljs"><pre><code class="hljs txt">（http1.1）Cache-Control&#x2F;Max-Age（http1.0）Pragma&#x2F;Expires</code></pre></div><p>属于协商缓存控制的：</p><div class="hljs"><pre><code class="hljs txt">（http1.1）If-None-Match&#x2F;E-tag（http1.0）If-Modified-Since&#x2F;Last-Modified</code></pre></div><h4 id="1-6-2-Max-Age相比Expires"><a href="#1-6-2-Max-Age相比Expires" class="headerlink" title="1.6.2 Max-Age相比Expires"></a>1.6.2 Max-Age相比Expires</h4><p>Expires使用的是服务器端的时间</p><p>而Max-Age使用的是客户端本地时间的计算</p><h4 id="1-6-3-E-tag相比Last-Modified"><a href="#1-6-3-E-tag相比Last-Modified" class="headerlink" title="1.6.3 E-tag相比Last-Modified"></a>1.6.3 E-tag相比Last-Modified</h4><p>Last-Modified：</p><ul><li>表明服务端的文件最后何时改变的</li><li>它有一个缺陷就是只能精确到1s，</li><li>然后还有一个问题就是有的服务端的文件会周期性的改变，导致缓存失效</li></ul><p>E-tag：</p><ul><li>是一种指纹机制，代表文件相关指纹</li><li>只有文件变才会变，也只要文件变就会变，</li><li>也没有精确时间的限制，只要文件一遍，立马E-tag就不一样了</li></ul><p>同时带有E-tag和Last-Modified，服务端会优先检查E-tag</p>]]></content>
    
    
    
    <tags>
      
      <tag>http</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用http请求头和相应头</title>
    <link href="/2020/07/14/notes/web/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/%E5%B8%B8%E7%94%A8http%E8%AF%B7%E6%B1%82%E5%A4%B4%E5%92%8C%E7%9B%B8%E5%BA%94%E5%A4%B4/"/>
    <url>/2020/07/14/notes/web/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/%E5%B8%B8%E7%94%A8http%E8%AF%B7%E6%B1%82%E5%A4%B4%E5%92%8C%E7%9B%B8%E5%BA%94%E5%A4%B4/</url>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.im/post/5c17d3cd5188250d9e604628" target="_blank" rel="noopener">https://juejin.im/post/5c17d3cd5188250d9e604628</a></p><h2 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h2><h3 id="Accept"><a href="#Accept" class="headerlink" title="Accept"></a>Accept</h3><p><code>*/*</code>   代表浏览器可以处理所有类型</p><h3 id="Accept-Encoding"><a href="#Accept-Encoding" class="headerlink" title="Accept-Encoding"></a>Accept-Encoding</h3><p><code>gzip, deflate</code>:自己接收的编码方法</p><h3 id="Accept-Language"><a href="#Accept-Language" class="headerlink" title="Accept-Language"></a>Accept-Language</h3><p>申明自己接收的语言</p><h3 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h3><p><code>keep-alive</code>:用于传输HTTP数据的TCP连接不会关闭</p><p><code>close</code>:用于传输HTTP数据的TCP连接会关闭,再次发送Request，需要重新建立TCP连接。</p><h3 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h3><p><code>www.baidu.com</code>:用于指定被请求资源的Internet主机和端口号</p><h3 id="Referer"><a href="#Referer" class="headerlink" title="Referer"></a>Referer</h3><p>告诉服务器我是从哪个页面链接过来的</p><h3 id="User-Agent"><a href="#User-Agent" class="headerlink" title="User-Agent"></a>User-Agent</h3><p>告诉HTTP服务器， 客户端使用的操作系统和浏览器的名称和版本。</p><h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><p><code>private</code>: 默认为private  响应只能够作为私有的缓存</p><p><code>public</code>:多级缓存</p><p><code>must-revalidate</code>:必须到服务器端去验证它是不是仍然是最新的</p><p><code>no-cache</code>:不设置强缓存，设置弱缓存</p><p><code>max-age=10</code>:最大的有效时间,单位是秒</p><p><code>no-store</code>:强缓存,弱缓存都不设置</p><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>用来存储一些用户信息以便让服务器辨别用户身份</p><h3 id="Range（用于断点续传）"><a href="#Range（用于断点续传）" class="headerlink" title="Range（用于断点续传）"></a>Range（用于断点续传）</h3><p><code>bytes=0-5</code>:指定第一个字节的位置和最后一个字节的位置。用于告诉服务器自己想取对象的哪部分。</p><h2 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h2><h3 id="Cache-Control-1"><a href="#Cache-Control-1" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><p>强缓存</p><p><code>private</code> 默认为private</p><p><code>public</code> 浏览器和缓存服务器都可以缓存页面信息。</p><p><code>Cachemust-revalidate</code>  对于客户机的每次请求，代理服务器必须想服务器验证缓存是否过时。</p><p><code>no-cache</code>  浏览器和缓存服务器都不应该缓存页面信息。</p><p><code>max-age=10</code>  是通知浏览器10秒之内不要烦我，自己从缓冲区中刷新。</p><p><code>no-store</code> 请求和响应的信息都不应该被存储在对方的磁盘系统中。</p><h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h3><p><code>Sun, 1 Jan 2000 01:00:00 GMT</code>: 强缓存,服务器时间</p><h3 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a>Last-Modified</h3><p><code>Dec, 26 Dec 2015 17:30:00 GMT</code>: 协商缓存,所请求的对象的最后修改日期</p><h3 id="Etag"><a href="#Etag" class="headerlink" title="Etag"></a>Etag</h3><p><code>737060cd8c284d8af7ad3082f209582d</code>：协商缓存</p><h3 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content-Type"></a>Content-Type</h3><p>告诉客户端，资源文件的类型，还有字符编码</p><p><code>charset=UTF-8</code>: 字符编码</p><p><code>boundary</code>：多用于上传文件时使用，用于分割数据；</p><p><code>application/x-www-form-urlencoded</code>: 最常见的 POST 提交数据的方式,key 和 val 都进行了 URL 转码</p><p><code>multipart/form-data</code>: 常见的 POST 数据提交的方式,一般用来上传文件</p><p><code>application/json</code>: 消息主体是序列化后的 JSON 字符串</p><p><code>text/xml</code>:  HTTP 作为传输协议，XML 作为编码方式</p><p><code>text/plain</code></p><p><code>text/html</code></p><p><code>text/css</code></p><p><code>text/javascript</code></p><h3 id="Content-Encoding"><a href="#Content-Encoding" class="headerlink" title="Content-Encoding"></a>Content-Encoding</h3><p><code>gzip</code></p><h3 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h3><p><code>Tue, 03 Apr 2018 03:52:28 GMT</code>: 服务端发送资源时的<strong>服务器时间</strong>，GMT是格林尼治所在地的标准时间。http协议中发送的时间都是GMT的</p><h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><p><code>Tengine/1.4.6</code>  这个是服务器和相对应的版本</p><h3 id="Transfer-Encoding"><a href="#Transfer-Encoding" class="headerlink" title="Transfer-Encoding"></a>Transfer-Encoding</h3><p><code>chunked</code>: 告诉客户端，服务器发送的资源的方式是分块发送的。一般分块发送的资源都是服务器动态生成的，在发送时还不知道发送资源的大小，所以采用分块发送，每一块都是独立的，独立的块都能标示自己的长度，最后一块是0长度的，当客户端读到这个0长度的块时，就可以确定资源已经传输完了。</p><h3 id="Connection-1"><a href="#Connection-1" class="headerlink" title="Connection"></a>Connection</h3><p><code>keep-alive</code></p><h3 id="Refresh"><a href="#Refresh" class="headerlink" title="Refresh"></a>Refresh</h3><p><code>5; url=http://baidu.com</code>: 用于重定向，或者当一个新的资源被创建时。默认会在5秒后刷新重定向。</p><h3 id="Access-Control-Allow"><a href="#Access-Control-Allow" class="headerlink" title="Access-Control-Allow-*"></a>Access-Control-Allow-*</h3><p><code>Access-Control-Allow-Origin: *</code>: 所有网站可以跨域资源共享,且<code>Access-Control-Allow-Credentials</code>就不能为true</p><p><code>Access-Control-Allow-Origin: www.baidu.com</code></p><p><code>Access-Control-Allow-Methods</code>: GET,POST,PUT,DELETE  允许哪些方法来访问</p><p><code>Access-Control-Allow-Credentials</code>: 是否允许发送cookie。</p><h3 id="Content-Range"><a href="#Content-Range" class="headerlink" title="Content-Range"></a>Content-Range</h3><p><code>bytes 0-5/7877</code>: 指定整个实体中的一部分的插入位置，他也指示了整个实体的长度。在服务器向客户返回一个部分响应，它必须描述响应覆盖的范围和整个实体长度。</p>]]></content>
    
    
    
    <tags>
      
      <tag>http</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器存储</title>
    <link href="/2020/07/14/notes/web/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/%E5%AD%98%E5%82%A8(Storage)/"/>
    <url>/2020/07/14/notes/web/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/%E5%AD%98%E5%82%A8(Storage)/</url>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.im/post/5ed9c9ea51882542f346fd49" target="_blank" rel="noopener">https://juejin.im/post/5ed9c9ea51882542f346fd49</a></p><h2 id="1-Cookies"><a href="#1-Cookies" class="headerlink" title="1 Cookies"></a>1 Cookies</h2><p><code>document.cookie</code></p><h3 id="1-1-Cookie的作用"><a href="#1-1-Cookie的作用" class="headerlink" title="1.1 Cookie的作用"></a>1.1 Cookie的作用</h3><ul><li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li><li>个性化设置（如用户自定义设置、主题等）</li><li>浏览器行为跟踪（如跟踪分析用户行为等）</li></ul><h3 id="1-2-Cookie-的优点"><a href="#1-2-Cookie-的优点" class="headerlink" title="1.2 Cookie 的优点"></a>1.2 Cookie 的优点</h3><ol><li>控制cookie的生命期，使之不会永远有效。</li><li>极高的扩展性和可用性</li><li>帮助服务端承担了很大的压力</li></ol><h3 id="1-3-Cookie-的缺点"><a href="#1-3-Cookie-的缺点" class="headerlink" title="1.3 Cookie 的缺点"></a>1.3 Cookie 的缺点</h3><ul><li>数量(分浏览器)和长度的限制。每个cookie长度不能超过4KB</li><li>安全性，如果cookie被人拦截了，那人就可以取得所有的session信息，原样转发cookie就可以达到目的</li><li>增加请求大小</li><li>解析也很复杂</li></ul><h3 id="1-4-和session的区别"><a href="#1-4-和session的区别" class="headerlink" title="1.4 和session的区别"></a>1.4 和<code>session</code>的区别</h3><ol><li>cookie数据存放在客户端，session数据放在服务器上。</li><li>cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑到安全应当使用session。</li><li>session会在一定时间内保存在服务器上，当访问增多，会比较占用你服务器的性能，考虑性能应当使用cookie。</li><li>不同浏览器对cookie的数据大小限制不同，个数限制也不相同。</li><li>可以考虑将登陆信息等重要信息存放为session，不重要的信息可以放在cookie中。</li></ol><h3 id="1-5-SameSite属性"><a href="#1-5-SameSite属性" class="headerlink" title="1.5 SameSite属性"></a>1.5 SameSite属性</h3><p>Chrome 51 开始，浏览器的 Cookie 新增加了一个<code>SameSite</code>属性，用来防止 CSRF 攻击和用户追踪。</p><p>为了恶意网站的Cookie请求的攻击，表单一般都带有一个随机 token，告诉服务器这是真实请求。</p><p>这种第三方网站引导发出的 Cookie，就称为第三方 Cookie。它除了用于 CSRF 攻击，还可以用于用户追踪。</p><p>Cookie 的SameSite属性用来限制第三方 Cookie，从而减少安全风险。</p><p>它可以设置三个值。</p><h4 id="Strict"><a href="#Strict" class="headerlink" title="Strict"></a>Strict</h4><p>完全禁止第三方 Cookie，可能造成非常不好的用户体验，比如跳转后总是未登陆状态</p><h4 id="Lax"><a href="#Lax" class="headerlink" title="Lax"></a>Lax</h4><p>大多数情况也是不发送第三方 Cookie，但是导航到目标网址的 Get 请求除外。</p><p><code>Set-Cookie: CookieName=CookieValue; SameSite=Lax;</code></p><p>导航到目标网址的 GET 请求，只包括三种情况：链接，预加载请求，GET 表单。</p><h4 id="None"><a href="#None" class="headerlink" title="None"></a>None</h4><h3 id="1-6-token"><a href="#1-6-token" class="headerlink" title="1.6 token"></a>1.6 token</h3><p>Token 是在服务端产生的。如果前端使用用户名/密码向服务端请求认证，服务端认证成功，那么在服务端会返回 Token 给前端。前端可以在每次请求的时候带上 Token 证明自己的合法地位</p><ul><li>Token 完全由应用管理，所以它可以避开同源策略</li><li>使用Token 可以避免 CSRF 攻击</li><li>Token 可以是无状态的，可以在多个服务间共享</li></ul><h2 id="2-sessionStorage-和-localStorage"><a href="#2-sessionStorage-和-localStorage" class="headerlink" title="2 sessionStorage 和 localStorage"></a>2 sessionStorage 和 localStorage</h2><h3 id="2-1-sessionStorage"><a href="#2-1-sessionStorage" class="headerlink" title="2.1 sessionStorage"></a>2.1 sessionStorage</h3><ul><li>容量大小约为5M左右,该方式的生命周期为<strong>关闭浏览器窗口</strong>为止</li><li>同源的同窗口,即使刷新页面或进入同源另一页面，数据仍然存在。</li></ul><p>实质上是保存在session对象</p><h3 id="2-2-localStorage"><a href="#2-2-localStorage" class="headerlink" title="2.2 localStorage"></a>2.2 localStorage</h3><ul><li>容量大小约为20M左右,可以用多个iframe方式使用多个域名来突破限制</li><li>存储的数据不会随着用户浏览时会话过期而过期</li><li>但会应用户的请求而删除</li><li>浏览器也因为存储空间的限制或安全原因删除它们</li><li>而且类型存储的数据可以同一个浏览器的<strong>多个窗口共享</strong></li></ul><p>注意点:<strong>只能存储字符串</strong>，如果是json对象的话,可以将对象JSON.stringify() 编码后存储</p><h3 id="2-3-方法详解"><a href="#2-3-方法详解" class="headerlink" title="2.3 方法详解"></a>2.3 方法详解</h3><ul><li><code>setItem(key, value)</code> 设置存储内容,注意<a href="https://iammapping.com/the-other-ways-to-use-localstorage/" target="_blank" rel="noopener">错误处理</a></li><li><code>getItem(key)</code> 读取存储内容</li><li><code>removeItem(key)</code> 删除键值为key的存储内容</li><li><code>clear()</code> 清空所有存储内容</li><li><code>window.addEventListener(&#39;storage&#39;, callback)</code>响应变化</li></ul><p>一旦键名设置成功，则不允许修改，也不能重复，若重复，会覆盖原有的键名值</p><h3 id="2-4-设置过期时间"><a href="#2-4-设置过期时间" class="headerlink" title="2.4 设置过期时间"></a>2.4 设置过期时间</h3><ol><li>存储的值加一个时间戳，下次取值时验证时间戳。</li><li>扩展Storage</li></ol><h2 id="IndexedDB"><a href="#IndexedDB" class="headerlink" title="IndexedDB"></a>IndexedDB</h2><p>允许储存大量数据，提供查找接口，还能建立索引。不属于关系型数据库，更接近 NoSQL 数据库</p><p>特点：</p><ol><li><p>键值对储存。 IndexedDB 内部采用对象仓库（object store）存放数据。<strong>所有类型的数据都可以直接存入</strong>，包括 JavaScript 对象。对象仓库中，数据以”键值对”的形式保存，每一个数据记录都有对应的主键，主键是独一无二的，不能有重复，否则会抛出一个错误。</p></li><li><p>异步。 IndexedDB 操作时不会锁死浏览器，用户依然可以进行其他操作，这与 LocalStorage 形成对比，<strong>后者的操作是同步的</strong>。异步设计是为了防止大量数据的读写，拖慢网页的表现。</p></li><li><p>支持事务。 IndexedDB 支持事务（transaction），这意味着一系列操作步骤之中，只要有一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，不存在只改写一部分数据的情况。</p></li><li><p>同源限制 IndexedDB <strong>受到同源限制</strong>，每一个数据库对应创建它的域名。网页只能访问自身域名下的数据库，而不能访问跨域的数据库。</p></li><li><p>储存空间大 IndexedDB 的储存空间比 LocalStorage 大得多，<strong>一般来说不少于 250MB，甚至没有上限</strong>。</p></li><li><p>支持二进制储存。 IndexedDB 不仅可以储存字符串，还可以储存二进制数据（ArrayBuffer 对象和 Blob 对象）。</p></li></ol><p>其他： <a href="http://www.ruanyifeng.com/blog/2018/07/indexeddb.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2018/07/indexeddb.html</a></p><h2 id="Web-SQL"><a href="#Web-SQL" class="headerlink" title="Web SQL"></a>Web SQL</h2><p>当前只有谷歌支持，ie和火狐均不支持。</p><p>页面刷新后该库就不存在了。</p><p>与关系数据库的概念比较相似。</p>]]></content>
    
    
    
    <tags>
      
      <tag>浏览器</tag>
      
      <tag>cookie</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xss攻击和csrf攻击</title>
    <link href="/2020/07/14/notes/web/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/xss%E6%94%BB%E5%87%BB%E5%92%8Ccsrf%E6%94%BB%E5%87%BB/"/>
    <url>/2020/07/14/notes/web/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/xss%E6%94%BB%E5%87%BB%E5%92%8Ccsrf%E6%94%BB%E5%87%BB/</url>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/dwqs/blog/issues/68" target="_blank" rel="noopener">https://github.com/dwqs/blog/issues/68</a></p><h2 id="1-CSRF（Cross-site-request-forgery）：跨站请求伪造"><a href="#1-CSRF（Cross-site-request-forgery）：跨站请求伪造" class="headerlink" title="1 CSRF（Cross-site request forgery）：跨站请求伪造"></a>1 CSRF（Cross-site request forgery）：跨站请求伪造</h2><p>原理：转发Cookie(如果该cookie没有过期，即使页面关闭)。不同页面请求同一连接(path内)，会自动携带cookie</p><p>每个 Cookie 都会有与之关联的域，这个域的范围一般通过 donmain 属性指定。</p><p>如果 Cookie 的域和页面的域相同，那么我们称这个 Cookie 为第一方 Cookie（first-party cookie），如果 Cookie 的域和页面的域不同，则称之为第三方 Cookie（third-party cookie）。</p><h3 id="1-1-如何防御"><a href="#1-1-如何防御" class="headerlink" title="1.1 如何防御"></a>1.1 如何防御</h3><h4 id="方法一：Token-验证：（用的最多）"><a href="#方法一：Token-验证：（用的最多）" class="headerlink" title="方法一：Token 验证：（用的最多）"></a>方法一：Token 验证：（用的最多）</h4><p>（1）服务器发送给客户端一个token；</p><p>（2）客户端提交的表单中带着这个token。</p><p>（3）如果这个 token 不合法，那么服务器拒绝这个请求。</p><h4 id="方法二：使用验证码"><a href="#方法二：使用验证码" class="headerlink" title="方法二：使用验证码"></a>方法二：使用验证码</h4><p>只要是涉及到数据交互就先进行验证码验证，这个方法可以完全解决CSRF。</p><h4 id="方法三：Referer-验证-SameSite属性"><a href="#方法三：Referer-验证-SameSite属性" class="headerlink" title="方法三：Referer 验证(SameSite属性)"></a>方法三：Referer 验证(SameSite属性)</h4><p>Referer 指的是页面请求来源。意思是，只接受本站的请求，服务器才做响应；如果不是，就拦截</p><h2 id="2-XSS（Cross-Site-Scripting）：跨域脚本攻击"><a href="#2-XSS（Cross-Site-Scripting）：跨域脚本攻击" class="headerlink" title="2 XSS（Cross Site Scripting）：跨域脚本攻击"></a>2 XSS（Cross Site Scripting）：跨域脚本攻击</h2><p>XSS攻击可以分为3类：反射型（非持久型）、存储型（持久型）、基于DOM。</p><h3 id="2-1-XSS的攻击原理"><a href="#2-1-XSS的攻击原理" class="headerlink" title="2.1 XSS的攻击原理"></a>2.1 XSS的攻击原理</h3><p>不需要你做任何的登录认证，它会通过合法的操作（比如在url中输入、在评论框中输入），向你的页面<strong>注入脚本</strong>（可能是js、hmtl代码块等）。</p><p>最后导致的结果可能是：</p><p>盗用Cookie破坏页面的正常结构，插入广告等恶意内容D-doss攻击</p><h3 id="2-2-XSS的攻击方式"><a href="#2-2-XSS的攻击方式" class="headerlink" title="2.2 XSS的攻击方式"></a>2.2 XSS的攻击方式</h3><h4 id="2-2-1-反射型（非持久型）"><a href="#2-2-1-反射型（非持久型）" class="headerlink" title="2.2.1 反射型（非持久型）"></a>2.2.1 反射型（非持久型）</h4><p>发出请求时，<strong>XSS代码出现在url中，作为输入提交到服务器端，服务器端解析后响应，XSS代码随响应内容一起传回给浏览器，最后浏览器解析执行XSS代码</strong>。这个过程像一次反射，所以叫反射型XSS。</p><p>这种攻击方式往往需要攻击者诱使用户点击一个恶意链接，或者提交一个表单，或者进入一个恶意网站时，注入脚本进入被攻击者的网站。</p><h4 id="2-2-2-存储型（持久型）"><a href="#2-2-2-存储型（持久型）" class="headerlink" title="2.2.2 存储型（持久型）"></a>2.2.2 存储型（持久型）</h4><p>储型XSS和反射型XSS的差别在于，提交的代码<strong>会存储在服务器端</strong>（数据库、内存、文件系统等），下次请求时目标页面时不用再提交XSS代码。</p><p><strong>比较常见的一个场景</strong>是攻击者在社区或论坛上写下一篇包含恶意 JavaScript 代码的文章或评论，文章或评论发表后，所有访问该文章或评论的用户，都会在他们的浏览器中执行这段恶意的 JavaScript 代码。</p><p>XSS的防范措施（encode + 过滤）</p><h4 id="2-2-3-基于DOM"><a href="#2-2-3-基于DOM" class="headerlink" title="2.2.3 基于DOM"></a>2.2.3 基于DOM</h4><p>通过恶意脚本修改页面的 DOM 结构，是纯粹发生在客户端的攻击</p><h3 id="2-3-XSS的防范措施主要有三个"><a href="#2-3-XSS的防范措施主要有三个" class="headerlink" title="2.3 XSS的防范措施主要有三个"></a>2.3 XSS的防范措施主要有三个</h3><p>现在主流的浏览器内置了防范 XSS 的措施，例如 CSP。</p><p>1、对敏感字符做转义(输入，输出)</p><p>(1) HTML：对以下这些字符进行转义：</p><ul><li><code>&amp;：&amp;amp;</code></li><li><code>&lt;：&amp;alt;</code></li><li><code>&gt;：&amp;gt;</code></li><li><code>&#39;：&amp;#x27;</code></li><li><code>&quot;：&amp;quot;</code></li><li><code>/：&amp;#x2F;</code></li></ul><p>(2) Javascript：把所有非字母、数字的字符都转义成小于256的ASCII字符；</p><p>(3)URL：使用Javascript的<code>encodeURIComponent()</code>方法对用户的输入进行编码，该方法会编码如下字符：<code>,      /      ?     :     @     &amp;     =     +     $     #</code></p><p>(4)利用模板引擎而不是拼接HTML</p><p>(5)自动扫描工具寻找潜在的 XSS 漏洞</p><p>2、CSP</p><p>本质上是建立白名单，规定了浏览器只能够执行特定来源的代码，在网站的http头部定义了 <code>Content-Security-Policy</code></p><p>3、Http响应头设置HttpOnly</p><p>cookie中设置了HttpOnly属性，那么通过js脚本将无法读取到cookie信息</p>]]></content>
    
    
    
    <tags>
      
      <tag>http</tag>
      
      <tag>xss</tag>
      
      <tag>csrf</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>URL的编码或解码</title>
    <link href="/2020/07/14/notes/web/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/URL%E7%9A%84%E7%BC%96%E7%A0%81%E6%88%96%E8%A7%A3%E7%A0%81/"/>
    <url>/2020/07/14/notes/web/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/URL%E7%9A%84%E7%BC%96%E7%A0%81%E6%88%96%E8%A7%A3%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h2 id="URL的合法字符"><a href="#URL的合法字符" class="headerlink" title="URL的合法字符"></a>URL的合法字符</h2><p>URL的合法字符表示再浏览器的地址栏中不会被转义的字符，有两种:</p><ol><li>URL元字符：分号（;），逗号（’,’），斜杠（/），问号（?），冒号（:），at（@），&amp;，等号（=），加号（+），美元符号（$），井号（#）</li><li>语义字符：a-z，A-Z，0-9，连词号（-），下划线（_），点（.），感叹号（!），波浪线（~），星号（*），单引号（’），圆括号（()）</li></ol><p>当输入的字符不符合以上的字符时，浏览器就会把该字符转义，规则：根据操作系统的默认编码，将每个字节转为百分号（%）加上两个大写的十六进制字母。</p><h2 id="JavaScript的四个URL编码-解码方法"><a href="#JavaScript的四个URL编码-解码方法" class="headerlink" title="JavaScript的四个URL编码/解码方法"></a>JavaScript的四个URL编码/解码方法</h2><p><code>encodeURI</code>, 将元字符和语义字符之外的字符都进行转义，一般用于知道该URL只用于完整的URL时使用</p><p><code>encodeURIComponent</code>, 将除了语义字符之外的字符进行转义，包括元字符，因此，它的参数通常是URL的路径或参数值，而不是整个URL。</p><p><code>decodeURI</code>, 还原转义后的URL，是encodeURI方法的逆运算。</p><p><code>decodeURIComponent</code>, 还原转义后的URL片段。是encodeURIComponent方法的逆运算。</p>]]></content>
    
    
    
    <tags>
      
      <tag>url</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Url的构成</title>
    <link href="/2020/07/14/notes/web/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/url/"/>
    <url>/2020/07/14/notes/web/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/url/</url>
    
    <content type="html"><![CDATA[<p>URL（Uniform Resource Locator,统一资源定位符），用于定位网络上的资源，每一个信息资源都有统一的且在网上唯一的地址。</p><p>Url一般有以下部分组成<br><code>scheme://host:port/path?query#fragment</code></p><p><code>Scheme</code>: 通信协议，一般为<code>http</code>、<code>https</code>等；<br><code>Host</code>: 服务器的域名主机名或ip地址；<br><code>Port</code>: 端口号，此项为可选项，默认为80；<br><code>Path</code>: 目录，由“/”隔开的字符串，表示的是主机上的目录或文件地址；<br><code>Query</code>: 查询，此项为可选项，可以给动态网页传递参数，用“&amp;”隔开，每个参数的名和值用“=”隔开；<br><code>Fragment</code>: 信息片段，字符串，用于指定网络资源中的某片断</p>]]></content>
    
    
    
    <tags>
      
      <tag>url</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UDP和TCP</title>
    <link href="/2020/07/14/notes/web/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/UDP%E5%92%8CTCP/"/>
    <url>/2020/07/14/notes/web/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/UDP%E5%92%8CTCP/</url>
    
    <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/108822858?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=760863794850197504" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/108822858?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=760863794850197504</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzA4Nzg0MDM5Nw==&amp;mid=2247484896&amp;idx=1&amp;sn=f7a351ffd19f14f8afdccb77557ca306&amp;chksm=90320602a7458f144124f76cc78a9fd87d20c2c51e7c756fb6eccc1672116c6c3ef4bfc9098d&amp;scene=0&amp;xtrack=1#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzA4Nzg0MDM5Nw==&amp;mid=2247484896&amp;idx=1&amp;sn=f7a351ffd19f14f8afdccb77557ca306&amp;chksm=90320602a7458f144124f76cc78a9fd87d20c2c51e7c756fb6eccc1672116c6c3ef4bfc9098d&amp;scene=0&amp;xtrack=1#rd</a></p><p>网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。</p><p>传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。</p><h2 id="1-UDP-和-TCP-的特点与区别"><a href="#1-UDP-和-TCP-的特点与区别" class="headerlink" title="1 UDP 和 TCP 的特点与区别"></a>1 UDP 和 TCP 的特点与区别</h2><p><strong>用户数据报协议 UDP</strong>（User Datagram Protocol）</p><ul><li>是<strong>无连接</strong>的，尽最大可能交付</li><li>没有拥塞控制，具有较好的实时性，工作效率比TCP高</li><li><strong>面向报文</strong>（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部）</li><li>支持一对一、一对多、多对一和多对多的交互通信</li></ul><p><strong>传输控制协议 TCP</strong>（Transmission Control Protocol）</p><ul><li>是<strong>面向连接</strong>的，提供可靠交付</li><li>有流量控制<strong>拥塞控制</strong>，提供<strong>全双工</strong>通信</li><li><strong>面向字节流</strong>（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块）</li><li>每一条 TCP 连接只能是点对点的（一对一）</li></ul><h2 id="2-UDP-、TCP-首部格式"><a href="#2-UDP-、TCP-首部格式" class="headerlink" title="2 UDP 、TCP 首部格式"></a>2 UDP 、TCP 首部格式</h2><p>TCP 的 6 种标识:</p><ul><li>SYN (建立联机)</li><li>ACK (确认)</li><li>PSH (传送)</li><li>FIN (结束)，正常关闭连接</li><li>RST (重置)，用来异常的关闭连接，发送rst段关闭连接时，不必等缓冲区的数据都发送出去，直接丢弃缓冲区中的数据。而接收端收到rst段后，也不必发送ack来确认。</li><li>URG (紧急)</li></ul><h2 id="3-TCP-的三次握手"><a href="#3-TCP-的三次握手" class="headerlink" title="3 TCP 的三次握手"></a>3 TCP 的三次握手</h2><p><img src="http://pic.aizf.ink/md/http/2.webp" alt="avatar"></p><p>TCP 是一种面向连接的单播协议，在发送数据前，通信双方必须在彼此间建立一条连接。<strong>所谓的“连接”，其实是客户端和服务器的内存里保存的一份关于对方的信息，如 IP 地址、端口号等</strong>。</p><ol><li>第一次握手<ol><li>客户端向服务器发出连接请求报文，这时报文首部中的同部位<code>SYN=1</code>，同时随机生成初始序列号 <code>seq=x</code></li><li>此时，TCP客户端进程进入了 <code>SYN-SENT</code>（同步已发送状态）状态。</li></ol></li><li>第二次握手<ol><li>TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 <code>ACK=1</code>，<code>SYN=1</code>，确认号是<code>ack=x+1</code>，同时也要为自己随机初始化一个序列号 <code>seq=y</code></li><li>此时，TCP服务器进程进入了<code>SYN-RCVD</code>（同步收到）状态。</li><li>如果拒绝，</li></ol></li><li>第三次握手<ol><li>客户进程收到确认后，还要向服务器给出确认。确认报文的<code>ACK=1</code>，<code>ack=y+1</code></li><li>此时，TCP连接建立，客户端进入<code>ESTABLISHED</code>（已建立连接）状态。</li></ol></li></ol><h3 id="3-1-为什么要三次握手"><a href="#3-1-为什么要三次握手" class="headerlink" title="3.1 为什么要三次握手"></a>3.1 为什么要三次握手</h3><ol><li>已失效的连接请求报文段<ol><li>client发送了第一个连接的请求报文，但是由于网络不好，直到某个时间才到达server</li><li>server端接收到这个请求报文后，还是会想client发出确认的报文，表示同意连接</li><li>假如不采用三次握手，那么只要server发出确认，新的建立就连接了，但其实这个请求是失效的请求，client是不会理睬server的确认信息</li><li>但是server认为新的连接已经建立起来了，并一直等待client发来数据，这样，server的很多资源就没白白浪费掉了</li></ol></li></ol><h2 id="4-TCP数据的传输过程"><a href="#4-TCP数据的传输过程" class="headerlink" title="4 TCP数据的传输过程"></a>4 TCP数据的传输过程</h2><p>建立连接后，两台主机就可以相互传输数据了。</p><p>TCP会话的双方都各自维护一个<code>发送窗口</code>和一个<code>接收窗口</code>。</p><p>发送方的发送缓存内的数据都可以被分为4类:</p><ol><li>已发送，已收到ACK</li><li>已发送，未收到ACK</li><li>未发送，但允许发送</li><li>未发送，但不允许发送</li></ol><p>其中类型2和3都属于发送窗口。</p><p>接收方的缓存数据分为3类：</p><ol><li>已接收</li><li>未接收但准备接收</li><li>未接收而且不准备接收</li></ol><p>其中类型2属于接收窗口。</p><h3 id="4-1-滑动机制-流量控制"><a href="#4-1-滑动机制-流量控制" class="headerlink" title="4.1 滑动机制(流量控制)"></a>4.1 滑动机制(流量控制)</h3><ol><li>发送窗口只有收到发送窗口内字节的ACK确认，才会移动发送窗口的左边界。ACK包含两个非常重要的信息：<ol><li>一是期望接收到的下一字节的序号n，该n代表接收方已经接收到了前n-1字节数据</li><li>二是当前的窗口大小m</li></ol></li><li>接收窗口只有在前面所有的段都确认的情况下才会移动左边界。当在前面还有字节未接收但收到后面字节的情况下，窗口不会移动，并不对后续字节确认。以此确保对端会对这些数据重传。</li><li>遵循快速重传、累计确认、选择确认等规则。</li><li>发送方发的window size = 8192;就是接收端最多发送8192字节，这个8192一般就是发送方接收缓存的大小。</li></ol><h2 id="5-TCP的四次挥手"><a href="#5-TCP的四次挥手" class="headerlink" title="5 TCP的四次挥手"></a>5 TCP的四次挥手</h2><ol><li>第一次挥手<ol><li>客户端进程发出连接释放报文，并且停止发送数据。</li><li><code>FIN=1</code>，其序列号为<code>seq=u</code>（等于前面已经传送过来的数据的最后一个字节的序号加1）</li><li>此时，客户端进入<code>FIN-WAIT-1</code>（终止等待1）状态</li></ol></li><li>第二次挥手<ol><li>服务器收到连接释放报文，发出确认报文，<code>ACK=1</code>，<code>ack=u+1</code>，并且带上自己的序列号<code>seq=v</code></li><li>此时，服务端就进入了<code>CLOSE-WAIT</code>（关闭等待）状态</li><li>客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。</li><li>客户端收到服务器的确认请求后，此时，客户端就进入<code>FIN-WAIT-2</code>（终止等待2）状态</li></ol></li><li>第三次挥手<ol><li>服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，<code>FIN=1</code>，<code>ack=u+1</code></li><li>序列号为<code>seq=w</code>，此时，服务器就进入了<code>LAST-ACK</code>（最后确认）状态，等待客户端的确认。</li></ol></li><li>第四次挥手<ol><li>客户端收到服务器的连接释放报文后，必须发出确认，<code>ACK=1</code>，<code>ack=w+1</code>，而自己的序列号是<code>seq=u+1</code>，</li><li>此时，客户端就进入了<code>TIME-WAIT</code>（时间等待）状态。</li><li>注意此时TCP连接还没有释放，必须经过2∗∗MSL（<strong>最长报文段寿命</strong>）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。</li><li><strong>服务器</strong>只要收到了客户端发出的确认，立即进入<code>CLOSED</code>状态。</li></ol></li></ol><h3 id="5-1-为什么是4次挥手"><a href="#5-1-为什么是4次挥手" class="headerlink" title="5.1 为什么是4次挥手"></a>5.1 为什么是4次挥手</h3><p><strong>为了确保数据能够完成传输。</strong></p><h3 id="5-2-tcp握手的时候为何ACK-确认-和SYN-建立连接-是一起发送。挥手的时候为什么是分开的时候发送"><a href="#5-2-tcp握手的时候为何ACK-确认-和SYN-建立连接-是一起发送。挥手的时候为什么是分开的时候发送" class="headerlink" title="5.2 tcp握手的时候为何ACK(确认)和SYN(建立连接)是一起发送。挥手的时候为什么是分开的时候发送"></a>5.2 tcp握手的时候为何ACK(确认)和SYN(建立连接)是一起发送。挥手的时候为什么是分开的时候发送</h3><p>关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭 SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步挥手。</p><h3 id="5-3-客户端突然挂掉了怎么办"><a href="#5-3-客户端突然挂掉了怎么办" class="headerlink" title="5.3 客户端突然挂掉了怎么办"></a>5.3 客户端突然挂掉了怎么办</h3><p>解决办法是在服务器端设置<strong>保活计时器</strong>，每当服务器收到客户端的消息，就将计时器复位。超时时间通常设置为2小时。</p><p>若服务器超过2小时没收到客户的信息，他就<strong>发送探测报文段</strong>。若发送了10个探测报文段，每一个相隔75秒，还没有响应就认为客户端出了故障，因而终止该连接。</p><h2 id="6-攻击"><a href="#6-攻击" class="headerlink" title="6 攻击"></a>6 攻击</h2><h3 id="6-1-SYN（洪水）攻击"><a href="#6-1-SYN（洪水）攻击" class="headerlink" title="6.1 SYN（洪水）攻击"></a>6.1 SYN（洪水）攻击</h3><h4 id="6-1-1-什么是-SYN-攻击"><a href="#6-1-1-什么是-SYN-攻击" class="headerlink" title="6.1.1 什么是 SYN 攻击"></a>6.1.1 什么是 SYN 攻击</h4><p>攻击客户端在短时间内伪造大量不存在的IP地址，向服务器不断地发送SYN包，服务器回复确认包，并等待客户的确认。</p><p>由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，导致目标系统运行缓慢，严重者会引起网络堵塞甚至系统瘫痪。SYN 攻击是一种典型的 DoS攻击。</p><h4 id="6-1-2-如何检测-SYN-攻击"><a href="#6-1-2-如何检测-SYN-攻击" class="headerlink" title="6.1.2 如何检测 SYN 攻击"></a>6.1.2 如何检测 SYN 攻击</h4><p>当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。</p><h4 id="6-1-3-如何防御-SYN-攻击"><a href="#6-1-3-如何防御-SYN-攻击" class="headerlink" title="6.1.3 如何防御 SYN 攻击"></a>6.1.3 如何防御 SYN 攻击</h4><p>不能完全被阻止，除非将TCP协议重新设计。我们所做的是尽可能的减轻SYN攻击的危害，常见的防御 SYN 攻击的方法有如下几种：</p><ul><li>缩短超时（SYN Timeout）</li><li>时间增加最大半连接数</li><li>过滤网关防护SYN</li><li>cookies技术</li></ul><h3 id="6-2-rst复位攻击"><a href="#6-2-rst复位攻击" class="headerlink" title="6.2 rst复位攻击"></a>6.2 rst复位攻击</h3><p>A和serverB之间建立了TCP连接。此时C伪造了一个TCP包发给B，使B异常的断开了与A之间的TCP连接，就是RST攻击了。</p><p>两种方式：</p><ol><li>伪装成A发过去的RST包</li><li>伪装成A发过去的SYN包，正常连接时又来建新连接，B会认为A故障，B主动向A发个RST包。并在自己这端强制关掉连接</li></ol><p>如何伪造A的包：</p><p>两个关键因素：源port和序列号</p><p>一个TCP连接都是四元组。由源IP、源port、目标IP、目标port唯一确定一个连接。</p>]]></content>
    
    
    
    <tags>
      
      <tag>tcp</tag>
      
      <tag>udp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>http和https</title>
    <link href="/2020/07/14/notes/web/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/HTTP/"/>
    <url>/2020/07/14/notes/web/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/HTTP/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://zhuanlan.zhihu.com/p/112010468?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=760863794850197504" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/112010468?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=760863794850197504</a></p></blockquote><ul><li>HTTP 是超文本传输协议，也就是HyperText Transfer Protocol。</li><li>HTTP 协议是一个双向协议。</li><li>HTTP 传输的内容是「超文本」。HTML 就是最常见的超文本了</li></ul><p>HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。</p><p>请求报文：请求行、请求头部、空行和请求数据</p><p>响应报文：状态行、消息报头、空行和响应正文</p><h2 id="1-状态码"><a href="#1-状态码" class="headerlink" title="1 状态码"></a>1 状态码</h2><h3 id="1-1-1xx"><a href="#1-1-1xx" class="headerlink" title="1.1 1xx"></a>1.1 1xx</h3><p>1xx 类状态码属于提示信息，是协议处理中的一种中间状态，实际用到的比较少。</p><ul><li>101 Switching Protocols。在HTTP升级为WebSocket的时候，如果服务器同意变更，就会发送状态码 101。</li></ul><h3 id="1-2-2xx"><a href="#1-2-2xx" class="headerlink" title="1.2 2xx"></a>1.2 2xx</h3><p>2xx 类状态码表示服务器成功处理了客户端的请求，也是我们最愿意看到的状态。</p><ul><li>「200 OK」是最常见的成功状态码，<strong>表示一切正常</strong>。如果是非 HEAD 请求，服务器返回的响应头都会有 body 数据，强缓存。</li><li>「204 No Content」也是常见的成功状态码，与 200 OK 基本相同，<strong>但响应头没有 body 数据</strong>。</li><li>「206 Partial Content」是应用于 HTTP <strong>分块下载或断点续传</strong>，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。</li></ul><h3 id="1-3-3xx"><a href="#1-3-3xx" class="headerlink" title="1.3 3xx"></a>1.3 3xx</h3><p>3xx 类状态码表示客户端请求的资源发送了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是<strong>重定向</strong>。</p><ul><li>「301 Moved Permanently」表示<strong>永久重定向</strong>，说明请求的资源已经不存在了，需改用新的 URL 再次访问。</li><li>「302 Moved Permanently」表示<strong>临时重定向</strong>，说明请求的资源还在，但暂时需要用另一个 URL 来访问。<br>301 和 302 都会在响应头里使用字段 Location，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。</li><li>「304 Not Modified」当<strong>协商缓存</strong>命中时会返回这个状态码。<strong>重定向已存在的缓冲文件，也称缓存重定向，用于缓存控制</strong>。</li></ul><h4 id="1-3-1-304"><a href="#1-3-1-304" class="headerlink" title="1.3.1 304"></a>1.3.1 304</h4><p>TODO</p><h3 id="1-4-4xx"><a href="#1-4-4xx" class="headerlink" title="1.4 4xx"></a>1.4 4xx</h3><p>4xx 类状态码表示<strong>客户端发送的报文有误</strong>，服务器无法处理，也就是错误码的含义。</p><ul><li>「400 Bad Request」表示客户端请求的报文有错误，但只是个<strong>笼统的错误</strong>。</li><li>「403 Forbidden」表示服务器<strong>禁止访问</strong>资源，并不是客户端的请求出错。</li><li>「404 Not Found」表示请求的资源在服务器上<strong>不存在</strong>或未找到，所以无法提供给客户端。</li><li>405 Method Not Allowed: 请求方法不被服务器端允许。</li></ul><h3 id="1-5-5xx"><a href="#1-5-5xx" class="headerlink" title="1.5 5xx"></a>1.5 5xx</h3><p>5xx 类状态码表示客户端请求报文正确，但是<strong>服务器</strong>处理时<strong>内部发生了错误</strong>，属于服务器端的错误码。</p><ul><li>「500 Internal Server Error」与 400 类型，是个<strong>笼统</strong>通用的错误码，服务器发生了什么错误，我们并不知道。</li><li>「501 Not Implemented」表示客户端请求的功能<strong>还不支持</strong>，类似“即将开业，敬请期待”的意思。</li><li>「502 Bad Gateway」通常是服务器作为网关或代理时返回的错误码，表示服务器<strong>自身工作正常，访问后端服务器发生了错误</strong>。</li><li>「503 Service Unavailable」表示<strong>服务器当前很忙</strong>，暂时无法响应服务器，类似“网络服务正忙，请稍后重试”的意思。</li></ul><h2 id="2-http-常见字段"><a href="#2-http-常见字段" class="headerlink" title="2 http 常见字段"></a>2 http 常见字段</h2><h3 id="2-1-Host"><a href="#2-1-Host" class="headerlink" title="2.1 Host"></a>2.1 Host</h3><p>指定服务器的域名</p><h3 id="2-2-Content-Length"><a href="#2-2-Content-Length" class="headerlink" title="2.2 Content-Length"></a>2.2 Content-Length</h3><p>服务器在返回数据时，会有 Content-Length 字段，表明<strong>本次</strong>回应的数据长度。</p><h3 id="2-3-Connection"><a href="#2-3-Connection" class="headerlink" title="2.3 Connection"></a>2.3 Connection</h3><p>最常用于客户端要求服务器使用 TCP 持久连接，以便其他请求复用。</p><p>HTTP/1.1 版本的默认连接都是持久连接，但为了兼容老版本的 HTTP，需要指定 Connection 首部字段的值为 Keep-Alive。</p><p><code>Connection: keep-alive</code></p><p>一个可以复用的 TCP 连接就建立了，直到客户端或服务器主动关闭连接。但是，这不是标准字段。</p><h3 id="2-4-Content-Type"><a href="#2-4-Content-Type" class="headerlink" title="2.4 Content-Type"></a>2.4 Content-Type</h3><p>用于服务器回应时，告诉客户端，本次数据是什么格式。</p><p>客户端请求的时候，可以使用 Accept 字段声明自己可以接受哪些数据格式。</p><p><code>Accept-Charset: charset=utf-8</code></p><p><code>Accept: */*</code></p><p><code>Content-Type: text/html; charset=utf-8</code></p><blockquote><p>上面的类型表明，发送的是网页，而且编码是UTF-8。</p></blockquote><p>取值可以分为下面几类:</p><ul><li>text：text/html, text/plain, text/css 等</li><li>image: image/gif, image/jpeg, image/png 等</li><li>audio/video: audio/mpeg, video/mp4 等</li><li>application: application/json, application/javascript, application/pdf, application/- octet-stream</li></ul><h3 id="2-5-Content-Encoding"><a href="#2-5-Content-Encoding" class="headerlink" title="2.5 Content-Encoding"></a>2.5 Content-Encoding</h3><p>说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式</p><p><code>Accept-Encoding: gzip, deflate</code></p><blockquote><p>客户端在请求时，用 Accept-Encoding 字段说明自己可以接受哪些压缩方法。</p></blockquote><p><code>Content-Encoding: gzip</code></p><blockquote><p>表示服务器返回的数据采用了 gzip 方式压缩，告知客户端需要用此方式解压。</p></blockquote><h3 id="2-6-Content-Language"><a href="#2-6-Content-Language" class="headerlink" title="2.6 Content-Language"></a>2.6 Content-Language</h3><p>指定支持的语言</p><h3 id="2-7-如何处理大文件的传输"><a href="#2-7-如何处理大文件的传输" class="headerlink" title="2.7 如何处理大文件的传输"></a>2.7 如何处理大文件的传输</h3><p>HTTP 针对这一场景，采取了范围请求的解决方案，允许客户端仅仅请求一个资源的一部分。</p><p>前提是服务器要支持范围请求,必须加上这样一个响应头:</p><p><code>Accept-Ranges: none</code></p><h2 id="3-GET-与-POST"><a href="#3-GET-与-POST" class="headerlink" title="3 GET 与 POST"></a>3 GET 与 POST</h2><p><a href="https://www.zhihu.com/question/28586791" target="_blank" rel="noopener">https://www.zhihu.com/question/28586791</a></p><p>本质都是tcp/ip</p><p>Get 方法的含义是请求从服务器<strong>获取</strong>资源，这个资源可以是静态的文本、页面、图片视频等。</p><p>POST 方法，它向 URI 指定的资源<strong>提交</strong>数据，数据就放在报文的 body 里。</p><h3 id="3-1-安全和幂等"><a href="#3-1-安全和幂等" class="headerlink" title="3.1 安全和幂等"></a>3.1 安全和幂等</h3><ul><li>在 HTTP 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。</li><li>所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。</li></ul><h3 id="3-2-对比"><a href="#3-2-对比" class="headerlink" title="3.2 对比"></a>3.2 对比</h3><h4 id="3-2-1-幂等"><a href="#3-2-1-幂等" class="headerlink" title="3.2.1 幂等"></a>3.2.1 幂等</h4><ul><li><code>GET</code> 方法就是安全且幂等的,<strong>因此可以对GET请求的数据做缓存</strong>，浏览器，代理（如nginx），或者server端</li><li><code>POST</code> 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据就会创建多个资源，所以不是幂等的。<ul><li>不能随意多次执行。因此也就不能缓存。</li><li>POST可能有副作用，所以浏览器实现为不能把POST请求保存为书签。</li><li>如果尝试重新执行POST请求，浏览器也会弹一个框提示下这个刷新可能会有副作用</li><li>把没有副作用的请求用POST实现，浏览器该弹框还是会弹框，对用户体验好处改善不大。</li><li>将HTTP POST作为接口的形式使用时，就没有这种弹框了。</li></ul></li></ul><h4 id="3-2-2-携带数据的格式"><a href="#3-2-2-携带数据的格式" class="headerlink" title="3.2.2 携带数据的格式"></a>3.2.2 携带数据的格式</h4><ul><li>GET请求没有body，只有url，请求数据放在url的querystring中；</li><li>POST请求的数据在body中<ul><li>POST请求都来自表单提交。每次提交，表单的数据被浏览器用编码到HTTP请求的body里。浏览器发出的POST请求的body主要有有两种格式，一种是application/x-www-form-urlencoded用来传输简单的数据，大概就是”key1=value1&amp;key2=value2”这样的格式。另外一种是传文件，会采用multipart/form-data格式。采用后者是因为application/x-www-form-urlencoded的编码方式对于文件这种二进制的数据非常低效。</li></ul></li></ul><h3 id="3-3-接口中的GET和POST"><a href="#3-3-接口中的GET和POST" class="headerlink" title="3.3 接口中的GET和POST"></a>3.3 接口中的GET和POST</h3><p>指通过浏览器的Ajax api，此时GET/POST不光能用在前端和后端的交互中，还能用在后端各个子服务的调用中</p><p>TODO</p><h3 id="3-4-关于安全性"><a href="#3-4-关于安全性" class="headerlink" title="3.4 关于安全性"></a>3.4 关于安全性</h3><p>从攻击的角度，无论是GET还是POST<strong>都不够安全</strong>，因为HTTP本身是<strong>明文协议</strong></p><p>https</p><p>一般情况下，私密数据传输用POST + body就好。</p><h3 id="3-5-关于编码"><a href="#3-5-关于编码" class="headerlink" title="3.5 关于编码"></a>3.5 关于编码</h3><p>GET只支持URL编码</p><h3 id="TCP-IP层面"><a href="#TCP-IP层面" class="headerlink" title="TCP/IP层面"></a>TCP/IP层面</h3><p><code>get</code>请求时，浏览器会把headers和data一起发送出去，服务器响应200（返回数据），<br><code>post</code>请求时，浏览器先发送headers，服务器响应100 continue，浏览器再发送data，服务器响应200（返回数据）。</p><h2 id="4-HTTP-特性"><a href="#4-HTTP-特性" class="headerlink" title="4 HTTP 特性"></a>4 HTTP 特性</h2><p>HTTP 最凸出的<strong>优点</strong>是「简单、灵活和易于扩展、应用广泛和跨平台」。</p><ol><li><p><strong>简单</strong> HTTP 基本的报文格式就是 header + body，头部信息也是 key-value 简单文本的形式，易于理解。</p></li><li><p><strong>灵活和易于扩展</strong></p><ul><li>HTTP协议里的各类请求方法、URI/URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发人员自定义和扩充。</li><li>同时 HTTP 由于是工作在应用层（ OSI 第七层），则它下层可以随意变化。</li><li>HTTPS 也就是在 HTTP 与 TCP 层之间增加了 SSL/TLS 安全传输层，HTTP/3 甚至把 TCP 层换成了基于 UDP 的 QUIC。</li></ul></li><li><p><strong>应用广泛和跨平台</strong></p></li></ol><p>缺点:</p><ol><li>无状态双刃剑<ol><li>减轻服务器的负担</li><li>在完成有关联性的操作时会非常麻烦(Cookie)</li></ol></li><li>明文传输</li><li>不安全(明文传输,不验证通信方的身份,无法证明报文的完整性)。HTTP 的安全问题，可以用 HTTPS 的方式解决</li></ol><h2 id="5-性能"><a href="#5-性能" class="headerlink" title="5 性能"></a>5 性能</h2><p>HTTP 协议是基于 TCP/IP，并且使用了「请求 - 应答」的通信模式，所以性能的关键就在这两点里。</p><h3 id="5-1-长连接"><a href="#5-1-长连接" class="headerlink" title="5.1 长连接"></a>5.1 长连接</h3><p>早期 HTTP/1.0 性能上的一个很大的问题，那就是每发起一个请求，都要新建一次 TCP 连接（三次握手），而且是串行请求</p><p>为了解决上述 TCP 连接问题，HTTP/1.1 提出了长连接的通信方式，也叫持久连接。这种方式的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。</p><p>持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。</p><h3 id="5-2-管道网络传输"><a href="#5-2-管道网络传输" class="headerlink" title="5.2 管道网络传输"></a>5.2 管道网络传输</h3><p>HTTP/1.1 采用了长连接的方式，这使得管道（pipeline）网络传输成为了可能。</p><p>即可在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，<strong>不必等其回来，就可以发第二个请求出去</strong>，可以减少整体的响应时间。</p><p><strong>但是服务器还是按照顺序</strong>，先回应 A 请求，完成后再回应 B 请求。要是 前面的回应特别慢，后面就会有许多请求排队等着。这称为「<strong>队头堵塞</strong>」。</p><h3 id="5-3-队头阻塞"><a href="#5-3-队头阻塞" class="headerlink" title="5.3 队头阻塞"></a>5.3 队头阻塞</h3><p>「请求 - 应答」的模式加剧了 HTTP 的性能问题。<br>因为当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一同被阻塞了</p><h3 id="5-4-并发连接"><a href="#5-4-并发连接" class="headerlink" title="5.4 并发连接"></a>5.4 并发连接</h3><p>对于一个域名允许分配多个长连接，在RFC2616规定过客户端最多并发 2 个连接，不过事实上在现在的浏览器标准中，这个上限要多很多，Chrome 中是 6 个。</p><p>还是不能满足人们对性能的需求于是进行<strong>域名划分</strong></p><p>一个一级域名下可以分出非常多的二级域名，而它们都指向同样的一台服务器，能够并发的长连接数更多了，事实上也更好地解决了队头阻塞的问题。</p><h2 id="6-HTTP-与-HTTPS"><a href="#6-HTTP-与-HTTPS" class="headerlink" title="6 HTTP 与 HTTPS"></a>6 HTTP 与 HTTPS</h2><p>HTTPS 解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。</p><p>HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。<strong>而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程</strong>，才可进入加密报文传输。</p><p>HTTP 的端口号是 80，HTTPS 的端口号是 443</p><p>HTTPS 协议需要向 CA（证书权威机构）申请数字证书(证明密钥是他的密钥)，来保证服务器的身份是可信的。</p><p>HTTP 由于是明文传输，所以安全上存在以下三个风险：</p><ul><li>窃听风险，比如通信链路上可以获取通信内容。</li><li>篡改风险，比如强制入垃圾广告，视觉污染。</li><li>冒充风险，比如冒充淘宝网站。</li></ul><p>HTTPS可以很好的解决了上述的风险：</p><ul><li>信息加密(<strong>混合加密</strong>)：交互信息无法被窃取。</li><li>校验机制(<strong>摘要算法来实现完整性</strong>)：无法篡改通信内容，篡改了就不能正常显示。</li><li>身份证书(<strong>公钥放入到数字证书</strong>)：证明淘宝是真的淘宝网。</li></ul><h3 id="6-1-混合加密"><a href="#6-1-混合加密" class="headerlink" title="6.1 混合加密"></a>6.1 混合加密</h3><p>对称加密和非对称加密结合</p><ul><li>在通信建立前采用非对称加密的方式交换「会话秘钥」，后续就不再使用非对称加密。(速度慢)</li><li>在通信过程中全部使用对称加密的「会话秘钥」的方式加密明文数据。(运算速度快)</li></ul><h3 id="6-2-摘要算法"><a href="#6-2-摘要算法" class="headerlink" title="6.2 摘要算法"></a>6.2 摘要算法</h3><p>摘要算法用来实现完整性，能够为数据生成独一无二的「指纹」，用于校验数据的完整性，解决了篡改的风险。</p><p>客户端在发送明文之前会通过摘要算法算出明文的「指纹」，发送的时候把<strong>「指纹 + 明文」一同<br>加密</strong>成密文后，发送给服务器，服务器解密后，用相同的摘要算法算出发送过来的明文,然后比对指纹</p><h3 id="6-3-数字证书"><a href="#6-3-数字证书" class="headerlink" title="6.3 数字证书"></a>6.3 数字证书</h3><p>客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。</p><p>为保证公钥不被篡改，需要借助第三方权威机构 CA，将服务器公钥放在数字证书，只要证书是可信的，公钥就是可信的。</p><h3 id="6-4-HTTPS-是如何建立连接的？其间交互了什么？"><a href="#6-4-HTTPS-是如何建立连接的？其间交互了什么？" class="headerlink" title="6.4 HTTPS 是如何建立连接的？其间交互了什么？"></a>6.4 HTTPS 是如何建立连接的？其间交互了什么？</h3><p>SSL/TLS 协议基本流程：</p><ul><li>客户端向服务器索要并验证服务器的公钥。(握手)</li><li>双方协商生产「会话秘钥」。(握手)</li><li>双方采用「会话秘钥」进行加密通信。</li></ul><p>握手过程：</p><ol><li>ClientHello,发送以下内容<ol><li>支持的 SSL/TLS 协议版本</li><li>生产的随机数（Client Random），后面用于生产「会话秘钥」</li><li>客户端支持的密码套件列表，如 RSA 加密算法</li></ol></li><li>SeverHello，回应内容如下<ol><li>确认 SSL/ TLS 协议版本</li><li>服务器生产的随机数，后面用于生产「会话秘钥」</li><li>确认的密码套件列表，如 RSA 加密算法</li><li>服务器的数字证书</li></ol></li><li>客户端回应<ol><li>首先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。</li><li>取出服务器的公钥，然后使用它加密报文，向服务器发送如下信息<ol><li>一个随机数（pre-master key）。该随机数会被服务器公钥加密。</li><li>加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</li><li>客户端握手结束通知，表示客户端的握手阶段已经结束。</li><li>这样服务器和客户端就同时有三个随机数，各自生成本次通信的「会话秘钥」。</li></ol></li></ol></li><li>服务器的最后回应<ol><li>收到客户端的第三个随机数后，通过协商的加密算法，计算出本次通信的「会话秘钥」。</li><li>然后，向客户端发生最后的信息：<ol><li>加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</li><li>服务器握手结束通知，表示服务器的握手阶段已经结束。</li></ol></li></ol></li></ol><h2 id="7-HTTP-1-1、HTTP-2、HTTP-3-演变"><a href="#7-HTTP-1-1、HTTP-2、HTTP-3-演变" class="headerlink" title="7 HTTP/1.1、HTTP/2、HTTP/3 演变"></a>7 HTTP/1.1、HTTP/2、HTTP/3 演变</h2><h3 id="7-1-HTTP-1-1-相比-HTTP-1-0"><a href="#7-1-HTTP-1-1-相比-HTTP-1-0" class="headerlink" title="7.1 HTTP/1.1 相比 HTTP/1.0"></a>7.1 HTTP/1.1 相比 HTTP/1.0</h3><ul><li><p>使用 TCP 长连接</p></li><li><p>支持 管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去</p></li><li><p>队头阻塞</p></li></ul><h3 id="7-2-HTTP-2相比HTTP-1-1"><a href="#7-2-HTTP-2相比HTTP-1-1" class="headerlink" title="7.2 HTTP/2相比HTTP/1.1"></a>7.2 HTTP/2相比HTTP/1.1</h3><p>HTTP/2 协议是基于 HTTPS 的，所以 HTTP/2 的安全性也是有保障的。</p><p>改进：</p><ol><li>头部压缩<ul><li>如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你消除重复的分。</li></ul></li><li>二进制格式<ul><li>HTTP/2 不再像 HTTP/1.1 里的纯文本形式的报文，而是全面采用了二进制格式。</li><li>头信息和数据体都是二进制，并且统称为帧（frame）：头信息帧和数据帧。</li><li>二进制格式增加了数据传输的效率</li></ul></li><li>数据流<ul><li>HTTP/2 的数据包不是按顺序发送的。因此，必须要对数据包做标记，指出它属于哪个回应。</li><li>每个请求或回应的所有数据包，称为一个数据流（Stream）。</li><li>每个数据流都标记着一个独一无二的编号，其中规定<strong>客户端</strong>发出的数据流编号为<strong>奇数</strong>， <strong>服务器</strong>发出的数据流编号为<strong>偶数</strong></li><li>客户端还可以指定数据流的优先级。优先级高的请求，服务器就先响应该请求。</li></ul></li><li>多路复用<ul><li>HTTP/2 是可以在一个连接中并发多个请求或回应，而不用按照顺序一一对应。</li><li>解决队头阻塞，降低了延迟，大幅度提高了连接的利用率。</li></ul></li><li>服务器推送<ul><li>在一定程度上改善了传统的「请求 - 应答」工作模式，服务不再是被动地响应，也可以主动向客户端发送消息。</li></ul></li></ol><h3 id="7-2-HTTP-3相比HTTP-2"><a href="#7-2-HTTP-3相比HTTP-2" class="headerlink" title="7.2 HTTP/3相比HTTP/2"></a>7.2 HTTP/3相比HTTP/2</h3><p><strong>HTTP/2 主要的问题在于</strong>：</p><p>多个 HTTP 请求在<strong>复用一个 TCP 连接</strong>，下层的 TCP 协议是不知道有多少个 HTTP 请求的。</p><p>所以一旦发生了丢包现象，就会触发 TCP 的重传机制，这样在一个 TCP 连接中的所有的 HTTP 请求都必须等待这个丢了的包被重传回来。（丢包，就会阻塞所有的 HTTP 请求）</p><p>这都是基于 TCP 传输层的问题，所以 <strong>HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP</strong>！</p><ul><li>UDP 发生是不管顺序，也不管丢包的，所以不会出现 HTTP/1.1 的队头阻塞 和 HTTP/2 的一个丢包全部重传问题。</li><li>UDP 是不可靠传输的，但基于 UDP 的 <code>QUIC 协议</code> 可以实现类似 TCP 的可靠性传输。</li><li>HTTPS 要建立一个连接，要花费 6 次交互，先是建立三次握手，然后是 TLS/1.3 的三次握手。</li><li>QUIC 直接把以往的 TCP 和 TLS/1.3 的 6 次交互合并成了 3 次，减少了交互次数。</li></ul><h3 id="7-3-图解"><a href="#7-3-图解" class="headerlink" title="7.3 图解"></a>7.3 图解</h3><p><img src="http://pic.aizf.ink/md/http/1.jpg" alt="avatar"></p>]]></content>
    
    
    
    <tags>
      
      <tag>http</tag>
      
      <tag>https</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>fetch</title>
    <link href="/2020/07/14/notes/web/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/fetch/"/>
    <url>/2020/07/14/notes/web/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/fetch/</url>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/zyj362633491/article/details/84997208" target="_blank" rel="noopener">https://blog.csdn.net/zyj362633491/article/details/84997208</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>http</tag>
      
      <tag>fetch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cookie、Session、Token、JWT</title>
    <link href="/2020/07/14/notes/web/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/Cookie%E3%80%81Session%E3%80%81Token%E3%80%81JWT/"/>
    <url>/2020/07/14/notes/web/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/Cookie%E3%80%81Session%E3%80%81Token%E3%80%81JWT/</url>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.im/post/5e055d9ef265da33997a42cc" target="_blank" rel="noopener">https://juejin.im/post/5e055d9ef265da33997a42cc</a></p><p><a href="https://juejin.im/post/5e718ecc6fb9a07cda098c2d" target="_blank" rel="noopener">https://juejin.im/post/5e718ecc6fb9a07cda098c2d</a></p><p><a href="http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html</a></p><h2 id="认证（Authentication）：验证当前用户的身份"><a href="#认证（Authentication）：验证当前用户的身份" class="headerlink" title="认证（Authentication）：验证当前用户的身份"></a>认证（Authentication）：验证当前用户的身份</h2><ul><li>用户名密码登录</li><li>邮箱发送登录链接</li><li>手机号接收验证码</li></ul><h2 id="授权（Authorization）：用户授予第三方应用访问该用户某些资源的权限"><a href="#授权（Authorization）：用户授予第三方应用访问该用户某些资源的权限" class="headerlink" title="授权（Authorization）：用户授予第三方应用访问该用户某些资源的权限"></a>授权（Authorization）：用户授予第三方应用访问该用户某些资源的权限</h2><ul><li>APP 会询问是否允许授予权限</li><li>小程序会询问是否允许授予权限</li><li>实现授权的方式有：cookie、session、token、OAuth</li></ul><h2 id="凭证（Credentials）：实现认证和授权的前提是需要一种媒介（证书）-来标记访问者的身份"><a href="#凭证（Credentials）：实现认证和授权的前提是需要一种媒介（证书）-来标记访问者的身份" class="headerlink" title="凭证（Credentials）：实现认证和授权的前提是需要一种媒介（证书） 来标记访问者的身份"></a>凭证（Credentials）：实现认证和授权的前提是需要一种媒介（证书） 来标记访问者的身份</h2><ul><li>在互联网应用中，一般网站（如掘金）会有两种模式，<strong>游客模式</strong>和<strong>登录模式</strong>。游客模式下，可以正常浏览网站上面的文章，一旦想要点赞/收藏/分享文章，就需要登录或者注册账号。当用户登录成功后，服务器会给该用户使用的浏览器颁发一个<strong>令牌（token）</strong>，这个令牌用来表明你的身份，每次浏览器发送请求时会带上这个令牌，就可以使用游客模式下无法使用的功能。</li></ul><h2 id="跨站和跨域"><a href="#跨站和跨域" class="headerlink" title="跨站和跨域"></a>跨站和跨域</h2><p>同站(same-site)/跨站(cross-site)」和第一方(first-party)/第三方(third-party)是等价的。</p><p>同源策略的同源(same-origin)是指两个 URL 的协议/主机名/端口一致。</p><p>cookie中的「同站」判断就比较宽松：只要两个 URL 的 eTLD+1 相同即可，不需要考虑协议和端口。eTLD+1 则表示，有效顶级域名+二级域名</p><p>举几个例子:</p><p><a href="http://www.taobao.com" target="_blank" rel="noopener">www.taobao.com</a> 和 <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 是跨站，<a href="http://www.a.taobao.com" target="_blank" rel="noopener">www.a.taobao.com</a> 和 <a href="http://www.b.taobao.com" target="_blank" rel="noopener">www.b.taobao.com</a> 是同站，a.github.io 和 b.github.io 是跨站(注意是跨站)。</p><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><ul><li>HTTP 是无状态的协议（对于事务处理没有记忆能力，每次客户端和服务端会话完成时，服务端不会保存任何会话信息）</li><li>cookie 存储在客户端</li><li>cookie 是不可跨域的：每个 cookie 都会绑定单一的域名，无法在别的域名下获取使用，一级域名和二级域名之间是允许共享使用的（靠的是 domain）。</li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>第一次访问网站的时候，浏览器发出请求，服务器响应请求后，会将cookie放入到响应请求中，在浏览器第二次发请求的时候，会把cookie带过去，服务端会辨别用户身份，当然服务器也可以修改cookie内容</p><h3 id="cookie-的属性"><a href="#cookie-的属性" class="headerlink" title="cookie 的属性"></a>cookie 的属性</h3><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>Name=Value</td><td>键值对，设置 Cookie 的名称及相对应的值，都必须是字符串类型<br/>1. 如果值为 Unicode 字符，需要为字符编码。<br/>2. 如果值为二进制数据，则需要使用 BASE64 编码。</td></tr><tr><td>Domain</td><td>指定 cookie 所属域名，默认是当前域名</td></tr><tr><td>Path</td><td>指定 cookie 在哪个路径（路由）下生效，默认是 ‘/‘。如果设置为 /abc，则只有 /abc 下的路由可以访问到该 cookie，如：/abc/read。</td></tr><tr><td>Max-Age</td><td>cookie 失效的时间，单位秒。如果为整数，则该 cookie 在 maxAge 秒后失效。如果为负数，该 cookie 为临时 cookie ，关闭浏览器即失效，浏览器也不会以任何形式保存该 cookie 。如果为 0，表示删除该 cookie 。默认为 -1。- 比 expires 好用。</td></tr><tr><td>Expires</td><td>过期时间，在设置的某个时间点后该 cookie 就会失效。一般浏览器的 cookie 都是默认储存的，当关闭浏览器结束这个会话的时候，这个 cookie 也就会被删除</td></tr><tr><td>Secure</td><td>该 cookie 是否仅被使用安全协议传输。安全协议有 HTTPS，SSL等，在网络上传输数据之前先将数据加密。默认为false。当 secure 值为 true 时，cookie 在 HTTP 中是无效，在 HTTPS 中才有效。</td></tr><tr><td>HttpOnly</td><td>如果给某个 cookie 设置了 httpOnly 属性，则无法通过 JS 脚本 读取到该 cookie 的信息，但还是能通过 Application 中手动修改 cookie，所以只是在一定程度上可以防止 XSS 攻击，不是绝对的安全</td></tr><tr><td>SameSite</td><td><strong>1.</strong> Strict 仅允许一方请求携带 Cookie，即浏览器将只发送相同站点请求的 Cookie，即当前网页 URL 与请求目标 URL 完全一致。<br/><strong>2.</strong> Lax 允许部分第三方请求携带 Cookie<br/><strong>3.</strong> None 无论是否跨站都会发送 Cookie</td></tr></tbody></table><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><ul><li>session 是另一种记录服务器和客户端会话状态的机制</li><li>session 是基于 cookie 实现的，session 存储在服务器端，sessionId 会被存储到客户端的cookie 中</li></ul><h3 id="认证流程"><a href="#认证流程" class="headerlink" title="认证流程"></a>认证流程</h3><ol><li>用户第一次请求服务器的时候，创建对应的 Session</li><li>请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器</li><li>浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名</li><li>当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。</li></ol><p>根据以上流程可知，SessionID 是连接 Cookie 和 Session 的一道桥梁，大部分系统也是根据此原理来验证用户登录状态。</p><h2 id="Token（令牌）"><a href="#Token（令牌）" class="headerlink" title="Token（令牌）"></a>Token（令牌）</h2><p>访问资源接口（API）时所需要的资源凭证</p><h3 id="简单-token-的组成"><a href="#简单-token-的组成" class="headerlink" title="简单 token 的组成"></a>简单 token 的组成</h3><ul><li>uid(用户唯一的身份标识)</li><li>time(当前时间的时间戳)</li><li>sign（签名，token 的前几位以哈希算法压缩成的一定长度的十六进制字符串）</li></ul><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>服务端无状态化、可扩展性好（服务端不用存放 token 数据。用解析 token 的计算时间换取 session 的存储空间，从而减轻服务器的压力）</li><li>支持移动端设备</li><li>安全</li><li>支持跨程序调用（完全由应用管理，所以它可以避开同源策略）</li></ul><h3 id="验证流程"><a href="#验证流程" class="headerlink" title="验证流程"></a>验证流程</h3><ol><li>客户端使用用户名跟密码请求登录</li><li>服务端收到请求，去验证用户名与密码</li><li>验证成功后，服务端会签发一个 token 并把这个 token 发送给客户端</li><li>客户端收到 token 以后，会把它存储起来，比如放在 cookie 里或者 localStorage 里</li><li>客户端每次向服务端请求资源的时候需要带着服务端签发的 token</li><li>服务端收到请求，然后去验证客户端请求里面带着的 token ，如果验证成功，就向客户端返回请求的数据</li></ol><h3 id="Refresh-Token"><a href="#Refresh-Token" class="headerlink" title="Refresh Token"></a>Refresh Token</h3><p>专用于刷新 access token 的 token。如果没有 refresh token，也可以刷新 access token，但每次刷新都要用户输入登录用户名与密码</p><h3 id="Token-和-Session-的区别"><a href="#Token-和-Session-的区别" class="headerlink" title="Token 和 Session 的区别"></a>Token 和 Session 的区别</h3><ul><li>服务端有无状态</li><li>身份认证 Token 安全性比 Session 好，因为每一个请求都有签名还能防止监听以及重放攻击</li><li>第三方共享</li></ul><h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><p>JSON Web Token（简称 JWT）是目前最流行的跨域认证解决方案。是一种认证授权机制</p><p><a href="http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html</a></p><p>JWT是一个很长的字符串，中间用点（.）分隔成三个部分：</p><ul><li>Header（头部）</li><li>Payload（负载）</li><li>Signature（签名）</li></ul><h3 id="认证流程-1"><a href="#认证流程-1" class="headerlink" title="认证流程"></a>认证流程</h3><ol><li>用户输入用户名/密码登录，服务端认证成功后，会返回给客户端一个 JWT</li><li>客户端将 token 保存到本地（通常使用 localstorage，也可以使用 cookie）</li><li>当用户希望访问一个受保护的路由或者资源的时候，需要请求头的 Authorization 字段中使用Bearer 模式添加 JWT，其内容看起来是这样：<code>Authorization: Bearer &lt;token&gt;</code></li></ol><h2 id="Token-和-JWT-的区别"><a href="#Token-和-JWT-的区别" class="headerlink" title="Token 和 JWT 的区别"></a>Token 和 JWT 的区别</h2><p>相同：</p><ul><li>都是访问资源的令牌</li><li>都可以记录用户的信息</li><li>都是使服务端无状态化</li><li>都是只有验证成功后，客户端才能访问服务端上受保护的资源</li></ul><p>不同：</p><ul><li>Token：服务端验证客户端发送过来的 Token 时，还需要查询数据库获取用户信息，然后验证 Token 是否有效。</li><li>JWT： 将 Token 和 Payload 加密后存储于客户端，服务端只需要使用密钥解密进行校验（校验也是 JWT 自己实现的）即可，不需要查询或者减少查询数据库，因为 JWT 自包含了用户信息和加密的数据。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>cookie</tag>
      
      <tag>session</tag>
      
      <tag>token</tag>
      
      <tag>jwt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AJAX(Asynchronous JavaScript and XML)简介</title>
    <link href="/2020/07/14/notes/web/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/AJAX/"/>
    <url>/2020/07/14/notes/web/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/AJAX/</url>
    
    <content type="html"><![CDATA[<p>AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。</p><p>XMLHttpRequest 可以用于获取任何类型的数据，而不仅仅是 XML。它甚至支持 HTTP 以外的协议（包括 file:// 和 FTP），尽管可能受到更多出于安全等原因的限制。</p><h2 id="1-创建-XMLHttpRequest-对象"><a href="#1-创建-XMLHttpRequest-对象" class="headerlink" title="1 创建 XMLHttpRequest 对象"></a>1 创建 XMLHttpRequest 对象</h2><p>XMLHttpRequest 是 AJAX 的基础,XMLHttpRequest 对象用于和服务器交换数据。</p><p>所有现代浏览器均支持 XMLHttpRequest 对象（IE5 和 IE6 使用 ActiveXObject）。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> request;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.XMLHttpRequest)    &#123;<span class="hljs-comment">// code for IE7+, Firefox, Chrome, Opera, Safari</span>        request = <span class="hljs-keyword">new</span> XMLHttpRequest();    &#125;<span class="hljs-keyword">else</span>    &#123;<span class="hljs-comment">// code for IE6, IE5</span>        request = <span class="hljs-keyword">new</span> ActiveXObject(<span class="hljs-string">"Microsoft.XMLHTTP"</span>);    &#125;</code></pre></div><h2 id="2-向服务器发送请求"><a href="#2-向服务器发送请求" class="headerlink" title="2 向服务器发送请求"></a>2 向服务器发送请求</h2><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// GET</span>request.open(<span class="hljs-string">"GET"</span>,<span class="hljs-string">"test1.txt"</span>,<span class="hljs-literal">true</span>);request.send();<span class="hljs-comment">// POST</span>request.open(<span class="hljs-string">"POST"</span>,<span class="hljs-string">"ajax_test.asp"</span>,<span class="hljs-literal">true</span>);request.setRequestHeader(<span class="hljs-string">"Content-type"</span>,<span class="hljs-string">"application/x-www-form-urlencoded"</span>);request.send(<span class="hljs-string">"fname=Bill&amp;lname=Gates"</span>);</code></pre></div><p><code>open(method,url,async)</code></p><p>规定请求的类型、URL 以及是否异步处理请求。</p><ul><li>method：请求的类型；GET 或 POST</li><li>url：文件在服务器上的位置</li><li>async：true（异步）或 false（同步）</li></ul><p><code>send(string)</code></p><p>将请求发送到服务器。</p><p>string：仅用于 POST 请求</p><p><code>setRequestHeader(header,value)</code></p><p>向请求添加 HTTP 头。</p><ul><li>header: 规定头的名称</li><li>value: 规定头的值</li></ul><h2 id="3-服务器响应"><a href="#3-服务器响应" class="headerlink" title="3 服务器响应"></a>3 服务器响应</h2><p><code>responseText</code></p><p>获得字符串形式的响应数据。如果来自服务器的响应并非 XML，请使用 responseText 属性。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"myDiv"</span>).innerHTML=request.responseText;</code></pre></div><p><code>responseXML</code></p><p>获得 XML 形式的响应数据。如果来自服务器的响应是 XML，而且需要作为 XML 对象进行解析，请使用 responseXML 属性。</p><h2 id="4-onreadystatechange-事件"><a href="#4-onreadystatechange-事件" class="headerlink" title="4 onreadystatechange 事件"></a>4 onreadystatechange 事件</h2><p>每当 readyState 改变时，就会触发 onreadystatechange 事件。</p><p>XMLHttpRequest 对象的三个重要的属性：</p><ol><li><code>onreadystatechange</code>，每当 readyState 属性改变时，就会调用该函数。</li><li><code>readyState</code>，存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。<ul><li>0: 请求未初始化</li><li>1: 服务器连接已建立</li><li>2: 请求已接收</li><li>3: 请求处理中</li><li>4: 请求已完成，且响应已就绪</li></ul></li><li>status<ol><li>200: “OK”</li><li>404: 未找到页面</li><li>…</li></ol></li></ol><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> request = <span class="hljs-keyword">new</span> XMLHttpRequest(); <span class="hljs-comment">// 新建XMLHttpRequest对象</span>request.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">// 状态发生变化时，函数被回调</span>    <span class="hljs-keyword">if</span> (request.readyState === <span class="hljs-number">4</span>) &#123; <span class="hljs-comment">// 成功完成</span>        <span class="hljs-comment">// 判断响应结果:</span>        <span class="hljs-keyword">if</span> (request.status === <span class="hljs-number">200</span>) &#123;            <span class="hljs-comment">// 成功，通过responseText拿到响应的文本:</span>            <span class="hljs-keyword">return</span> success(request.responseText);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 失败，根据响应码判断失败原因:</span>            <span class="hljs-keyword">return</span> fail(request.status);        &#125;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">// HTTP请求还在继续...</span>    &#125;&#125;<span class="hljs-comment">// 发送请求:</span>request.open(<span class="hljs-string">'GET'</span>, <span class="hljs-string">'/api/categories'</span>);request.send();</code></pre></div><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p><code>xhr.onreadystatechange</code></p><blockquote><p>当 readyState 属性发生变化时</p></blockquote><p><code>readyState</code></p><blockquote><p>无符号短整型（unsigned short）数字，代表请求的状态码(0,1,2,3,4)</p></blockquote><p><code>xhr.response</code></p><blockquote><p>整个响应实体</p></blockquote><p><code>xhr.responseText</code></p><blockquote><p>返回一个 DOMString，该 DOMString 包含对请求的响应，如果请求未成功或尚未发送，则返回 null。</p></blockquote><p><code>xhr.status</code></p><blockquote><p>一个无符号短整型（unsigned short）数字，代表请求的响应状态</p></blockquote><p><code>xhr.withCredentials</code></p><blockquote><p>用来指定跨域 Access-Control 请求是否应当带有授权信息，如 cookie 或授权 header 头。</p></blockquote><p><code>xhr.open(method, url[, async])</code></p><blockquote><p>初始化一个请求</p></blockquote><p><code>xhr.setRequestHeader(header, value)</code></p><blockquote><p>设置 HTTP 请求头的值。必须在 open() 之后、send() 之前</p></blockquote><p><code>xhr.send()</code></p><blockquote><p>接受一个可选的参数，其作为请求主体；如果请求方法是 GET 或者 HEAD，则应将请求主体设置为 null。</p></blockquote><p><code>xhr.abort()</code></p><blockquote><p>取消,当一个请求被终止，它的 readyState 属性将被置为0</p></blockquote><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><table><thead><tr><th>-</th><th>-</th></tr></thead><tbody><tr><td>abort</td><td>当 request 被停止时触发，例如当程序调用 XMLHttpRequest.abort() 时。也可以使用 onabort 属性。</td></tr><tr><td>error</td><td>当 request 遭遇错误时触发。也可以使用 onerror 属性</td></tr><tr><td>load</td><td>XMLHttpRequest请求成功完成时触发。也可以使用 onload 属性.</td></tr><tr><td>loadend</td><td>当请求结束时触发, 无论请求成功 ( load) 还是失败 (abort 或 error)。也可以使用 onloadend 属性。</td></tr><tr><td>loadstart</td><td>接收到响应数据时触发。也可以使用 onloadstart 属性。</td></tr><tr><td>progress</td><td>当请求接收到更多数据时，周期性地触发。也可以使用 onprogress 属性。</td></tr><tr><td>timeout</td><td>在预设时间内没有接收到响应时触发。也可以使用 ontimeout 属性。</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>http</tag>
      
      <tag>ajax</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>移动端常用问题</title>
    <link href="/2020/07/14/notes/web/%E7%A7%BB%E5%8A%A8%E7%AB%AF/%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/07/14/notes/web/%E7%A7%BB%E5%8A%A8%E7%AB%AF/%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="1-300-毫秒延迟的来历"><a href="#1-300-毫秒延迟的来历" class="headerlink" title="1 300 毫秒延迟的来历"></a>1 300 毫秒延迟的来历</h2><p>双击缩放或者双击滚动</p><p>移动端页面对于触摸事件会有 300 毫秒的延迟，导致多数用户感觉移动设备上基于 HTML 的 web 应用界面响应速度慢。</p><h3 id="1-1-解决方案"><a href="#1-1-解决方案" class="headerlink" title="1.1 解决方案"></a>1.1 解决方案</h3><p>打开一个页面，移动端浏览器会自动寻找,如果指定了视窗口的<code>width</code>，就会把页面放到指定<code>width</code>的<code>viewport</code>里面。如果没有指定，则默认值有的是<code>980</code>，具体根据浏览器来定的。</p><h4 id="1-1-1-设置meta标签禁止缩放"><a href="#1-1-1-设置meta标签禁止缩放" class="headerlink" title="1.1.1 设置meta标签禁止缩放"></a>1.1.1 设置meta标签禁止缩放</h4><p>1、</p><p><code>&lt;meta name=&quot;viewport&quot; content=&quot;user-scalable=no&quot;/&gt;</code><br><code>&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1, maximum-scale=1&quot;&gt;</code></p><p>这个方案有一个缺点，就是必须通过完全禁用缩放来达到去掉点击延迟的目的，然而完全禁用缩放并不是我们的初衷</p><p>2、</p><p><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;/&gt;</code></p><p>如果能够识别出一个网站是响应式的网站，那么移动端浏览器就可以自动禁掉默认的双击缩放行为并且去掉300ms的点击延迟。如果设置了上述meta标签，那浏览器就可以认为该网站已经对移动端做过了适配和优化，就无需双击缩放操作了。</p><p>好处在于，它没有完全禁用缩放，而只是禁用了浏览器默认的双击缩放行为，但用户仍然可以通过双指缩放操作来缩放页面。</p><h4 id="1-1-2-第三方插件"><a href="#1-1-2-第三方插件" class="headerlink" title="1.1.2 第三方插件"></a>1.1.2 第三方插件</h4><ul><li>fastclick.js</li><li>zepto.js</li><li>touch.js</li></ul><h3 id="1-2-viewport"><a href="#1-2-viewport" class="headerlink" title="1.2 viewport"></a>1.2 viewport</h3><table><thead><tr><th>-</th><th>-</th></tr></thead><tbody><tr><td>width</td><td>设置layout viewport  的宽度，为一个正整数，或字符串”width-device”</td></tr><tr><td>initial-scale</td><td>设置页面的初始缩放值，为一个数字，可以带小数</td></tr><tr><td>minimum-scale</td><td>允许用户的最小缩放值，为一个数字，可以带小数</td></tr><tr><td>maximum-scale</td><td>允许用户的最大缩放值，为一个数字，可以带小数</td></tr><tr><td>height</td><td>设置layout viewport  的高度，这个属性对我们并不重要，很少使用</td></tr><tr><td>user-scalable</td><td>是否允许用户进行缩放，值为”no”或”yes”, no 代表不允许，yes代表允许</td></tr></tbody></table><h2 id="2-点击穿透"><a href="#2-点击穿透" class="headerlink" title="2 点击穿透"></a>2 点击穿透</h2><p>一次点击行为，可被拆解成：mousedown -&gt; mouseup -&gt; click 三步。</p><p>手指触发触摸事件的过程为：touchstart -&gt; touchmove -&gt; touchend。</p><p><strong>tap 事件</strong>在用户轻击一个元素时触发，手机WEB端，click会有 200~300 ms，所以<strong>请用tap代替click作为点击事件</strong></p><p>click在移动端有300ms的延迟，混用click和touch会导致穿透事件</p><h3 id="2-1-场景及原因"><a href="#2-1-场景及原因" class="headerlink" title="2.1 场景及原因"></a>2.1 场景及原因</h3><p>1.蒙层穿透</p><p>在这 300ms 以内，因为上层元素隐藏或消失了，由于 click 事件的滞后性，同样位置的 DOM 元素触发了 click 事件（如果是 input 则触发了 focus 事件）。</p><p>2.<code>&lt;a&gt;</code></p><p>解决办法：</p><ul><li>设置蒙层消失的延迟</li><li>pointer-events，让被覆盖元素短时间内无法触发click</li><li>使用fastclick库</li><li>禁止页面缩放</li></ul><p>使用fastclick库，从此所有的点击事件都使用click，没有300ms的延迟，也没有穿透问题</p><h2 id="3-rem"><a href="#3-rem" class="headerlink" title="3 rem"></a>3 rem</h2><p>rem相对于<strong>根元素</strong>的字体大小的单位</p><p>em相对于<strong>父元素</strong>的字体大小的单位</p><p>rem（即html的字体大小），如果html字体大小100PX，那么1rem = 100px。</p><h3 id="3-1-步骤"><a href="#3-1-步骤" class="headerlink" title="3.1 步骤"></a>3.1 步骤</h3><p>1、首先需要在<code>&lt;head&gt;</code>标签中加入</p><p><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,maixmum-scale=1.0,minimum-scale=1.0,user-scalable=no&quot;&gt;</code></p><p>2、在<code>&lt;script&gt;</code>标签中加入</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">window</span>.onresize = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-built_in">document</span>.documentElement.style.fontSize = <span class="hljs-built_in">document</span>.documentElement.offsetWidth / <span class="hljs-number">20</span> +<span class="hljs-string">'px'</span>;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">document.documentElement.style.fontSize 是得到&lt;html&gt;标签并为它设置font-size样式字体大小，因为REM计算的规则是依赖根元素也就是&lt;html&gt;元素的字体大小</span><span class="hljs-comment">document.documentElement.offsetWidth  是获取整个视口的宽度</span><span class="hljs-comment">*/</span></code></pre></div><p><code>document.documentElement.offsetWidth / 20</code>这里的20不是固定的，<strong>这里 / 20 是把屏幕均分为20份</strong>，Chorme浏览器字体最小只能为12px，所以这里的最后结果最好别小于12。</p><p>3、这样1rem相当于1/20视口宽度</p>]]></content>
    
    
    
    <tags>
      
      <tag>移动端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>移动端响应式布局</title>
    <link href="/2020/07/14/notes/web/%E7%A7%BB%E5%8A%A8%E7%AB%AF/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80/"/>
    <url>/2020/07/14/notes/web/%E7%A7%BB%E5%8A%A8%E7%AB%AF/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<ul><li>media(一套代码)</li><li>rem(pc，移动端两套代码)</li><li>flex(部分内容)</li><li>vh/vm(部分内容)</li><li>…</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>移动端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器分类</title>
    <link href="/2020/07/14/notes/web/%E6%B5%8F%E8%A7%88%E5%99%A8/%E5%88%86%E7%B1%BB/"/>
    <url>/2020/07/14/notes/web/%E6%B5%8F%E8%A7%88%E5%99%A8/%E5%88%86%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="webkit内核-V8引擎"><a href="#webkit内核-V8引擎" class="headerlink" title="webkit内核(V8引擎)"></a>webkit内核(V8引擎)</h2><ul><li>Chrome</li><li>Safari</li><li>国产</li><li>Opera</li></ul><h2 id="Gecko内核"><a href="#Gecko内核" class="headerlink" title="Gecko内核"></a>Gecko内核</h2><ul><li>Firefox</li></ul><h2 id="Trident"><a href="#Trident" class="headerlink" title="Trident"></a>Trident</h2><ul><li>IE<ul><li>IE6~8</li><li>IE9~11</li><li>IE Edge</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>浏览器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器内核相关</title>
    <link href="/2020/07/14/notes/web/%E6%B5%8F%E8%A7%88%E5%99%A8/%E5%86%85%E6%A0%B8/"/>
    <url>/2020/07/14/notes/web/%E6%B5%8F%E8%A7%88%E5%99%A8/%E5%86%85%E6%A0%B8/</url>
    
    <content type="html"><![CDATA[<h2 id="多进程的浏览器"><a href="#多进程的浏览器" class="headerlink" title="多进程的浏览器"></a>多进程的浏览器</h2><p>浏览器是多进程的，有一个主控进程，以及每一个tab页面都会新开一个进程（某些情况下多个tab会合并进程）</p><p>进程可能包括主控进程，插件进程，GPU，tab页（浏览器内核）等等</p><ul><li>Browser进程：浏览器的主进程（负责协调、主控），只有一个</li><li>第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建</li><li>GPU进程：最多一个，用于3D绘制</li><li>浏览器渲染进程（内核）：默认每个Tab页面一个进程，互不影响，控制页面渲染，脚本执行，事件处理等（有时候会优化，如多个空白tab会合并成一个进程）</li></ul><h2 id="多线程的浏览器内核"><a href="#多线程的浏览器内核" class="headerlink" title="多线程的浏览器内核"></a>多线程的浏览器内核</h2><p>每一个tab页面可以看作是浏览器内核进程，然后这个进程是多线程的，它有几大类子线程</p><ul><li>GUI线程</li><li>JS引擎线程</li><li>事件触发线程</li><li>定时器线程</li><li>网络请求线程</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>浏览器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack target</title>
    <link href="/2020/07/14/notes/web/webpack/8-%E6%9E%84%E5%BB%BA%E7%9B%AE%E6%A0%87(targets)/"/>
    <url>/2020/07/14/notes/web/webpack/8-%E6%9E%84%E5%BB%BA%E7%9B%AE%E6%A0%87(targets)/</url>
    
    <content type="html"><![CDATA[<p>因为服务器和浏览器代码都可以用 JavaScript 编写，所以 webpack 提供了多种构建目标(target)，你可以在你的 webpack 配置中设置。</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>要设置 target 属性，只需要在你的 webpack 配置中设置 target 的值。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;  target: <span class="hljs-string">'node'</span>&#125;;</code></pre></div><h2 id="多个-Target"><a href="#多个-Target" class="headerlink" title="多个 Target"></a>多个 Target</h2><p>尽管 webpack 不支持向 target 传入多个字符串，你可以通过打包两份分离的配置来创建同构的库：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>);<span class="hljs-keyword">var</span> serverConfig = &#123;  target: <span class="hljs-string">'node'</span>,  output: &#123;    path: path.resolve(__dirname, <span class="hljs-string">'dist'</span>),    filename: <span class="hljs-string">'lib.node.js'</span>  &#125;  <span class="hljs-comment">//…</span>&#125;;<span class="hljs-keyword">var</span> clientConfig = &#123;  target: <span class="hljs-string">'web'</span>, <span class="hljs-comment">// &lt;=== 默认是 'web'，可省略</span>  output: &#123;    path: path.resolve(__dirname, <span class="hljs-string">'dist'</span>),    filename: <span class="hljs-string">'lib.js'</span>  &#125;  <span class="hljs-comment">//…</span>&#125;;<span class="hljs-built_in">module</span>.exports = [ serverConfig, clientConfig ];</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack modules</title>
    <link href="/2020/07/14/notes/web/webpack/6-%E6%A8%A1%E5%9D%97(modules)/"/>
    <url>/2020/07/14/notes/web/webpack/6-%E6%A8%A1%E5%9D%97(modules)/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是-webpack-模块"><a href="#什么是-webpack-模块" class="headerlink" title="什么是 webpack 模块"></a>什么是 webpack 模块</h2><p>对比 Node.js 模块，webpack 模块能够以各种方式表达它们的依赖关系，几个例子如下：</p><ul><li>ES2015 import 语句</li><li>CommonJS require() 语句</li><li>AMD define 和 require 语句</li><li>css/sass/less 文件中的 @import 语句。</li><li>样式(url(…))或 HTML 文件(<img src=...>)中的图片链接(image url)</li></ul><h2 id="支持的模块类型"><a href="#支持的模块类型" class="headerlink" title="支持的模块类型"></a>支持的模块类型</h2>]]></content>
    
    
    
    <tags>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack plugin</title>
    <link href="/2020/07/14/notes/web/webpack/5-%E6%8F%92%E4%BB%B6(plugins)/"/>
    <url>/2020/07/14/notes/web/webpack/5-%E6%8F%92%E4%BB%B6(plugins)/</url>
    
    <content type="html"><![CDATA[<p>插件是 webpack 的支柱功能。</p><h2 id="剖析"><a href="#剖析" class="headerlink" title="剖析"></a>剖析</h2><p>webpack 插件是一个具有 apply 属性的 JavaScript 对象。apply 属性会被 webpack compiler 调用，并且 compiler 对象可在整个编译生命周期访问。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> pluginName = <span class="hljs-string">'ConsoleLogOnBuildWebpackPlugin'</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConsoleLogOnBuildWebpackPlugin</span> </span>&#123;    apply(compiler) &#123;        compiler.hooks.run.tap(pluginName, compilation =&gt; &#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"webpack 构建过程开始！"</span>);        &#125;);    &#125;&#125;</code></pre></div><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>由于插件可以携带参数/选项，你必须在 webpack 配置中，向 plugins 属性传入 new 实例。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> HtmlWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'html-webpack-plugin'</span>); <span class="hljs-comment">//通过 npm 安装</span><span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">'webpack'</span>); <span class="hljs-comment">//访问内置的插件</span><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>);<span class="hljs-keyword">const</span> config = &#123;  entry: <span class="hljs-string">'./path/to/my/entry/file.js'</span>,  output: &#123;    filename: <span class="hljs-string">'my-first-webpack.bundle.js'</span>,    path: path.resolve(__dirname, <span class="hljs-string">'dist'</span>)  &#125;,  <span class="hljs-built_in">module</span>: &#123;    rules: [      &#123;        test: <span class="hljs-regexp">/\.(js|jsx)$/</span>,        use: <span class="hljs-string">'babel-loader'</span>      &#125;    ]  &#125;,  plugins: [    <span class="hljs-keyword">new</span> webpack.optimize.UglifyJsPlugin(),    <span class="hljs-keyword">new</span> HtmlWebpackPlugin(&#123;<span class="hljs-attr">template</span>: <span class="hljs-string">'./src/index.html'</span>&#125;)  ]&#125;;<span class="hljs-built_in">module</span>.exports = config;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack loader</title>
    <link href="/2020/07/14/notes/web/webpack/4-loader/"/>
    <url>/2020/07/14/notes/web/webpack/4-loader/</url>
    
    <content type="html"><![CDATA[<ul><li>loader 用于对模块的源代码进行转换。loader 可以使你在 import 或”加载”模块时预处理文件。</li><li>loader 可以将文件从不同的语言（如 TypeScript）转换为 JavaScript，或将内联图像转换为 data URL。</li><li>loader 甚至允许你直接在 JavaScript 模块中 import CSS文件！</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>例如，你可以使用 loader 告诉 webpack 加载 CSS 文件，或者将 TypeScript 转为 JavaScript。为此，首先安装相对应的 loader：</p><div class="hljs"><pre><code class="hljs bash">npm install --save-dev css-loadernpm install --save-dev ts-loader</code></pre></div><p>然后指示 webpack 对每个 .css 使用 css-loader，以及对所有 .ts 文件使用 ts-loader：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;  <span class="hljs-built_in">module</span>: &#123;    rules: [      &#123; <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/</span>, <span class="hljs-attr">use</span>: <span class="hljs-string">'css-loader'</span> &#125;,      &#123; <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.ts$/</span>, <span class="hljs-attr">use</span>: <span class="hljs-string">'ts-loader'</span> &#125;    ]  &#125;&#125;;</code></pre></div><h2 id="使用-loader"><a href="#使用-loader" class="headerlink" title="使用 loader"></a>使用 loader</h2><p>在你的应用程序中，有三种使用 loader 的方式：</p><ul><li>配置（推荐）：在 webpack.config.js 文件中指定 loader。</li><li>内联：在每个 import 语句中显式指定 loader。</li><li>CLI：在 shell 命令中指定它们。</li></ul><h3 id="配置-Configuration"><a href="#配置-Configuration" class="headerlink" title="配置[Configuration]"></a>配置[Configuration]</h3><p>module.rules 允许你在 webpack 配置中指定多个 loader。 </p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">module</span>: &#123;  rules: [    &#123;      test: <span class="hljs-regexp">/\.css$/</span>,      use: [        &#123; <span class="hljs-attr">loader</span>: <span class="hljs-string">'style-loader'</span> &#125;,        &#123;          loader: <span class="hljs-string">'css-loader'</span>,          options: &#123;            modules: <span class="hljs-literal">true</span>          &#125;        &#125;      ]    &#125;  ]&#125;</code></pre></div><h3 id="内联"><a href="#内联" class="headerlink" title="内联"></a>内联</h3><p>可以在 import 语句或任何等效于 “import” 的方式中指定 loader。使用 ! 将资源中的 loader 分开。分开的每个部分都相对于当前目录解析。</p><p><code>import Styles from &#39;style-loader!css-loader?modules!./styles.css&#39;;</code></p><p><strong>尽可能使用 module.rules</strong></p><h3 id="CLI"><a href="#CLI" class="headerlink" title="CLI"></a>CLI</h3><p><code>webpack --module-bind jade-loader --module-bind &#39;css=style-loader!css-loader&#39;</code></p><p>这会对 .jade 文件使用 jade-loader，对 .css 文件使用 style-loader 和 css-loader。</p><h2 id="loader-特性"><a href="#loader-特性" class="headerlink" title="loader 特性"></a>loader 特性</h2><ul><li>loader 支持链式传递。能够对资源使用流水线(pipeline)。一组链式的 loader 将按照相反的顺序执行。loader 链中的第一个 loader 返回值给下一个 loader。在最后一个 loader，返回 webpack 所预期的 JavaScript。</li><li>loader 可以是同步的，也可以是异步的。</li><li>loader 运行在 Node.js 中，并且能够执行任何可能的操作。</li><li>loader 接收查询参数。用于对 loader 传递配置。</li><li>loader 也能够使用 options 对象进行配置。</li><li>除了使用 package.json 常见的 main 属性，还可以将普通的 npm 模块导出为 loader，做法是在 package.json 里定义一个 loader 字段。</li><li>插件(plugin)可以为 loader 带来更多特性。</li><li>loader 能够产生额外的任意文件。</li></ul><p>loader 通过（loader）预处理函数，为 JavaScript 生态系统提供了更多能力。 用户现在可以更加灵活地引入细粒度逻辑，例如压缩、打包、语言翻译和其他更多。</p><h2 id="解析-loader"><a href="#解析-loader" class="headerlink" title="解析 loader"></a>解析 loader</h2><p>loader 遵循标准的模块解析。多数情况下，loader 将从模块路径（通常将模块路径认为是 npm install, node_modules）解析。</p>]]></content>
    
    
    
    <tags>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack mode</title>
    <link href="/2020/07/14/notes/web/webpack/3-%E6%A8%A1%E5%BC%8F(mode)/"/>
    <url>/2020/07/14/notes/web/webpack/3-%E6%A8%A1%E5%BC%8F(mode)/</url>
    
    <content type="html"><![CDATA[<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>只在配置中提供 mode 选项：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;  mode: <span class="hljs-string">'production'</span>&#125;;</code></pre></div><p>或者从 CLI 参数中传递：</p><p><code>webpack --mode=production</code></p><p>支持以下字符串值：</p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>development</td><td>会将 process.env.NODE_ENV 的值设为 development。启用 NamedChunksPlugin 和 NamedModulesPlugin。</td></tr><tr><td>production</td><td>会将 process.env.NODE_ENV 的值设为 production。启用 FlagDependencyUsagePlugin, FlagIncludedChunksPlugin, ModuleConcatenationPlugin, NoEmitOnErrorsPlugin, OccurrenceOrderPlugin, SideEffectsFlagPlugin 和 UglifyJsPlugin.</td></tr></tbody></table><p><strong>只设置 NODE_ENV，则不会自动设置 mode。</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack output</title>
    <link href="/2020/07/14/notes/web/webpack/2-%E8%BE%93%E5%87%BA(output)/"/>
    <url>/2020/07/14/notes/web/webpack/2-%E8%BE%93%E5%87%BA(output)/</url>
    
    <content type="html"><![CDATA[<p>配置 output 选项可以控制 webpack 如何向硬盘写入编译文件。注意，即使可以存在多个入口起点，但只指定一个输出配置。</p><h2 id="用法-Usage"><a href="#用法-Usage" class="headerlink" title="用法(Usage)"></a>用法(Usage)</h2><p>将它的值设置为一个对象，包括以下两点：</p><ul><li>filename 用于输出文件的文件名。</li><li>目标输出目录 path 的绝对路径。</li></ul><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> config = &#123;  output: &#123;    filename: <span class="hljs-string">'bundle.js'</span>,    path: <span class="hljs-string">'/home/proj/public/assets'</span>  &#125;&#125;;<span class="hljs-built_in">module</span>.exports = config;</code></pre></div><h2 id="多个入口起点"><a href="#多个入口起点" class="headerlink" title="多个入口起点"></a>多个入口起点</h2><p>如果配置创建了多个单独的 “chunk”（例如，使用多个入口起点或使用像 CommonsChunkPlugin 这样的插件），则应该使用占位符(substitutions)来确保每个文件具有唯一的名称。</p><div class="hljs"><pre><code class="hljs js">&#123;  entry: &#123;    app: <span class="hljs-string">'./src/app.js'</span>,    search: <span class="hljs-string">'./src/search.js'</span>  &#125;,  output: &#123;    filename: <span class="hljs-string">'[name].js'</span>,    path: __dirname + <span class="hljs-string">'/dist'</span>  &#125;&#125;<span class="hljs-comment">// 写入到硬盘：./dist/app.js, ./dist/search.js</span></code></pre></div><h2 id="高级进阶"><a href="#高级进阶" class="headerlink" title="高级进阶"></a>高级进阶</h2><p>以下是使用 CDN 和资源 hash 的复杂示例：</p><div class="hljs"><pre><code class="hljs js">output: &#123;  path: <span class="hljs-string">"/home/proj/cdn/assets/[hash]"</span>,  publicPath: <span class="hljs-string">"http://cdn.example.com/assets/[hash]/"</span>&#125;</code></pre></div><p>在编译时不知道最终输出文件的 publicPath 的情况下，publicPath 可以留空，并且在入口起点文件运行时动态设置。如果你在编译时不知道 publicPath，你可以先忽略它，并且在入口起点设置 <strong>webpack_public_path</strong>。</p>]]></content>
    
    
    
    <tags>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack entry</title>
    <link href="/2020/07/14/notes/web/webpack/1-%E5%85%A5%E5%8F%A3%E8%B5%B7%E7%82%B9(entry%20points)/"/>
    <url>/2020/07/14/notes/web/webpack/1-%E5%85%A5%E5%8F%A3%E8%B5%B7%E7%82%B9(entry%20points)/</url>
    
    <content type="html"><![CDATA[<h2 id="单个入口（简写）语法"><a href="#单个入口（简写）语法" class="headerlink" title="单个入口（简写）语法"></a>单个入口（简写）语法</h2><p><code>entry: string|Array&lt;string&gt;</code></p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> config = &#123;  entry: <span class="hljs-string">'./path/to/my/entry/file.js'</span>&#125;;<span class="hljs-built_in">module</span>.exports = config;</code></pre></div><h2 id="对象语法"><a href="#对象语法" class="headerlink" title="对象语法"></a>对象语法</h2><p>用于将关注点(concern)从环境(environment)、构建目标(build target)、运行时(runtime)中分离。然后使用专门的工具（如 webpack-merge）将它们合并。</p><p><code>entry: {[entryChunkName: string]: string|Array&lt;string&gt;}</code></p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> config = &#123;  entry: &#123;    app: <span class="hljs-string">'./src/app.js'</span>,    vendors: <span class="hljs-string">'./src/vendors.js'</span>  &#125;&#125;;</code></pre></div><h2 id="常见场景"><a href="#常见场景" class="headerlink" title="常见场景"></a>常见场景</h2><h3 id="分离-应用程序-app-和-第三方库-vendor-入口"><a href="#分离-应用程序-app-和-第三方库-vendor-入口" class="headerlink" title="分离 应用程序(app) 和 第三方库(vendor) 入口"></a>分离 应用程序(app) 和 第三方库(vendor) 入口</h3><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> config = &#123;  entry: &#123;    app: <span class="hljs-string">'./src/app.js'</span>,    vendors: <span class="hljs-string">'./src/vendors.js'</span>  &#125;&#125;;</code></pre></div><h3 id="多页面应用程序"><a href="#多页面应用程序" class="headerlink" title="多页面应用程序"></a>多页面应用程序</h3><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> config = &#123;  entry: &#123;    pageOne: <span class="hljs-string">'./src/pageOne/index.js'</span>,    pageTwo: <span class="hljs-string">'./src/pageTwo/index.js'</span>,    pageThree: <span class="hljs-string">'./src/pageThree/index.js'</span>  &#125;&#125;;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack概念</title>
    <link href="/2020/07/14/notes/web/webpack/0-%E6%A6%82%E5%BF%B5/"/>
    <url>/2020/07/14/notes/web/webpack/0-%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<p>本质上，webpack 是一个静态模块打包器(module bundler)。将所有这些模块打包成一个或多个 bundle。</p><p><code>webpack.config.js</code></p><p>四个核心概念：</p><ul><li>入口(entry)</li><li>输出(output)</li><li>loader</li><li>插件(plugins)</li></ul><h2 id="入口-entry"><a href="#入口-entry" class="headerlink" title="入口(entry)"></a>入口(entry)</h2><p>入口起点(entry point)指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。</p><p>每个依赖项随即被处理，最后输出到称之为 bundles 的文件中</p><p>可以通过在 webpack 配置中配置 entry 属性，来指定一个入口起点（或多个入口起点）。<strong>默认值为 ./src</strong>。</p><p>entry 配置:</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;  entry: <span class="hljs-string">'./path/to/my/entry/file.js'</span>&#125;;</code></pre></div><h2 id="出口-output"><a href="#出口-output" class="headerlink" title="出口(output)"></a>出口(output)</h2><p>output 属性告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件，<strong>默认值为 ./dist</strong>。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>);<span class="hljs-built_in">module</span>.exports = &#123;  entry: <span class="hljs-string">'./path/to/my/entry/file.js'</span>,  output: &#123;    path: path.resolve(__dirname, <span class="hljs-string">'dist'</span>),    filename: <span class="hljs-string">'my-first-webpack.bundle.js'</span>  &#125;&#125;;</code></pre></div><p>通过 <code>output.filename</code> 和 <code>output.path</code> 属性，来告诉 <code>webpack bundle</code> 的名称，以及我们想要 bundle 生成(emit)到哪里。在代码最上面导入的 path 模块是一个 Node.js 核心模块，用于操作文件路径。</p><h2 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h2><p>loader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。</p><p>在更高层面，在 webpack 的配置中 loader 有两个目标：</p><ul><li>test 属性，用于标识出应该被对应的 loader 进行转换的某个或某些文件。</li><li>use 属性，表示进行转换时，应该使用哪个 loader。</li></ul><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>);<span class="hljs-keyword">const</span> config = &#123;  output: &#123;    filename: <span class="hljs-string">'my-first-webpack.bundle.js'</span>  &#125;,  <span class="hljs-built_in">module</span>: &#123;    rules: [      &#123; <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.txt$/</span>, <span class="hljs-attr">use</span>: <span class="hljs-string">'raw-loader'</span> &#125;    ]  &#125;&#125;;<span class="hljs-built_in">module</span>.exports = config;</code></pre></div><p>这告诉 webpack 编译器(compiler) 如下信息：</p><blockquote><p>“嘿，webpack 编译器，当你碰到「在 require()/import 语句中被解析为 ‘.txt’ 的路径」时，在你对它打包之前，先使用 raw-loader 转换一下。”</p></blockquote><h2 id="插件-plugins"><a href="#插件-plugins" class="headerlink" title="插件(plugins)"></a>插件(plugins)</h2><p>loader 被用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。插件接口功能极其强大，可以用来处理各种各样的任务。</p><p>想要使用一个插件，你只需要 require() 它，然后把它添加到 plugins 数组中。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> HtmlWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'html-webpack-plugin'</span>); <span class="hljs-comment">// 通过 npm 安装</span><span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">'webpack'</span>); <span class="hljs-comment">// 用于访问内置插件</span><span class="hljs-keyword">const</span> config = &#123;  <span class="hljs-built_in">module</span>: &#123;    rules: [      &#123; <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.txt$/</span>, <span class="hljs-attr">use</span>: <span class="hljs-string">'raw-loader'</span> &#125;    ]  &#125;,  plugins: [    <span class="hljs-keyword">new</span> HtmlWebpackPlugin(&#123;<span class="hljs-attr">template</span>: <span class="hljs-string">'./src/index.html'</span>&#125;)  ]&#125;;<span class="hljs-built_in">module</span>.exports = config;</code></pre></div><p>webpack 提供许多开箱可用的插件！查阅<a href="https://www.webpackjs.com/plugins/" target="_blank" rel="noopener">插件列表</a>获取更多信息。</p><h2 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h2><p>通过选择 development 或 production 之中的一个，来设置 mode 参数，你可以启用相应模式下的 webpack 内置的优化</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;  mode: <span class="hljs-string">'production'</span>&#125;;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>父子组件生命周期执行顺序</title>
    <link href="/2020/07/14/notes/web/Vue/%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/"/>
    <url>/2020/07/14/notes/web/Vue/%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<ol><li>加载渲染过程<br> <code>父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount-&gt;子mounted-&gt;父mounted</code></li><li>子组件更新过程<br> <code>父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated</code></li><li>父组件更新过程<br> <code>父beforeUpdate-&gt;父updated</code></li><li>销毁过程<br> <code>父beforeDestroy-&gt;子beforeDestroy-&gt;子destroyed-&gt;父destroyed</code></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue和React对比</title>
    <link href="/2020/07/14/notes/web/Vue/Vue%E5%92%8CReact/"/>
    <url>/2020/07/14/notes/web/Vue/Vue%E5%92%8CReact/</url>
    
    <content type="html"><![CDATA[<h2 id="响应式更新对比"><a href="#响应式更新对比" class="headerlink" title="响应式更新对比"></a>响应式更新对比</h2><h3 id="React的更新粒度"><a href="#React的更新粒度" class="headerlink" title="React的更新粒度"></a>React的更新粒度</h3><p>React是自顶向下的进行递归更新的，也就是说，React 中假如父组件里还有十层嵌套子元素，那么所有层次都会递归的重新render（在不进行手动优化的情况下）。（因此，React 创造了Fiber，创造了异步渲染，其实本质上是弥补被自己搞砸了的性能）。</p><p>他们能用收集依赖的这套体系吗？不能，因为他们遵从Immutable的设计思想，永远不在原对象上修改属性，那么基于 Object.defineProperty 或 Proxy 的响应式依赖收集机制就无从下手了（你永远返回一个新的对象，我哪知道你修改了旧对象的哪部分？）</p><p>同时，由于没有响应式的收集依赖，React 只能递归的把所有子组件都重新 render一遍（除了memo和shouldComponentUpdate这些优化手段），然后再通过 diff算法 决定要更新哪部分的视图，这个递归的过程叫做 reconciler，听起来很酷，但是性能很灾难。</p><h3 id="Vue的更新粒度"><a href="#Vue的更新粒度" class="headerlink" title="Vue的更新粒度"></a>Vue的更新粒度</h3><p>那么，Vue 这种精确的更新是怎么做的呢？</p><p>1 其实每个组件都有自己的渲染 <code>watcher</code>，它掌管了当前组件的视图更新，但是并不会掌管 <code>ChildComponent</code> 的更新。</p><p>2 在 patch 的过程中，当组件更新到<code>ChildComponent</code>的时候，会走到 <code>patchVnode</code></p><p>3 <code>patchVnode</code>执行 <code>vnode</code> 的 <code>prepatch</code> 钩子。</p><ul><li>更新props（后续详细讲）</li><li>更新绑定事件</li><li>对于slot做一些更新（后续详细讲）</li></ul><p>4 如果有子节点的话，对子节点进行 diff。</p><p>Vue 的组件更新确实是<strong>精确到组件本身</strong>的。</p><p>对于子组件：</p><p>那么在diff的过程中，只会对 component 上声明的 props、listeners等属性进行更新，而不会深入到组件内部进行更新。</p><p>5 props的更新如何触发重渲染？</p><p>补充：<code>vm.$forceUpdate</code>，它仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件。</p><p>本质上就是触发了<code>渲染watcher</code>的重新执行，和你去修改一个响应式的属性触发更新的原理是一模一样的，它只是帮你调用了 <code>vm._watcher.update()</code></p>]]></content>
    
    
    
    <tags>
      
      <tag>react</tag>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VUE.sync修饰符</title>
    <link href="/2020/07/14/notes/web/Vue/VUE.sync%E4%BF%AE%E9%A5%B0%E7%AC%A6/"/>
    <url>/2020/07/14/notes/web/Vue/VUE.sync%E4%BF%AE%E9%A5%B0%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<p><code>Vue2.3.0</code> 新增</p><p><code>Vue3.x</code>中<code>:xxx.sync</code> 将被 <code>v-model:xxx</code> 取代</p><p><code>.sync</code>是vue中用于实现简单的“双向绑定”的语法糖</p><p>vue的prop是单向下行绑定：父级的prop的更新会向下流动到子组件中，但是反过来不行。</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>父组件：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">text-document</span> <span class="hljs-attr">:title.sync</span>=<span class="hljs-string">"doc.title"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">text-document</span>&gt;</span></code></pre></div><p>子组件：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 当子组件需要更新 title 的值时，它需要显式地触发一个更新事件：</span><span class="hljs-keyword">this</span>.$emit(<span class="hljs-string">'update:title'</span>, newValue)</code></pre></div><h2 id="Vue3-x"><a href="#Vue3-x" class="headerlink" title="Vue3.x"></a>Vue3.x</h2><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">text-document</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"doc"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">text-document</span>&gt;</span></code></pre></div><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">text-document</span> </span><span class="hljs-tag">    <span class="hljs-attr">v-model:title</span>=<span class="hljs-string">"doc.title"</span></span><span class="hljs-tag">    <span class="hljs-attr">v-model:content</span>=<span class="hljs-string">"doc.content"</span></span><span class="hljs-tag">&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">text-document</span>&gt;</span></code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>react基本概念</title>
    <link href="/2020/07/14/notes/web/React/%E5%9F%BA%E6%9C%AC/"/>
    <url>/2020/07/14/notes/web/React/%E5%9F%BA%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<h2 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1 初始化"></a>1 初始化</h2><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params">props</span>) </span>&#123;    <span class="hljs-keyword">let</span> a = <span class="hljs-string">"APP"</span>;    <span class="hljs-keyword">let</span> text = <span class="hljs-string">"React"</span>;    <span class="hljs-keyword">return</span> (        &lt;div className=&#123;a&#125;&gt;            &lt;p&gt;&#123;text&#125;&lt;<span class="hljs-regexp">/p&gt;</span><span class="hljs-regexp">        &lt;/</span>div&gt;  );&#125;ReactDOM.render(    &lt;App /&gt;,    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'root'</span>));</code></pre></div><h2 id="2-函数式组件，类组件"><a href="#2-函数式组件，类组件" class="headerlink" title="2 函数式组件，类组件"></a>2 函数式组件，类组件</h2><p>类组件：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProfilePage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;    showMessage = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;        alert(<span class="hljs-string">'Followed '</span> + <span class="hljs-keyword">this</span>.props.user);    &#125;;    handleClick = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;        setTimeout(<span class="hljs-keyword">this</span>.showMessage, <span class="hljs-number">3000</span>);    &#125;;    render() &#123;        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.handleClick&#125;</span>&gt;</span>Follow<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;    &#125;&#125;ReactDOM.render(    &lt;ProfilePage /&gt;,    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'root'</span>));</code></pre></div><h3 id="2-1-类组件的constructor"><a href="#2-1-类组件的constructor" class="headerlink" title="2.1 类组件的constructor()"></a>2.1 类组件的constructor()</h3><p>没有 <code>constructor</code> 可以不写 <code>super()</code></p><p>有 <code>constructor</code> 就需要 <code>super()</code>：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">component</span> </span>&#123;    <span class="hljs-comment">// 因为在没有调用 super()之前this 未初始化，这就是为什么 this 不能在 super()之前。</span>    <span class="hljs-keyword">constructor</span>()&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>) <span class="hljs-comment">//Error: 'this' is not allowed before super()</span>    &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">component</span> </span>&#123;    <span class="hljs-keyword">constructor</span>()&#123;&#125; <span class="hljs-comment">// Error: missing super() call in constructor</span>&#125;</code></pre></div><p>需要把<code>this.props</code>写在构造函数中才需要调用<code>super(props)</code>：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">component</span></span>&#123;    <span class="hljs-keyword">constructor</span>(props)&#123;        <span class="hljs-keyword">super</span>();        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.props); <span class="hljs-comment">// this.props is undefined</span>    &#125;&#125;</code></pre></div><p>如果你想在其他地方使用它，没有必要设置props到构造函数中。因为 React 会自动为你设置。</p><h2 id="2-2-函数式组件和类组件区别"><a href="#2-2-函数式组件和类组件区别" class="headerlink" title="2.2 函数式组件和类组件区别"></a>2.2 函数式组件和类组件区别</h2><p>函数组件的性能比类组件的性能要高，因为类组件使用的时候要实例化，而函数组件直接执行函数取返回结果即可。为了提高性能，尽量使用函数组件。</p><table><thead><tr><th>区别</th><th>函数组件</th><th>类组件</th></tr></thead><tbody><tr><td>是否有 this</td><td>没有</td><td>有</td></tr><tr><td>是否有生命周期</td><td>没有</td><td>有</td></tr><tr><td>是否有状态 state</td><td>没有</td><td>有</td></tr></tbody></table><h2 id="3-基本操作"><a href="#3-基本操作" class="headerlink" title="3 基本操作"></a>3 基本操作</h2><h3 id="3-1-响应式修改属性"><a href="#3-1-响应式修改属性" class="headerlink" title="3.1 响应式修改属性"></a>3.1 响应式修改属性</h3><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">this</span>.setState(&#123;    attr1:val1,    attr2:val2,&#125;)</code></pre></div><h3 id="3-2-绑定属性"><a href="#3-2-绑定属性" class="headerlink" title="3.2 绑定属性"></a>3.2 绑定属性</h3><p>用<code>{}</code>包含表达式</p><div class="hljs"><pre><code class="hljs js">&lt;button onClick=&#123;<span class="hljs-keyword">this</span>.handleClick&#125;&gt;Follow&lt;<span class="hljs-regexp">/button&gt;</span></code></pre></div><h3 id="3-3-JSX内注释方法"><a href="#3-3-JSX内注释方法" class="headerlink" title="3.3 JSX内注释方法"></a>3.3 JSX内注释方法</h3><div class="hljs"><pre><code class="hljs js">&#123;<span class="hljs-comment">/* xxx */</span>&#125;</code></pre></div><h2 id="4-父子通信"><a href="#4-父子通信" class="headerlink" title="4 父子通信"></a>4 父子通信</h2><p>父-&gt;子：</p><p><code>props</code></p><p>子父：</p><ol><li>父定义修改属性的函数</li><li>通过<code>props</code>传给子</li><li>子调用该函数(注意<code>this</code>指向)</li></ol><h2 id="5-事件"><a href="#5-事件" class="headerlink" title="5 事件"></a>5 事件</h2><p>绑定事件的名：驼峰命名法(如：原生为<code>onclick</code>，React为<code>onClick</code>)</p><p><code>{}</code>传入的内容：<strong>函数</strong>而非字符串</p><p>传递多个参数：</p><div class="hljs"><pre><code class="hljs js">&#123;<span class="hljs-comment">/* ES6 */</span>&#125;&lt;button onClick=&#123;(e)=&gt;&#123;<span class="hljs-keyword">this</span>.handler(e, <span class="hljs-string">"xxx"</span>)&#125;&#125;提交&lt;<span class="hljs-regexp">/button&gt;</span><span class="hljs-regexp">&#123;/</span>* 或 *<span class="hljs-regexp">/&#125;</span><span class="hljs-regexp">&lt;button onClick=&#123;this.deleteRow.bind(this, id)&#125;&gt;Delete Row&lt;/</span>button&gt;&#123;<span class="hljs-comment">/* ES5 */</span>&#125;&lt;button onClick=&#123;<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>&#123;<span class="hljs-keyword">this</span>.handler(e, <span class="hljs-string">"xxx"</span>)&#125;.bind(<span class="hljs-keyword">this</span>)&#125;提交&lt;<span class="hljs-regexp">/button&gt;</span></code></pre></div><h2 id="6-条件渲染"><a href="#6-条件渲染" class="headerlink" title="6 条件渲染"></a>6 条件渲染</h2><h3 id="6-1-直接根据-if…else…-返回组件"><a href="#6-1-直接根据-if…else…-返回组件" class="headerlink" title="6.1 直接根据(if…else…)返回组件"></a>6.1 直接根据(if…else…)返回组件</h3><h3 id="6-2-return插槽"><a href="#6-2-return插槽" class="headerlink" title="6.2 return插槽"></a>6.2 return插槽</h3><p>插槽内可放表达式</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">return</span> (    &lt;div&gt;        &#123;element&#125;    &lt;<span class="hljs-regexp">/div&gt;</span><span class="hljs-regexp">)</span></code></pre></div><h2 id="7-列表渲染"><a href="#7-列表渲染" class="headerlink" title="7 列表渲染"></a>7 列表渲染</h2><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">let</span> data=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];ele = data.map(<span class="hljs-function">(<span class="hljs-params">d,i</span>)=&gt;</span>(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;i&#125;</span>&gt;</span>d<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>));<span class="hljs-comment">// ...</span>&lt;ul&gt;    &#123;ele&#125;&lt;<span class="hljs-regexp">/ul&gt;</span><span class="hljs-regexp"></span><span class="hljs-regexp">&lt;ul&gt;</span><span class="hljs-regexp">    &#123;data.map((d,i)=&gt;(&lt;li key=&#123;i&#125;&gt;d&lt;/</span>li&gt;))&#125;&lt;<span class="hljs-regexp">/ul&gt;</span><span class="hljs-regexp">/</span><span class="hljs-regexp">/ ...</span></code></pre></div><p>也可以定义循环生成已经声明的组件</p><h2 id="8-生命周期"><a href="#8-生命周期" class="headerlink" title="8 生命周期"></a>8 生命周期</h2><ul><li>挂载卸载</li><li>更新</li></ul><p><img src="http://pic.aizf.ink/md/react/1.webp" alt="avatar"></p><h3 id="8-1-挂载卸载"><a href="#8-1-挂载卸载" class="headerlink" title="8.1 挂载卸载"></a>8.1 挂载卸载</h3><p><code>constructor()</code></p><blockquote><p>完成了React数据的初始化，它接受两个参数：props和context，当想在函数内部使用这两个参数时，需使用super()传入这两个参数。</p></blockquote><p><code>componentWillMount()</code></p><blockquote><p>一般用的比较少，它更多的是在服务端渲染时使用。</p></blockquote><p><code>componentDidMount()</code></p><blockquote><p>组件第一次渲染完成，此时dom节点已经生成，可以在这里调用ajax请求，返回数据setState后组件会重新渲染</p></blockquote><p><code>componentWillUnmount ()</code></p><blockquote><p>在此处完成组件的卸载和数据的销毁。</p></blockquote><ol><li>clear你在组建中所有的setTimeout,setInterval</li><li>移除所有组建中的监听 removeEventListener</li><li>…</li></ol><h3 id="8-2-更新过程"><a href="#8-2-更新过程" class="headerlink" title="8.2 更新过程"></a>8.2 更新过程</h3><p><code>componentWillReceiveProps (nextProps)</code></p><ol><li>在接受父组件改变后的<code>props</code>需要重新渲染组件时用到的比较多</li><li>接受一个参数<code>nextProps</code></li><li>通过对比<code>nextProps</code>和<code>this.props</code>，将<code>nextProps</code>的<code>state</code>为当前组件的<code>state</code>，从而重新渲染组件</li></ol><p><code>shouldComponentUpdate(nextProps,nextState)</code></p><ol><li>主要用于性能优化(部分更新)</li><li>唯一用于控制组件重新渲染的生命周期，由于在react中，<code>setState</code>以后，<code>state</code>发生变化，组件会进入重新渲染的流程，在这里<code>return false</code>可以阻止组件的更新</li><li>因为react父组件的重新渲染会导致其所有子组件的重新渲染，这个时候其实我们是不需要所有子组件都跟着重新渲染的，因此需要在子组件的该生命周期中做判断</li></ol><p><code>componentWillUpdate (nextProps,nextState)</code></p><p><code>componentDidUpdate(prevProps,prevState)</code></p><blockquote><p>这里可以拿到prevProps和prevState，即更新前的props和state。</p></blockquote><p><code>render()</code></p><blockquote><p>render函数会插入jsx生成的dom结构，react会生成一份虚拟dom树，在每一次组件更新时，在此react会通过其diff算法比较更新前后的新旧DOM树，比较以后，找到最小的有差异的DOM节点，并重新渲染。</p></blockquote><h3 id="8-3-新增"><a href="#8-3-新增" class="headerlink" title="8.3 新增"></a>8.3 新增</h3><p><img src="http://pic.aizf.ink/md/react/2.webp" alt="avatar"></p><h3 id="8-4-State-的更新"><a href="#8-4-State-的更新" class="headerlink" title="8.4 State 的更新"></a>8.4 State 的更新</h3><h4 id="8-4-1-不要直接修改-State"><a href="#8-4-1-不要直接修改-State" class="headerlink" title="8.4.1 不要直接修改 State"></a>8.4.1 不要直接修改 State</h4><p>应该使用 setState():</p><p><code>this.setState({comment: &#39;Hello&#39;});</code></p><h4 id="8-4-2-State-的更新可能是异步的"><a href="#8-4-2-State-的更新可能是异步的" class="headerlink" title="8.4.2 State 的更新可能是异步的"></a>8.4.2 State 的更新可能是异步的</h4><p>出于性能考虑，React 可能会把多个 setState() 调用合并成一个调用。</p><p>此代码可能会无法更新计数器：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// Wrong</span><span class="hljs-keyword">this</span>.setState(&#123;  counter: <span class="hljs-keyword">this</span>.state.counter + <span class="hljs-keyword">this</span>.props.increment,&#125;);</code></pre></div><p>要解决这个问题，可以让 setState() 接收一个函数而不是一个对象。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// Correct</span><span class="hljs-keyword">this</span>.setState(<span class="hljs-function">(<span class="hljs-params">state, props</span>) =&gt;</span> (&#123;  counter: state.counter + props.increment&#125;));</code></pre></div><h4 id="8-4-3-State-的更新会被合并"><a href="#8-4-3-State-的更新会被合并" class="headerlink" title="8.4.3 State 的更新会被合并"></a>8.4.3 State 的更新会被合并</h4><h2 id="9-redux"><a href="#9-redux" class="headerlink" title="9 redux"></a>9 redux</h2><ul><li>store:数据仓库</li><li>state:一个存储数据的对象</li><li>action:触发数据改变的方法</li><li>dispatch:将动作触发成方法</li><li>reducer:通过获取动作，改变数据</li></ul><h2 id="10-路由"><a href="#10-路由" class="headerlink" title="10 路由"></a>10 路由</h2><p>库<code>react-router-dom</code></p><p>模式：<code>hash</code>和<code>history</code></p><p>三大组建：</p><ul><li><code>Router</code>,包裹路由规则的最外层组件<ul><li><code>basename</code>设置默认base</li></ul></li><li><code>Route</code>,规则匹配组件<ul><li><code>exact</code>精确匹配</li></ul></li><li><code>Link</code>,跳转组件<ul><li><code>to</code>：可以是字符串也可以是表达式</li><li><code>replace</code>：点击链接后，可以将新地址替换成历史访问的原地址，回不到上一级 适用于登录后，不需要重新回到登页面</li></ul></li></ul><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">Router</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"/"</span>&gt;</span>Home<span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"/about"</span>&gt;</span>About<span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"/topics"</span>&gt;</span>Topics<span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">exact</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"/"</span> <span class="hljs-attr">component</span>=<span class="hljs-string">&#123;Home&#125;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"/about"</span> <span class="hljs-attr">component</span>=<span class="hljs-string">&#123;About&#125;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"/topics"</span> <span class="hljs-attr">component</span>=<span class="hljs-string">&#123;Topics&#125;</span> /&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Router</span>&gt;</span></code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>react</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js String</title>
    <link href="/2020/07/14/notes/web/js/API/String/"/>
    <url>/2020/07/14/notes/web/js/API/String/</url>
    
    <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String</a></p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="String-fromCharCode-num1-…-numN"><a href="#String-fromCharCode-num1-…-numN" class="headerlink" title="String.fromCharCode(num1, …, numN)"></a>String.fromCharCode(num1, …, numN)</h3><p>返回由指定的<strong>UTF-16</strong>代码单元序列创建的字符串。</p><h3 id="String-fromCodePoint-num1-…-numN"><a href="#String-fromCodePoint-num1-…-numN" class="headerlink" title="String.fromCodePoint(num1[, …[, numN]])"></a>String.fromCodePoint(num1[, …[, numN]])</h3><p>返回使用指定的代码点序列( <strong>Unicode 编码</strong>)创建的字符串。</p><h3 id="str-concat-string2-string3-…-stringN"><a href="#str-concat-string2-string3-…-stringN" class="headerlink" title="str.concat(string2, string3[, …, stringN])"></a>str.concat(string2, string3[, …, stringN])</h3><p>不影响原字符串</p><h3 id="str-startsWith-searchString-position"><a href="#str-startsWith-searchString-position" class="headerlink" title="str.startsWith(searchString[, position])"></a>str.startsWith(searchString[, position])</h3><p>判断当前字符串是否以另外一个给定的子字符串开头，并根据判断结果返回 true 或 false。</p><h3 id="str-endsWith-searchString-length"><a href="#str-endsWith-searchString-length" class="headerlink" title="str.endsWith(searchString[, length])"></a>str.endsWith(searchString[, length])</h3><p>判断当前字符串是否是以另外一个给定的子字符串“结尾”的，根据判断结果返回 true 或 false。</p><h3 id="str-match-regexp"><a href="#str-match-regexp" class="headerlink" title="str.match(regexp)"></a>str.match(regexp)</h3><p>返回一个字符串匹配正则表达式的的结果。</p><p>参数:</p><ul><li>regexp<ul><li>如果传入一个非正则表达式对象，则会隐式地使用 new RegExp(obj) 将其转换为一个 RegExp 。如果你没有给出任何参数并直接使用match() 方法 ，你将会得到一 个包含空字符串的 Array ：[“”] 。</li></ul></li></ul><p>返回值:</p><p>一个Array，其内容取决于global（g）标志的存在与否，如果未找到匹配则为null。</p><ul><li>如果使用g标志，则将返回与完整正则表达式匹配的所有结果，但不会返回捕获组。</li><li>如果未使用g标志，则仅返回第一个完整匹配及其相关的捕获组（Array）。 在这种情况下，返回的项目将具有如下所述的其他属性。</li><li>附加属性<ul><li>groups: 一个捕获组数组 或 undefined（如果没有定义命名捕获组）。</li><li>index: 匹配的结果的开始位置</li><li>input: 搜索的字符串.</li></ul></li></ul><p>如果正则表达式不包含 g 标志，<code>str.match()</code> 将返回与 <code>RegExp.exec()</code>. 相同的结果。</p><h3 id="str-search-regexp"><a href="#str-search-regexp" class="headerlink" title="str.search(regexp)"></a>str.search(regexp)</h3><p>如果匹配成功，则 search() 返回正则表达式在字符串中首次匹配项的索引;否则，返回 -1。</p><h3 id="str-replace-regexp-substr-newSubStr-function"><a href="#str-replace-regexp-substr-newSubStr-function" class="headerlink" title="str.replace(regexp|substr, newSubStr|function)"></a>str.replace(regexp|substr, newSubStr|function)</h3><h4 id="newSubStr-使用字符串作为参数"><a href="#newSubStr-使用字符串作为参数" class="headerlink" title="newSubStr(使用字符串作为参数)"></a>newSubStr(使用字符串作为参数)</h4><p>替换字符串可以插入下面的特殊变量名：</p><table><thead><tr><th>变量名</th><th>代表的值</th></tr></thead><tbody><tr><td><code>$$</code></td><td>插入一个 “$”。</td></tr><tr><td><code>$&amp;</code></td><td>插入匹配的子串。</td></tr><tr><td>$`</td><td>插入当前匹配的子串左边的内容。</td></tr><tr><td><code>$&#39;</code></td><td>插入当前匹配的子串右边的内容。</td></tr><tr><td><code>$n</code></td><td>假如第一个参数是 RegExp对象，并且 n 是个小于100的非负整数，那么插入第 n 个<strong>括号</strong>匹配的字符串。提示：索引是从1开始</td></tr></tbody></table><h4 id="function-指定一个函数作为参数"><a href="#function-指定一个函数作为参数" class="headerlink" title="function(指定一个函数作为参数)"></a>function(指定一个函数作为参数)</h4><table><thead><tr><th>变量名</th><th>代表的值</th></tr></thead><tbody><tr><td>match</td><td>匹配的子串。（对应于上述的$&amp;。）</td></tr><tr><td>p1,p2, …</td><td>假如replace()方法的第一个参数是一个RegExp 对象，则代表第n个括号匹配的字符串。（对应于上述的$1，$2等。）例如，如果是用 /(\a+)(\b+)/ 这个来匹配，p1 就是匹配的 \a+，p2 就是匹配的 \b+。</td></tr><tr><td>offset</td><td>匹配到的子字符串在原字符串中的偏移量。（比如，如果原字符串是 ‘abcd’，匹配到的子字符串是 ‘bc’，那么这个参数将会是 1）</td></tr><tr><td>string</td><td>被匹配的原字符串。</td></tr><tr><td>NamedCaptureGroup</td><td>命名捕获组匹配的对象</td></tr></tbody></table><h3 id="str-padEnd-targetLength-padString"><a href="#str-padEnd-targetLength-padString" class="headerlink" title="str.padEnd(targetLength [, padString])"></a>str.padEnd(targetLength [, padString])</h3><p>从字符串末尾填充到指定长度</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-string">'abc'</span>.padEnd(<span class="hljs-number">10</span>);          <span class="hljs-comment">// "abc       "</span><span class="hljs-string">'abc'</span>.padEnd(<span class="hljs-number">10</span>, <span class="hljs-string">"foo"</span>);   <span class="hljs-comment">// "abcfoofoof"</span><span class="hljs-string">'abc'</span>.padEnd(<span class="hljs-number">6</span>, <span class="hljs-string">"123456"</span>); <span class="hljs-comment">// "abc123"</span><span class="hljs-string">'abc'</span>.padEnd(<span class="hljs-number">1</span>);           <span class="hljs-comment">// "abc"</span></code></pre></div><h3 id="str-padStart-targetLength-padString"><a href="#str-padStart-targetLength-padString" class="headerlink" title="str.padStart(targetLength [, padString])"></a>str.padStart(targetLength [, padString])</h3><p>从字符串末尾填充到指定长度</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-string">'abc'</span>.padStart(<span class="hljs-number">6</span>,<span class="hljs-string">"123465"</span>); <span class="hljs-comment">// "123abc"</span><span class="hljs-string">'abc'</span>.padStart(<span class="hljs-number">8</span>, <span class="hljs-string">"0"</span>);     <span class="hljs-comment">// "00000abc"</span><span class="hljs-string">'abc'</span>.padStart(<span class="hljs-number">1</span>);          <span class="hljs-comment">// "abc"</span></code></pre></div><h3 id="str-substring-indexStart-indexEnd"><a href="#str-substring-indexStart-indexEnd" class="headerlink" title="str.substring(indexStart[, indexEnd])"></a>str.substring(indexStart[, indexEnd])</h3><p>相对于slice，不支持负数</p><h3 id="str-toLocaleLowerCase"><a href="#str-toLocaleLowerCase" class="headerlink" title="str.toLocaleLowerCase"></a>str.toLocaleLowerCase</h3><p>返回调用字符串被转换为小写的格式。</p><div class="hljs"><pre><code class="hljs js">str.toLocaleLowerCase()str.toLocaleLowerCase(locale) str.toLocaleLowerCase([locale, locale, ...])</code></pre></div><p>参数:</p><ul><li>locale 可选<ul><li>参数 locale 指明要转换成小写格式的特定语言区域。 如果以一个数组 Array形式给出多个locales,  最合适的地区将被选出来应用（参见best available locale）。默认的locale是主机环境的当前区域(locale)设置。</li></ul></li></ul><h3 id="str-toLocaleUpperCase"><a href="#str-toLocaleUpperCase" class="headerlink" title="str.toLocaleUpperCase"></a>str.toLocaleUpperCase</h3><h3 id="String-prototype-trim"><a href="#String-prototype-trim" class="headerlink" title="String.prototype.trim()"></a>String.prototype.trim()</h3><p>从一个字符串的两端删除空白字符。在这个上下文中的空白字符是所有的空白字符 (space, tab, no-break space 等) 以及所有行终止符字符（如 LF，CR等）。</p><p>不影响原字符串本身</p><h3 id="String-prototype-trimStart-String-prototype-trimLeft"><a href="#String-prototype-trimStart-String-prototype-trimLeft" class="headerlink" title="String.prototype.trimStart() / String.prototype.trimLeft())"></a>String.prototype.trimStart() / String.prototype.trimLeft())</h3><h3 id="String-prototype-trimEnd-String-prototype-trimRight"><a href="#String-prototype-trimEnd-String-prototype-trimRight" class="headerlink" title="String.prototype.trimEnd() / String.prototype.trimRight()"></a>String.prototype.trimEnd() / String.prototype.trimRight()</h3>]]></content>
    
    
    
    <tags>
      
      <tag>cheatsheet</tag>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js RegExp</title>
    <link href="/2020/07/14/notes/web/js/API/RegExp/"/>
    <url>/2020/07/14/notes/web/js/API/RegExp/</url>
    
    <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp</a></p><h2 id="创建一个正则表达式"><a href="#创建一个正则表达式" class="headerlink" title="创建一个正则表达式"></a>创建一个正则表达式</h2><h3 id="正则表达式字面量"><a href="#正则表达式字面量" class="headerlink" title="正则表达式字面量"></a>正则表达式字面量</h3><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> re = <span class="hljs-regexp">/ab+c/</span>;</code></pre></div><p>脚本加载后，正则表达式字面量就会被编译。当正则表达式保持不变时，使用此方法可获得更好的性能。</p><h3 id="调用RegExp对象的构造函数"><a href="#调用RegExp对象的构造函数" class="headerlink" title="调用RegExp对象的构造函数"></a>调用RegExp对象的构造函数</h3><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> re = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">"ab+c"</span>);</code></pre></div><p>在脚本运行过程中，用构造函数创建的正则表达式会被编译。</p><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>match、matchAll、replace、search 和 split 方法</p><h3 id="RegExp"><a href="#RegExp" class="headerlink" title="RegExp"></a>RegExp</h3><p>exec 和 test 方法</p><h4 id="re-正则实例"><a href="#re-正则实例" class="headerlink" title="re(正则实例)"></a>re(正则实例)</h4><p><code>lastIndex</code></p><blockquote><p>下一次匹配开始的位置</p></blockquote><p><code>source</code></p><blockquote><p>正则匹配的字符串</p></blockquote><h4 id="exec"><a href="#exec" class="headerlink" title="exec()"></a>exec()</h4><p><code>result = re.exec(str)</code></p><p>result：</p><blockquote><p>如果匹配成功，exec() 方法返回一个数组，并更新正则表达式对象的 lastIndex 属性。</p><p>result[0] : 匹配的全部字符串</p><p>[1], …[n] : 括号中的分组捕获</p><p>index : 匹配到的字符位于原始字符串的基于0的索引值</p><p>input : 原始字符串</p><p>如果匹配失败，exec() 方法返回 null，并将 lastIndex 重置为 0 。</p></blockquote><p>注意：</p><p>当正则表达式使用 “g” 标志时，可以多次执行 exec 方法来查找同一个字符串中的成功匹配。当你这样做时，查找将从正则表达式的 lastIndex 属性指定的位置开始。（test() 也会更新 lastIndex 属性）。注意，即使再次查找的字符串不是原查找字符串时，lastIndex 也不会被重置，它依旧会从记录的 lastIndex 开始。</p><h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h3><table><thead><tr><th>字符</th><th>含义</th></tr></thead><tbody><tr><td>^</td><td>匹配输入的开始。</td></tr><tr><td>$</td><td>匹配输入的结束。</td></tr><tr><td>*</td><td>匹配前一个表达式 0 次或多次。等价于 {0,}。</td></tr><tr><td>+</td><td>匹配前面一个表达式 1 次或者多次。等价于 {1,}。</td></tr><tr><td>?</td><td>匹配前面一个表达式 0 次或者 1 次。等价于 {0,1}。</td></tr><tr><td>.</td><td>默认匹配除换行符之外的任何单个字符。</td></tr><tr><td>(x)</td><td>会匹配 ‘x’ 并且记住匹配项。其中括号被称为捕获括号。</td></tr><tr><td>(?:x)</td><td>匹配 ‘x’ 但是不记住匹配项。这种括号叫作非捕获括号</td></tr><tr><td>x(?=y)</td><td>匹配’x’仅仅当’x’后面跟着’y’,这种叫做先行断言。</td></tr><tr><td>x(?!y)</td><td>当’x’后面不跟着’y’时匹配’x’，这被称为正向否定查找。</td></tr><tr><td>`x</td><td>y`</td></tr><tr><td><code>{n}</code>, <code>{n,}</code>, <code>{n,m}</code></td><td></td></tr><tr><td><code>[xyz]</code></td><td>匹配方括号中的任意字符，包括转义序列。你可以使用破折号（-）来指定一个字符范围。</td></tr><tr><td><code>[^xyz]</code></td><td>匹配任何没有包含在方括号中的字符。</td></tr><tr><td>\d</td><td>匹配一个数字。等价于<code>[0-9]</code>。</td></tr><tr><td>\D</td><td>匹配一个非数字字符。等价于<code>[^0-9]</code>。</td></tr><tr><td>\s</td><td>匹配一个空白字符，包括空格、制表符、换页符和换行符。</td></tr><tr><td>\S</td><td>匹配一个非空白字符</td></tr><tr><td>\w</td><td>匹配一个单字字符（字母、数字或者下划线）。等价于<code>[A-Za-z0-9_]</code>。</td></tr><tr><td>\W</td><td>匹配一个非单字字符。</td></tr></tbody></table><h3 id="正则表达式标志"><a href="#正则表达式标志" class="headerlink" title="正则表达式标志"></a>正则表达式标志</h3><table><thead><tr><th>标志</th><th>描述</th></tr></thead><tbody><tr><td>g</td><td>全局搜索。</td></tr><tr><td>i</td><td>不区分大小写搜索。</td></tr><tr><td>m</td><td>多行搜索。</td></tr><tr><td>s</td><td>允许 . 匹配换行符。</td></tr><tr><td>u</td><td>使用unicode码的模式进行匹配。</td></tr><tr><td>y</td><td>执行“粘性(sticky)”搜索,匹配从目标字符串的当前位置开始。</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>cheatsheet</tag>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js Array</title>
    <link href="/2020/07/14/notes/web/js/API/Array/"/>
    <url>/2020/07/14/notes/web/js/API/Array/</url>
    
    <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray</a></p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><h3 id="Array-length"><a href="#Array-length" class="headerlink" title="Array.length"></a>Array.length</h3><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="Array-from-arrayLike-mapFn-thisArg"><a href="#Array-from-arrayLike-mapFn-thisArg" class="headerlink" title="Array.from(arrayLike[, mapFn[, thisArg]])"></a>Array.from(arrayLike[, mapFn[, thisArg]])</h3><ul><li>arrayLike<ul><li>想要转换成数组的<strong>伪数组对象或可迭代对象</strong>。</li></ul></li><li>mapFn 可选<ul><li>如果指定了该参数，<strong>新数组中的每个元素会执行该回调函数</strong>。</li></ul></li><li>thisArg 可选<ul><li>可选参数，执行回调函数 mapFn 时 this 对象。</li></ul></li></ul><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">Array</span>.from([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], x =&gt; x + x);<span class="hljs-comment">// [2, 4, 6]</span></code></pre></div><h3 id="Array-isArray-obj"><a href="#Array-isArray-obj" class="headerlink" title="Array.isArray(obj)"></a>Array.isArray(obj)</h3><p>如果值是 Array，则为true; 否则为false。</p><h3 id="Array-of-element0-element1-…-elementN"><a href="#Array-of-element0-element1-…-elementN" class="headerlink" title="Array.of(element0[, element1[, …[, elementN]]])"></a>Array.of(element0[, element1[, …[, elementN]]])</h3><p>创建一个具有可变数量参数的新数组实例，而不考虑参数的数量或类型。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">Array</span>.of(<span class="hljs-number">7</span>);       <span class="hljs-comment">// [7]</span><span class="hljs-built_in">Array</span>.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// [1, 2, 3]</span><span class="hljs-built_in">Array</span>(<span class="hljs-number">7</span>);          <span class="hljs-comment">// [ , , , , , , ]</span><span class="hljs-built_in">Array</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);    <span class="hljs-comment">// [1, 2, 3]</span></code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>cheatsheet</tag>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>首屏时间(FCP) 白屏时间(FP)</title>
    <link href="/2020/07/14/notes/web/js/%E9%A6%96%E5%B1%8F%E5%92%8C%E7%99%BD%E5%B1%8F/"/>
    <url>/2020/07/14/notes/web/js/%E9%A6%96%E5%B1%8F%E5%92%8C%E7%99%BD%E5%B1%8F/</url>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.im/post/5e8484e151882573c2190eb9" target="_blank" rel="noopener">https://juejin.im/post/5e8484e151882573c2190eb9</a></p><h2 id="白屏（First-Paint）"><a href="#白屏（First-Paint）" class="headerlink" title="白屏（First Paint）"></a>白屏（First Paint）</h2><p>当浏览器开始渲染页面，白屏触发，这时候你如果设置了背景颜色的话，就可以看到页面出现了背景色。</p><p>白屏会在页面加载之前触发</p><h2 id="首屏-First-Contentful-Paint"><a href="#首屏-First-Contentful-Paint" class="headerlink" title="首屏 (First Contentful Paint)"></a>首屏 (First Contentful Paint)</h2><p>当页面绘制完第一个 DOM 内容，会触发首屏，这里的内容可以是文字、图片或者是 canvas。</p><p>首屏决定了网页的用户体验，因为它会标记实际内容何时加载到页面中</p><h2 id="时间计算"><a href="#时间计算" class="headerlink" title="时间计算"></a>时间计算</h2><h3 id="performance-timing-API"><a href="#performance-timing-API" class="headerlink" title="performance.timing API"></a>performance.timing API</h3><p><img src="https://user-gold-cdn.xitu.io/2019/9/26/16d6ddba20a58314?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="avatar"></p><p><code>navigationStart</code>:输入栏回车或者页面按F5刷新</p><p><code>fetchStart</code>:浏览器准备好使用 HTTP 请求获取文档的timing</p><p><code>domLoading</code>:刚开始解析渲染DOM树</p><p><code>domInteractive</code>：完成解析DOM树</p><p><code>domContentLoadedEventEnd</code>: DOM解析完，且资源加载完（js）</p><p><code>loadEventStart</code>：load回调开始执行</p><h3 id="白屏时间"><a href="#白屏时间" class="headerlink" title="白屏时间"></a>白屏时间</h3><p>在 head 标签开始加一段脚本，用于记录白屏开始时间，在 head 标签结束之前，加一段脚本，用于计算白屏时间，有些浏览器可以调用 Performance API 得出白屏结束时间，有些不支持</p><div class="hljs"><pre><code class="hljs js">domLoading - fetchStartdomInteractive - fetchStart</code></pre></div><h3 id="首屏时间"><a href="#首屏时间" class="headerlink" title="首屏时间"></a>首屏时间</h3><p>指页面第一屏所有资源完整展示的时间。这是一个对用户来说非常直接的体验指标，但是对于前端却是一个非常难以统计衡量的指标。</p><div class="hljs"><pre><code class="hljs js">domContentLoadedEventEnd - fetchStartloadEventStart - fetchStart</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js隐式转换</title>
    <link href="/2020/07/14/notes/web/js/%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2/"/>
    <url>/2020/07/14/notes/web/js/%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/jawil/blog/issues/1" target="_blank" rel="noopener">https://github.com/jawil/blog/issues/1</a><br><a href="https://github.com/jawil/blog/issues/5" target="_blank" rel="noopener">https://github.com/jawil/blog/issues/5</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Equality_comparisons_and_sameness" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Equality_comparisons_and_sameness</a></p><p>JS是一门动态的弱类型语言</p><h2 id="强类型和弱类型"><a href="#强类型和弱类型" class="headerlink" title="强类型和弱类型"></a>强类型和弱类型</h2><p>区别在于计算时是否可以不同类型之间对使用者透明地隐式转换。</p><h2 id="js的几个假值"><a href="#js的几个假值" class="headerlink" title="js的几个假值"></a>js的几个假值</h2><p>null 、+0、 -0、””、 false 、NaN 、undefined</p><h2 id="双等号"><a href="#双等号" class="headerlink" title="双等号"></a>双等号</h2><p>在比较前将两个被比较的值转换为相同类型（等式的一边或两边都可能被转换）。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-literal">null</span> == <span class="hljs-literal">undefined</span>           <span class="hljs-comment">// true</span><span class="hljs-string">"undefined"</span> == <span class="hljs-literal">undefined</span>    <span class="hljs-comment">// false</span><span class="hljs-string">"null"</span> == <span class="hljs-literal">null</span>              <span class="hljs-comment">// false</span></code></pre></div><h3 id="转换规则"><a href="#转换规则" class="headerlink" title="转换规则"></a>转换规则</h3><p><img src="http://pic.aizf.ink/md/js/6.jpg" alt="avatar"></p><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><ol><li>有<code>NaN</code>，直接返回false</li><li>有<code>boolean</code>，<code>true</code>转化为<code>1</code>，<code>false</code>转化为<code>0</code></li><li><code>null</code>和<code>undefined</code>，不转化</li><li>字符串,<ol><li><code>b</code>是字符串，直接比较</li><li><code>b</code>是数字，字符串转化为数字</li><li><code>b</code>是布尔，转换布尔</li><li><code>b</code>是对象或数组，调用<code>toString</code>或<code>valueOf</code>,先<code>valueOf</code>，无法比较则<code>toString</code>,若也无法比较则报错</li></ol></li></ol><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// chrome 83</span>&#123;&#125;+<span class="hljs-number">1</span>    <span class="hljs-comment">// 1</span><span class="hljs-number">1</span>+&#123;&#125;    <span class="hljs-comment">// "1[object Object]"</span>(&#123;&#125;+<span class="hljs-number">1</span>)  <span class="hljs-comment">// "[object Object]1"</span><span class="hljs-number">1</span>-&#123;&#125;    <span class="hljs-comment">// NaN</span>&#123;&#125;<span class="hljs-number">-1</span>    <span class="hljs-comment">// -1</span>[]+<span class="hljs-number">1</span>    <span class="hljs-comment">// "1"</span><span class="hljs-number">1</span>+[]    <span class="hljs-comment">// "1"</span><span class="hljs-number">1</span>-[]    <span class="hljs-comment">// 1</span>[]<span class="hljs-number">-1</span>    <span class="hljs-comment">// -1</span>[]==![] <span class="hljs-comment">// true</span></code></pre></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>用<code>===</code>啊</p>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>闭包</title>
    <link href="/2020/07/14/notes/web/js/%E9%97%AD%E5%8C%85/"/>
    <url>/2020/07/14/notes/web/js/%E9%97%AD%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/A_re-introduction_to_JavaScript" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/A_re-introduction_to_JavaScript</a></p><p>函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起构成闭包（closure）。也就是说，<strong>闭包可以让你从内部函数访问外部函数作用域。</strong>在 JavaScript 中，<strong>每当函数被创建，就会在函数生成时生成闭包</strong>。</p><p>每当 JavaScript 执行一个函数时，都会创建一个作用域对象（scope object），用来保存在这个函数中创建的局部变量。它使用一切被传入函数的变量进行初始化（初始化后，它包含一切被传入函数的变量）。</p><p>你不能从 JavaScript 代码中直接访问作用域对象，也没有 可以遍历当前作用域对象中的属性 的方法。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">out</span>(<span class="hljs-params">a</span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inside</span>(<span class="hljs-params">b</span>) </span>&#123;    <span class="hljs-keyword">return</span> a + b;  &#125;&#125;</code></pre></div><p>通常，JavaScript 的垃圾回收器会在这时回收 <code>out</code> 创建的作用域对象（暂记为 <code>out</code> 的返回值，新函数 inside，拥有一个指向<code>out</code>作用域对象的引用。最终，<code>out</code>作用域对象不会被垃圾回收器回收，直到没有任何引用指向新函数 adder。</p><p>作用域对象组成了一个名为作用域链（scope chain）的（调用）链。</p><p>一个闭包，就是 一个函数 与其 被创建时所带有的作用域对象 的组合。</p>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js遍历方法汇总</title>
    <link href="/2020/07/14/notes/web/js/%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/"/>
    <url>/2020/07/14/notes/web/js/%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;    <span class="hljs-comment">// ...</span>&#125;</code></pre></div><h2 id="for…in"><a href="#for…in" class="headerlink" title="for…in"></a>for…in</h2><p>会遍历<strong>数组或对象</strong>所有的可枚举属性，包括原型链上的可枚举属性。</p><p>可以通过<code>hasOwnPropery</code>方法, 避免遍历原型链上的可枚举属性</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> obj) &#123;　　<span class="hljs-keyword">if</span>（obj.hasOwnProperty(key))&#123;　　　　<span class="hljs-built_in">console</span>.log(key);　　&#125;&#125;</code></pre></div><h2 id="for…of"><a href="#for…of" class="headerlink" title="for…of"></a>for…of</h2><p>遍历<strong>数组或对象</strong>的值，支持新的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols" target="_blank" rel="noopener">迭代协议</a>，可以用来迭代可迭代的对象</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> val <span class="hljs-keyword">of</span> arr) &#123;    <span class="hljs-comment">// ...</span>&#125;</code></pre></div><h2 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h2><div class="hljs"><pre><code class="hljs js">arr.forEach(<span class="hljs-function">(<span class="hljs-params">d,i,p</span>)=&gt;</span>&#123;    <span class="hljs-comment">// ...</span>&#125;)</code></pre></div><h2 id="every"><a href="#every" class="headerlink" title="every"></a>every</h2><div class="hljs"><pre><code class="hljs js">arr.every(<span class="hljs-function">(<span class="hljs-params">d,i,p</span>)=&gt;</span>&#123;    <span class="hljs-comment">// ...</span>    <span class="hljs-comment">// return true or false</span>&#125;)</code></pre></div><p>回调全部<code>return true</code>，<code>every()</code>返回<code>true</code>，否则返回<code>false</code></p><p>可通过<code>return false</code>，提前中断循环</p><h2 id="some"><a href="#some" class="headerlink" title="some"></a>some</h2><p>如果任意一个回调返回<code>true</code>，则返回<code>true</code>。</p><p>可通过<code>return true</code>，提前中断循环</p><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>根据回调，返回新的数组</p><h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h2><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">let</span> init = <span class="hljs-number">5</span>;<span class="hljs-keyword">let</span> res = arr.reduce(<span class="hljs-function">(<span class="hljs-params">acc, curr, i, p</span>) =&gt;</span> &#123; <span class="hljs-keyword">return</span> acc + curr;&#125;,init);</code></pre></div><p>acc：<code>arr[0]</code>,累积值或<code>initialValue</code></p><p>返回：最终的结果</p><p>注：</p><ol><li>不指定<code>init</code>，回调运行<code>arr.length-1</code>次，指定则运行<code>arr.length</code>次</li><li>空数组调用<code>reduce</code>且不指定<code>init</code>会报错</li></ol><p>也就是说不指定<code>init</code>，则使用<code>arr[0]</code>作为<code>init</code></p><h3 id="例"><a href="#例" class="headerlink" title="例"></a>例</h3><div class="hljs"><pre><code class="hljs js">[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>].reduce(<span class="hljs-function">(<span class="hljs-params">pre, curr</span>) =&gt;</span> &#123;    <span class="hljs-keyword">let</span> res = pre + curr;    <span class="hljs-built_in">console</span>.log(pre, curr, res);    <span class="hljs-keyword">return</span> res;&#125;);<span class="hljs-comment">/**</span><span class="hljs-comment"> * 0 1 1</span><span class="hljs-comment"> * 1 2 3</span><span class="hljs-comment"> * 3 3 6</span><span class="hljs-comment"> * 6 4 10</span><span class="hljs-comment"> * 10</span><span class="hljs-comment">  */</span></code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js触发事件</title>
    <link href="/2020/07/14/notes/web/js/%E8%A7%A6%E5%8F%91%E4%BA%8B%E4%BB%B6/"/>
    <url>/2020/07/14/notes/web/js/%E8%A7%A6%E5%8F%91%E4%BA%8B%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="dispatchEvent"><a href="#dispatchEvent" class="headerlink" title="dispatchEvent"></a>dispatchEvent</h2><div class="hljs"><pre><code class="hljs js">$(dom).addEvent(<span class="hljs-string">"alert"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    alert(<span class="hljs-string">"aaa~~"</span>);&#125;);<span class="hljs-comment">// 创建</span><span class="hljs-keyword">var</span> evt = <span class="hljs-built_in">document</span>.createEvent(<span class="hljs-string">"HTMLEvents"</span>);<span class="hljs-comment">// 初始化</span>evt.initEvent(<span class="hljs-string">"alert"</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>);<span class="hljs-comment">// 触发, 即弹出文字</span>dom.dispatchEvent(evt);</code></pre></div><ul><li><code>createEvent()</code>，参数：<code>HTMLEvents</code>，<code>MouseEvents</code>，<code>UIEvents</code></li><li><code>initEvent()</code>方法用于初始化通过<code>DocumentEvent</code>接口创建的Event的值。支持三个参数：<code>initEvent(eventName, canBubble, preventDefault)</code>. 分别表示事件名称，是否可以冒泡，是否阻止事件的默认操作。</li></ul><h2 id="on和addEventListener的使用与不同"><a href="#on和addEventListener的使用与不同" class="headerlink" title="on和addEventListener的使用与不同"></a>on和addEventListener的使用与不同</h2><h3 id="on"><a href="#on" class="headerlink" title="on"></a>on</h3><p>on的用法：以onclick为例</p><p>第一种：</p><div class="hljs"><pre><code class="hljs js">obj.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-comment">//do something..</span>&#125;</code></pre></div><p>第二种：</p><div class="hljs"><pre><code class="hljs js">obj.onclick= fn;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span> (<span class="hljs-params"></span>)</span>&#123;<span class="hljs-comment">//do something...</span>&#125;</code></pre></div><p>第三种：当函数fn有参数的情况下使用匿名函数来传参：</p><p>第一个默认传入<code>MouseEvent</code></p><div class="hljs"><pre><code class="hljs js">obj.onclick = <span class="hljs-function">(<span class="hljs-params">a,b</span>)=&gt;</span>fn(a,b)</code></pre></div><h3 id="addEventListener"><a href="#addEventListener" class="headerlink" title="addEventListener"></a>addEventListener</h3><p>形式：</p><ul><li><code>addEventListener(event,funtionName,useCapture)</code></li></ul><p>参数：</p><ul><li><code>event</code>:事件的类型如 “click”</li><li><code>funtionName</code>：方法名</li><li><code>useCapture</code>(可选)：布尔值，指定事件是否在捕获或冒泡阶段执行。</li><li><code>true</code> - 事件句柄在捕获阶段执行</li><li><code>false</code>- <code>false</code>- 默认。事件句柄在冒泡阶段执行</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解析href的方法</title>
    <link href="/2020/07/14/notes/web/js/%E8%A7%A3%E6%9E%90href/"/>
    <url>/2020/07/14/notes/web/js/%E8%A7%A3%E6%9E%90href/</url>
    
    <content type="html"><![CDATA[<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="node"><a href="#node" class="headerlink" title="node"></a>node</h3><p><a href="http://nodejs.cn/api/url.html#url_url" target="_blank" rel="noopener">http://nodejs.cn/api/url.html#url_url</a></p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// const url = require('url');</span><span class="hljs-keyword">const</span> myURL = <span class="hljs-keyword">new</span> URL(<span class="hljs-string">'https://example.org/foo#bar'</span>);<span class="hljs-built_in">console</span>.log(myURL.hash);<span class="hljs-comment">// #bar</span>myURL.hash = <span class="hljs-string">'baz'</span>;<span class="hljs-built_in">console</span>.log(myURL.href);<span class="hljs-comment">// https://example.org/foo#baz</span>url.hosturl.hostnameurl.origin<span class="hljs-comment">// ...</span></code></pre></div><h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><p><code>url = new URL(url, [base])</code></p><blockquote><p>如果 url 是绝对URL，则将忽略 base</p></blockquote><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> url = <span class="hljs-keyword">new</span> URL(<span class="hljs-string">'../cats'</span>, <span class="hljs-string">'http://www.example.com/dogs'</span>);<span class="hljs-built_in">console</span>.log(url.hostname); <span class="hljs-comment">// "www.example.com"</span><span class="hljs-built_in">console</span>.log(url.pathname); <span class="hljs-comment">// "/cats"</span>url.hash = <span class="hljs-string">'tabby'</span>;<span class="hljs-built_in">console</span>.log(url.href); <span class="hljs-comment">// "http://www.example.com/cats#tabby"</span><span class="hljs-keyword">const</span> url1 = <span class="hljs-keyword">new</span> URL(<span class="hljs-string">"https://some.site/?id=123&amp;cc=2&amp;id=1"</span>);<span class="hljs-built_in">console</span>.log(url1.searchParams.get(<span class="hljs-string">"id"</span>)); <span class="hljs-comment">// "123"</span></code></pre></div><h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> url = <span class="hljs-string">'https://www.baidu.com/#/?name=baidu'</span><span class="hljs-keyword">var</span> tag = <span class="hljs-built_in">window</span>.document.createElement(<span class="hljs-string">'a'</span>)tag.href = url<span class="hljs-built_in">console</span>.log(tag.origin)<span class="hljs-built_in">console</span>.log(tag.hash)</code></pre></div><div class="hljs"><pre><code class="hljs js">location<span class="hljs-built_in">Object</span>.keys(location)[<span class="hljs-string">"replace"</span>, <span class="hljs-string">"href"</span>, <span class="hljs-string">"ancestorOrigins"</span>, <span class="hljs-string">"origin"</span>, <span class="hljs-string">"protocol"</span>, <span class="hljs-string">"host"</span>, <span class="hljs-string">"hostname"</span>, <span class="hljs-string">"port"</span>, <span class="hljs-string">"pathname"</span>, <span class="hljs-string">"search"</span>, <span class="hljs-string">"hash"</span>, <span class="hljs-string">"assign"</span>, <span class="hljs-string">"reload"</span>, <span class="hljs-string">"toString"</span>]</code></pre></div><h2 id="获取search"><a href="#获取search" class="headerlink" title="获取search"></a>获取search</h2><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> url = <span class="hljs-keyword">new</span> URL(<span class="hljs-string">"https://some.site/?id=123&amp;cc=2&amp;id=1"</span>);<span class="hljs-built_in">console</span>.log(url.searchParams.get(<span class="hljs-string">"id"</span>));    <span class="hljs-comment">// "123"</span><span class="hljs-built_in">console</span>.log(url.search);                    <span class="hljs-comment">// "?id=123&amp;cc=2&amp;id=1"</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.fromEntries(url.searchParams));    <span class="hljs-comment">// &#123;id: "1", cc: "2"&#125;</span></code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>节流和防抖</title>
    <link href="/2020/07/14/notes/web/js/%E8%8A%82%E6%B5%81%E5%92%8C%E9%98%B2%E6%8A%96/"/>
    <url>/2020/07/14/notes/web/js/%E8%8A%82%E6%B5%81%E5%92%8C%E9%98%B2%E6%8A%96/</url>
    
    <content type="html"><![CDATA[<h2 id="节流函数-throttle"><a href="#节流函数-throttle" class="headerlink" title="节流函数 throttle"></a>节流函数 throttle</h2><p>函数节流指的是某个函数在一定时间间隔内（例如 3 秒）只执行一次，在这 3 秒内 无视后来产生的函数调用请求，也<strong>不会延长时间间隔</strong>。</p><h3 id="原理及实现"><a href="#原理及实现" class="headerlink" title="原理及实现"></a>原理及实现</h3><p>实现方案有以下两种</p><ul><li>第一种是用时间戳来判断是否已到执行时间，记录上次执行的时间戳，然后每次触发事件执行回调，回调中判断当前时间戳距离上次执行时间戳的间隔是否已经达到时间差（Xms） ，如果是则执行，并更新上次执行的时间戳，如此循环。</li><li>第二种方法是使用定时器，比如当 scroll 事件刚触发时，打印一个 hello world，然后设置个 1000ms 的定时器，此后每次触发 scroll 事件触发回调，如果已经存在定时器，则回调不执行方法，直到定时器触发，handler 被清除，然后重新设置定时器。</li></ul><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> throttle = <span class="hljs-function">(<span class="hljs-params">fn, wait = <span class="hljs-number">50</span></span>) =&gt;</span> &#123;    <span class="hljs-keyword">let</span> pre=<span class="hljs-number">0</span>;    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>)</span>&#123;        <span class="hljs-keyword">let</span> now=+<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();        <span class="hljs-keyword">if</span>(now-pre&gt;wait)&#123;            pre=now;            fn.apply(<span class="hljs-keyword">this</span>,args)        &#125;    &#125;&#125;<span class="hljs-keyword">const</span> func=throttle(fn,wait)<span class="hljs-comment">// 用fn，wait初始化，调用func执行fn</span></code></pre></div><h2 id="防抖函数-debounce"><a href="#防抖函数-debounce" class="headerlink" title="防抖函数 debounce"></a>防抖函数 debounce</h2><h3 id="定义及解读"><a href="#定义及解读" class="headerlink" title="定义及解读"></a>定义及解读</h3><p>防抖函数 <code>debounce</code> 指的是某个函数在某段时间内，无论触发了多少次回调，都只执行最后一次。在这 3 秒内如果遇到函数调用请求就<strong>重新计时</strong> 3 秒。</p><h3 id="原理-及实现"><a href="#原理-及实现" class="headerlink" title="原理 及实现"></a>原理 及实现</h3><p>实现原理就是利用定时器，函数第一次执行时设定一个定时器，之后调用时发现已经设定过定时器就清空之前的定时器，并重新设定一个新的定时器，如果存在没有被清空的定时器，当定时器计时结束后触发函数执行。</p><h4 id="实现1"><a href="#实现1" class="headerlink" title="实现1"></a>实现1</h4><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// fn 是需要防抖处理的函数</span><span class="hljs-comment">// wait 是时间间隔</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">fn, wait = <span class="hljs-number">50</span></span>) </span>&#123;    <span class="hljs-comment">// 通过闭包缓存一个定时器 id</span>    <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>    <span class="hljs-comment">// 将 debounce 处理结果当作函数返回</span>    <span class="hljs-comment">// 触发事件回调时执行这个返回函数</span>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) </span>&#123;        <span class="hljs-comment">// 如果已经设定过定时器就清空上一次的定时器</span>        <span class="hljs-keyword">if</span> (timer) clearTimeout(timer)        <span class="hljs-comment">// 开始设定一个新的定时器，定时器结束后执行传入的函数 fn</span>        timer = setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;            fn.apply(<span class="hljs-keyword">this</span>, args)        &#125;, wait)    &#125;&#125;</code></pre></div><h4 id="实现2"><a href="#实现2" class="headerlink" title="实现2"></a>实现2</h4><p>上述实现方案已经可以解决大部分使用场景了，不过想<strong>要实现第一次触发回调事件就执行 fn 有点力不从心了</strong>，这时候我们来改写下 debounce 函数，加上第一次触发立即执行的功能。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 实现 2</span><span class="hljs-comment">// immediate 表示第一次是否立即执行</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">fn, wait = <span class="hljs-number">50</span>, immediate</span>) </span>&#123;    <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) </span>&#123;        <span class="hljs-keyword">if</span> (timer) clearTimeout(timer)        <span class="hljs-comment">// ------ 新增部分 start ------</span>        <span class="hljs-comment">// immediate 为 true 表示第一次触发后执行</span>        <span class="hljs-comment">// timer 为空表示首次触发</span>        <span class="hljs-keyword">if</span> (immediate &amp;&amp; !timer) &#123;            fn.apply(<span class="hljs-keyword">this</span>, args)        &#125;        <span class="hljs-comment">// ------ 新增部分 end ------</span>        timer = setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;            fn.apply(<span class="hljs-keyword">this</span>, args)        &#125;, wait)    &#125;&#125;</code></pre></div><p>实现原理比较简单，判断传入的 immediate 是否为 true，另外需要额外判断是否是第一次执行防抖函数，判断依旧就是 timer 是否为空，所以只要 immediate &amp;&amp; !timer 返回 true 就执行 fn 函数，即 fn.apply(this, args)。</p><h4 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h4><p>TODO</p>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js实现继承的几种方法</title>
    <link href="/2020/07/14/notes/web/js/%E7%BB%A7%E6%89%BF8%E7%A7%8D/"/>
    <url>/2020/07/14/notes/web/js/%E7%BB%A7%E6%89%BF8%E7%A7%8D/</url>
    
    <content type="html"><![CDATA[<p><a href="http://www.ruanyifeng.com/blog/2011/06/designing_ideas_of_inheritance_mechanism_in_javascript.html" target="_blank" rel="noopener">继承机制历史</a></p><p><a href="https://juejin.im/post/5bcb2e295188255c55472db0" target="_blank" rel="noopener">https://juejin.im/post/5bcb2e295188255c55472db0</a></p><h2 id="1-原型链继承"><a href="#1-原型链继承" class="headerlink" title="1 原型链继承"></a>1 原型链继承</h2><p>原型链继承的本质是重写原型对象，代之以一个新类型的实例。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Animal</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">this</span>.value = <span class="hljs-string">'animal'</span>;&#125;Animal.prototype.run = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.value + <span class="hljs-string">' is runing'</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Cat</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<span class="hljs-comment">// 这里是关键，创建 Animal 的实例，并将该实例赋值给 Cat.prototype</span><span class="hljs-comment">// 相当于 Cat.prototype.__proto__ = Animal.prototype</span>Cat.prototype = <span class="hljs-keyword">new</span> Animal();<span class="hljs-keyword">var</span> instance = <span class="hljs-keyword">new</span> Cat();instance.value = <span class="hljs-string">'cat'</span>; <span class="hljs-comment">// 创建 instance 的自身属性 value</span><span class="hljs-built_in">console</span>.log(instance.run()); <span class="hljs-comment">// cat is runing</span></code></pre></div><p>原型链继承方案有以下缺点：</p><ul><li>1、多个实例对引用类型的操作<strong>会被篡改</strong></li><li>2、子类型的原型上的 constructor 属性被重写了</li><li>3、给子类型原型添加属性和方法必须在替换原型之后</li><li>4、创建子类型实例时无法向父类型的构造函数传参</li></ul><p><img src="http://pic.aizf.ink/md/js/5.webp" alt="avatar"></p><h2 id="2-借用构造函数继承"><a href="#2-借用构造函数继承" class="headerlink" title="2 借用构造函数继承"></a>2 借用构造函数继承</h2><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SuperType</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">this</span>.color=[<span class="hljs-string">"red"</span>,<span class="hljs-string">"green"</span>,<span class="hljs-string">"blue"</span>];&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SubType</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-comment">//继承自SuperType</span>    SuperType.call(<span class="hljs-keyword">this</span>);&#125;<span class="hljs-keyword">var</span> instance1 = <span class="hljs-keyword">new</span> SubType();instance1.color.push(<span class="hljs-string">"black"</span>);alert(instance1.color);<span class="hljs-comment">//"red,green,blue,black"</span><span class="hljs-keyword">var</span> instance2 = <span class="hljs-keyword">new</span> SubType();alert(instance2.color);<span class="hljs-comment">//"red,green,blue"</span></code></pre></div><p>缺点：</p><ol><li>只能继承父类的实例属性和方法，不能继承原型属性/方法</li><li>无法实现复用，每个子类都有父类实例函数的副本，影响性能</li></ol><h2 id="3-组合继承-结合上两种方法"><a href="#3-组合继承-结合上两种方法" class="headerlink" title="3 组合继承(结合上两种方法)"></a>3 组合继承(结合上两种方法)</h2><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SuperType</span>(<span class="hljs-params">name</span>)</span>&#123;    <span class="hljs-keyword">this</span>.name = name;    <span class="hljs-keyword">this</span>.colors = [<span class="hljs-string">"red"</span>, <span class="hljs-string">"blue"</span>, <span class="hljs-string">"green"</span>];&#125;SuperType.prototype.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    alert(<span class="hljs-keyword">this</span>.name);&#125;;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SubType</span>(<span class="hljs-params">name, age</span>)</span>&#123;    <span class="hljs-comment">// 第二次调用SuperType()</span>    SuperType.call(<span class="hljs-keyword">this</span>, name);    <span class="hljs-keyword">this</span>.age = age;&#125;<span class="hljs-comment">// 第一次调用SuperType()</span>SubType.prototype = <span class="hljs-keyword">new</span> SuperType();SubType.prototype.constructor = SubType;SubType.prototype.sayAge = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    alert(<span class="hljs-keyword">this</span>.age);&#125;;<span class="hljs-keyword">var</span> instance1 = <span class="hljs-keyword">new</span> SubType(<span class="hljs-string">"Nicholas"</span>, <span class="hljs-number">29</span>);instance1.colors.push(<span class="hljs-string">"black"</span>);alert(instance1.colors); <span class="hljs-comment">//"red,blue,green,black"</span>instance1.sayName(); <span class="hljs-comment">//"Nicholas";</span>instance1.sayAge(); <span class="hljs-comment">//29</span><span class="hljs-keyword">var</span> instance2 = <span class="hljs-keyword">new</span> SubType(<span class="hljs-string">"Greg"</span>, <span class="hljs-number">27</span>);alert(instance2.colors); <span class="hljs-comment">//"red,blue,green"</span>instance2.sayName(); <span class="hljs-comment">//"Greg";</span>instance2.sayAge(); <span class="hljs-comment">//27</span></code></pre></div><p>缺点：</p><ol><li>父类构造函数被调用两次</li><li>创建实例对象时，其原型中会存在两份相同的属性/方法。</li></ol><h2 id="4-原型式继承"><a href="#4-原型式继承" class="headerlink" title="4 原型式继承"></a>4 原型式继承</h2><p>用一个对象作中介，将父级属性添加到该对象的原型链上。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">object</span>(<span class="hljs-params">obj</span>) </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span>(<span class="hljs-params"></span>) </span>&#123; &#125;    F.prototype = obj;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> F();&#125;<span class="hljs-keyword">var</span> person = &#123;    name: <span class="hljs-string">"Nicholas"</span>,    friends: [<span class="hljs-string">"Shelby"</span>, <span class="hljs-string">"Court"</span>, <span class="hljs-string">"Van"</span>]&#125;;<span class="hljs-keyword">var</span> anotherPerson = object(person);anotherPerson.name = <span class="hljs-string">"Greg"</span>;anotherPerson.friends.push(<span class="hljs-string">"Rob"</span>);<span class="hljs-keyword">var</span> yetAnotherPerson = object(person);yetAnotherPerson.name = <span class="hljs-string">"Linda"</span>;yetAnotherPerson.friends.push(<span class="hljs-string">"Barbie"</span>);<span class="hljs-built_in">console</span>.log(person.friends);  <span class="hljs-comment">//"Shelby,Court,Van,Rob,Barbie"</span></code></pre></div><p>缺点：</p><ol><li>多实例间会篡改属性</li><li>无法传递参数</li></ol><h2 id="5-寄生式继承"><a href="#5-寄生式继承" class="headerlink" title="5 寄生式继承"></a>5 寄生式继承</h2><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createAnother</span>(<span class="hljs-params">original</span>)</span>&#123;    <span class="hljs-keyword">var</span> clone = object(original); <span class="hljs-comment">// 4中的 object()</span>    clone.sayHi = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-comment">// 对象增加属性</span>        alert(<span class="hljs-string">"hi"</span>);    &#125;;    <span class="hljs-keyword">return</span> clone; <span class="hljs-comment">// 返回这个对象</span>&#125;<span class="hljs-keyword">var</span> person = &#123;    name: <span class="hljs-string">"Nicholas"</span>,    friends: [<span class="hljs-string">"Shelby"</span>, <span class="hljs-string">"Court"</span>, <span class="hljs-string">"Van"</span>]&#125;;<span class="hljs-keyword">var</span> anotherPerson = createAnother(person);anotherPerson.sayHi(); <span class="hljs-comment">//"hi"</span></code></pre></div><p>缺点：</p><ol><li>多实例间会篡改属性</li><li>无法传递参数</li></ol><h2 id="6-寄生组合式继承"><a href="#6-寄生组合式继承" class="headerlink" title="6 寄生组合式继承"></a>6 寄生组合式继承</h2><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inheritPrototype</span>(<span class="hljs-params">subType, superType</span>)</span>&#123;    <span class="hljs-keyword">var</span> prototype = <span class="hljs-built_in">Object</span>.create(superType.prototype); <span class="hljs-comment">// 创建对象，创建父类原型的一个副本</span>    prototype.constructor = subType;                    <span class="hljs-comment">// 增强对象，弥补因重写原型而失去的默认的constructor 属性</span>    subType.prototype = prototype;                      <span class="hljs-comment">// 指定对象，将新创建的对象赋值给子类的原型</span>&#125;<span class="hljs-comment">// 父类初始化实例属性和原型属性</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SuperType</span>(<span class="hljs-params">name</span>)</span>&#123;    <span class="hljs-keyword">this</span>.name = name;    <span class="hljs-keyword">this</span>.colors = [<span class="hljs-string">"red"</span>, <span class="hljs-string">"blue"</span>, <span class="hljs-string">"green"</span>];&#125;SuperType.prototype.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    alert(<span class="hljs-keyword">this</span>.name);&#125;;<span class="hljs-comment">// 借用构造函数传递增强子类实例属性（支持传参和避免篡改）</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SubType</span>(<span class="hljs-params">name, age</span>)</span>&#123;    SuperType.call(<span class="hljs-keyword">this</span>, name);    <span class="hljs-keyword">this</span>.age = age;&#125;<span class="hljs-comment">// 将父类原型指向子类</span>inheritPrototype(SubType, SuperType);<span class="hljs-comment">// 新增子类原型属性</span>SubType.prototype.sayAge = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    alert(<span class="hljs-keyword">this</span>.age);&#125;<span class="hljs-keyword">var</span> instance1 = <span class="hljs-keyword">new</span> SubType(<span class="hljs-string">"xyc"</span>, <span class="hljs-number">23</span>);<span class="hljs-keyword">var</span> instance2 = <span class="hljs-keyword">new</span> SubType(<span class="hljs-string">"lxy"</span>, <span class="hljs-number">23</span>);instance1.colors.push(<span class="hljs-string">"2"</span>); <span class="hljs-comment">// ["red", "blue", "green", "2"]</span>instance1.colors.push(<span class="hljs-string">"3"</span>); <span class="hljs-comment">// ["red", "blue", "green", "3"]</span></code></pre></div><h2 id="7-ES6-class-extends"><a href="#7-ES6-class-extends" class="headerlink" title="7 ES6 class extends"></a>7 ES6 class extends</h2>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>箭头函数的this</title>
    <link href="/2020/07/14/notes/web/js/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0this/"/>
    <url>/2020/07/14/notes/web/js/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0this/</url>
    
    <content type="html"><![CDATA[<p>大部分情况下可以用一句话来概括，<strong>this总是指向调用该函数的对象</strong>。</p><p>但是对于箭头函数并不是这样，是根据<strong>外层</strong>（函数或者全局）<strong>作用域</strong>（词法作用域）来决定this。</p><p>对于箭头函数的this总结如下：</p><ul><li>箭头函数不绑定this，箭头函数中的this相当于普通变量。</li><li>箭头函数的this寻值行为与普通变量相同，在作用域中逐级寻找。</li><li>箭头函数的this无法通过bind，call，apply来直接修改（可以间接修改）。</li><li>改变作用域中this的指向可以改变箭头函数的this。</li><li>eg. function closure(){()=&gt;{//code }}，在此例中，我们通过改变封包环境closure.bind(another)()，来改变箭头函数this的指向。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js深拷贝</title>
    <link href="/2020/07/14/notes/web/js/%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
    <url>/2020/07/14/notes/web/js/%E6%B7%B1%E6%8B%B7%E8%B4%9D/</url>
    
    <content type="html"><![CDATA[<h2 id="JSON-满足大部分业务"><a href="#JSON-满足大部分业务" class="headerlink" title="JSON(满足大部分业务)"></a>JSON(满足大部分业务)</h2><p><code>let newObj = JSON.parse(JSON.stringify(obj));</code></p><p>弊端：函数，正则等会被解析为<code>{}</code></p><h2 id="2-一般"><a href="#2-一般" class="headerlink" title="2 一般"></a>2 一般</h2><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deepClone</span>(<span class="hljs-params">obj</span>) </span>&#123;    <span class="hljs-comment">// 去特</span>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> obj !== <span class="hljs-string">"object"</span>) <span class="hljs-keyword">return</span> obj;    <span class="hljs-keyword">if</span> (obj === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;    <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">RegExp</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(obj);    &#125;    <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Date</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Data(obj);    &#125;    <span class="hljs-comment">// 不直接创建空对象目的：克隆的结果和之前保持相同的所属类</span>    <span class="hljs-keyword">let</span> newObj = <span class="hljs-keyword">new</span> obj.constructor;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> obj) &#123;        <span class="hljs-keyword">if</span> (obj.hasOwnProperty(key)) &#123;            newObj[key] = deepClone(obj[key]);        &#125;    &#125;    <span class="hljs-keyword">return</span> newObj;&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>模拟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>bind原理及模拟实现</title>
    <link href="/2020/07/14/notes/web/js/%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90bind%E5%8E%9F%E7%90%86%E3%80%81%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%8F%8A%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/"/>
    <url>/2020/07/14/notes/web/js/%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90bind%E5%8E%9F%E7%90%86%E3%80%81%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%8F%8A%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p>bind返回的绑定函数也能使用 new 操作符创建对象：这种行为就像把原函数当成构造器，提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。</p><h2 id="模拟实现"><a href="#模拟实现" class="headerlink" title="模拟实现"></a>模拟实现</h2><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">Function</span>.prototype.bind = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">context, ...bindArgs</span>) </span>&#123;    context = context === <span class="hljs-literal">undefined</span> || context === <span class="hljs-literal">null</span> ? <span class="hljs-built_in">window</span> : <span class="hljs-built_in">Object</span>(context)    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> <span class="hljs-keyword">this</span>.apply(context, [...bindArgs, ...args])&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>模拟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js模块加载方案</title>
    <link href="/2020/07/14/notes/web/js/%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%96%B9%E6%A1%88/"/>
    <url>/2020/07/14/notes/web/js/%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.im/post/5bea425751882508851b45d6" target="_blank" rel="noopener">https://juejin.im/post/5bea425751882508851b45d6</a></p><ul><li>AMD</li><li>CMD</li><li>CommonJS</li><li>ES6 模块</li></ul><h2 id="require-js"><a href="#require-js" class="headerlink" title="require.js"></a>require.js</h2><h2 id="AMD-The-Asynchronous-Module-Definition"><a href="#AMD-The-Asynchronous-Module-Definition" class="headerlink" title="AMD(The Asynchronous Module Definition)"></a>AMD(The Asynchronous Module Definition)</h2><ul><li>浏览器端</li><li>异步,模块先加载完再执行代码</li></ul><p>浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用 AMD 规范。</p><p>定义了下面两个API：</p><ul><li><code>require([module], callback)</code>,加载一个模块</li><li><code>define(id, [depends], callback)</code>,来定义一个模块</li></ul><h2 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h2><ul><li>浏览器端</li><li>同步,require 的时候才去加载模块文件，加载完再接着执行。</li></ul><h2 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h2><ul><li>服务器端</li><li>同步,在 require 的时候才去加载模块文件，加载完再接着执行。</li><li>输出的是一个值的拷贝</li></ul><p>浏览器不支持，没有全局变量<code>module</code>, <code>require</code></p><p>由于 Node.js 主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以 CommonJS 规范比较适用。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 导出</span><span class="hljs-keyword">var</span> add = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x, y</span>) </span>&#123;    <span class="hljs-keyword">return</span> x + y;&#125;;<span class="hljs-built_in">module</span>.exports.add = add;<span class="hljs-comment">// 引入</span><span class="hljs-keyword">var</span> _add = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./add.js'</span>);<span class="hljs-built_in">console</span>.log(_add.add(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>));</code></pre></div><h2 id="UMD（Universal-Module-Definition）"><a href="#UMD（Universal-Module-Definition）" class="headerlink" title="UMD（Universal Module Definition）"></a>UMD（Universal Module Definition）</h2><p>AMD和CommonJS的糅合</p><p>UMD先判断是否支持Node.js的模块（exports）是否存在，存在则使用Node.js模块模式。<br>在判断是否支持AMD（define是否存在），存在则使用AMD方式加载模块。</p><div class="hljs"><pre><code class="hljs js">(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">window, factory</span>) </span>&#123;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> exports === <span class="hljs-string">'object'</span>) &#123;        <span class="hljs-built_in">module</span>.exports = factory();    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> define === <span class="hljs-string">'function'</span> &amp;&amp; define.amd) &#123;        define(factory);    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-built_in">window</span>.eventUtil = factory();    &#125;&#125;)(<span class="hljs-keyword">this</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-comment">//module ...</span>&#125;);</code></pre></div><h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><ul><li>异步,模块先加载完再执行代码</li><li>输出的是值的引用</li></ul><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 导出</span><span class="hljs-keyword">var</span> firstName = <span class="hljs-string">'Michael'</span>;<span class="hljs-keyword">var</span> lastName = <span class="hljs-string">'Jackson'</span>;<span class="hljs-keyword">var</span> year = <span class="hljs-number">1958</span>;<span class="hljs-keyword">export</span> &#123;firstName, lastName, year&#125;;<span class="hljs-comment">// 引入</span><span class="hljs-keyword">import</span> &#123;firstName, lastName, year&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./profile'</span>;</code></pre></div><h2 id="Babel编译-import-和-export"><a href="#Babel编译-import-和-export" class="headerlink" title="Babel编译 import 和 export"></a>Babel编译 import 和 export</h2>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>构造函数、原型和原型链</title>
    <link href="/2020/07/14/notes/web/js/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%81%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <url>/2020/07/14/notes/web/js/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%81%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<ul><li>所有实例对象需要<strong>共享</strong>的属性和方法，都放在<code>prototype</code>里面；</li><li>那些<strong>不需要共享</strong>的属性和方法，就放在<strong>构造函数</strong>里面。</li></ul><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p><code>constructor</code> 返回创建实例对象时构造函数的引用。此属性的值是对函数本身的引用，而不是一个包含函数名称的字符串。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent</span>(<span class="hljs-params">age</span>) </span>&#123;    <span class="hljs-keyword">this</span>.age = age;&#125;<span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> Parent(<span class="hljs-number">50</span>);p.constructor === Parent; <span class="hljs-comment">// true</span>p.constructor === <span class="hljs-built_in">Object</span>; <span class="hljs-comment">// false</span></code></pre></div><p>构造函数和普通函数的<strong>区别</strong>在于，使用 new 生成实例的函数就是构造函数，直接调用的就是普通函数。</p><p>普通函数创建的实例没可能也有 <code>constructor</code> 属性</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parent3</span>(<span class="hljs-params">age</span>) </span>&#123;    <span class="hljs-keyword">return</span> &#123;        age: age    &#125;&#125;<span class="hljs-keyword">var</span> p3 = parent3(<span class="hljs-number">50</span>);p3.constructor === <span class="hljs-built_in">Object</span>; <span class="hljs-comment">// true</span></code></pre></div><h3 id="constructor-值只读吗"><a href="#constructor-值只读吗" class="headerlink" title="constructor 值只读吗"></a>constructor 值只读吗</h3><p>对于引用类型来说 constructor 属性值是可以修改的，但是对于基本类型来说是只读的。</p><p>null 和 undefined 是没有 constructor 属性</p><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><h3 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a><code>prototype</code></h3><p><code>prototype</code>是<strong>函数才有的</strong>属性</p><p>每个对象拥有一个原型对象，对象以其原型为模板，从原型继承方法和属性，这些属性和方法定义在对象的构造器函数的 <code>prototype</code> 属性上，而非对象实例本身。</p><p>构造函数 <code>Parent</code> 有一个指向原型的指针，原型 <code>Parent.prototype</code> 有一个指向构造函数的指针 <code>Parent.prototype.constructor</code></p><p><img src="http://pic.aizf.ink/md/js/1.jpg" alt="avatar"></p><h3 id="proto"><a href="#proto" class="headerlink" title="__proto__"></a><code>__proto__</code></h3><p>是每个对象都有的属性,可以理解为“构造器的原型”，即<code>__proto__===constructor.protype</code></p><p>这是一个访问器属性（即 <code>getter</code> 函数和 <code>setter</code> 函数），通过它可以访问到对象的内部 <code>[[Prototype]]</code> (一个对象或 <code>null</code> )。</p><p><code>__proto__</code> 发音 dunder proto，最先被 Firefox使用，后来在 ES6 被列为 Javascript 的标准内建属性</p><p><code>[[Prototype]]</code>是对象的一个内部属性，外部代码无法直接访问。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> Parent();p.__proto__ === Parent.prototype<span class="hljs-comment">// true</span></code></pre></div><p><code>__proto__</code> 是每个实例上都有的属性，<code>prototype</code> 是构造函数的属性，这两个并不一样，但 <code>p.__proto__</code> 和 <code>Parent.prototype</code> 指向同一个对象。</p><p>所以构造函数 Parent、Parent.prototype 和 p 的关系如下图</p><p><img src="http://pic.aizf.ink/md/js/2.jpg" alt="avatar"></p><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p><code>__proto__</code> 属性在 ES6 时才被标准化，以确保 Web 浏览器的兼容性，但是不推荐使用，除了标准化的原因之外还有性能问题。为了更好的支持，推荐使用 <code>Object.getPrototypeOf()</code>。</p><p>如果要读取或修改对象的 [[Prototype]] 属性，建议使用如下方案，但是此时设置对象的 [[Prototype]] 依旧是一个缓慢的操作，如果性能是一个问题，就要避免这种操作。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 获取</span><span class="hljs-built_in">Object</span>.getPrototypeOf()<span class="hljs-built_in">Reflect</span>.getPrototypeOf()<span class="hljs-comment">// 修改</span><span class="hljs-built_in">Object</span>.setPrototypeOf()<span class="hljs-built_in">Reflect</span>.setPrototypeOf()</code></pre></div><p>如果要创建一个新对象，同时继承另一个对象的 [[Prototype]] ，推荐使用 Object.create()。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent</span>(<span class="hljs-params"></span>) </span>&#123;    age: <span class="hljs-number">50</span>&#125;;<span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> Parent();<span class="hljs-keyword">var</span> child = <span class="hljs-built_in">Object</span>.create(p);</code></pre></div><p>这里 child 是一个新的空对象，有一个指向对象 <code>p</code> 的指针 <code>__proto__</code>。</p><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>每个对象拥有一个原型对象，<strong>通过 <code>__proto__</code> 指针指向上一个原型</strong> ，并从中继承方法和属性，同时原型对象也可能拥有原型，这样一层一层，最终指向 <code>null</code>。这种关系被称为原型链 (prototype chain)，通过原型链一个对象会拥有定义在其他对象中的属性和方法。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent</span>(<span class="hljs-params">age</span>) </span>&#123;    <span class="hljs-keyword">this</span>.age = age;&#125;<span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> Parent(<span class="hljs-number">50</span>);p.constructor === Parent; <span class="hljs-comment">// true</span></code></pre></div><p>这里 p.constructor 指向 Parent，那是不是意味着 p 实例存在 constructor 属性呢？并不是。</p><p>我们打印下 p 值就知道,可以看到实例对象 <code>p</code> 本身没有 <code>constructor</code> 属性，是通过原型链向上查找 <code>__proto__</code> ，最终查找到 <code>constructor</code> 属性，该属性指向 <code>Parent</code>。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 木易杨</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent</span>(<span class="hljs-params">age</span>) </span>&#123;    <span class="hljs-keyword">this</span>.age = age;&#125;<span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> Parent(<span class="hljs-number">50</span>);p;<span class="hljs-comment">// Parent &#123;age: 50&#125;</span>p.__proto__ === Parent.prototype; <span class="hljs-comment">// true</span>p.__proto__.__proto__ === <span class="hljs-built_in">Object</span>.prototype; <span class="hljs-comment">// true</span>p.__proto__.__proto__.__proto__ === <span class="hljs-literal">null</span>; <span class="hljs-comment">// true</span></code></pre></div><p>运作机制</p><p><img src="http://pic.aizf.ink/md/js/3.jpg" alt="avatar"></p><h2 id="prototype-和-proto"><a href="#prototype-和-proto" class="headerlink" title="prototype 和 __proto__"></a><code>prototype</code> 和 <code>__proto__</code></h2><p>原型对象 <code>prototype</code> 是<strong>构造函数</strong>的属性，<code>__proto__</code>是每个实例上都有的属性，这两个并不一样，但 <code>foo.__proto__</code> 和 <code>Foo.prototype</code> 指向同一个对象。</p><p><img src="http://pic.aizf.ink/md/js/4.png" alt="avatar"></p><p>如上图，原型链的构建依赖于 <code>__proto__</code>,通过 <code>foo.__proto__</code> 指向 <code>Foo.prototype</code>，<code>foo.__proto__.__proto__</code> 指向 <code>Bichon.prototype</code>，如此一层一层最终链接到 <code>null</code>。</p><blockquote><p>可以这么理解 <code>Foo</code>，我是一个 <code>constructor</code>，我也是一个 <code>function</code>，我身上有着 <code>prototype</code> 的 reference，只要随时调用 <code>foo = new Foo()</code>，我就会将 <code>foo.__proto__</code> 指向到我的 <code>prototype</code> 对象。</p></blockquote><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>在原型链上查找属性比较耗时，对性能有副作用，这在性能要求苛刻的情况下很重要。另外，试图访问不存在的属性时会遍历整个原型链。</p>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js数组的查找方法汇总</title>
    <link href="/2020/07/14/notes/web/js/%E6%95%B0%E7%BB%84%E7%9A%84%E6%9F%A5%E6%89%BE%E6%96%B9%E6%B3%95/"/>
    <url>/2020/07/14/notes/web/js/%E6%95%B0%E7%BB%84%E7%9A%84%E6%9F%A5%E6%89%BE%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="arr-find-callback-thisArg"><a href="#arr-find-callback-thisArg" class="headerlink" title="arr.find(callback[, thisArg])"></a>arr.find(callback[, thisArg])</h2><p>返回数组中第一个满足所提供测试函数的元素的<strong>值</strong>，否则返回 <code>undefined</code>。</p><h2 id="arr-findIndex-callback-thisArg"><a href="#arr-findIndex-callback-thisArg" class="headerlink" title="arr.findIndex(callback[, thisArg])"></a>arr.findIndex(callback[, thisArg])</h2><p>返回数组中满足提供的测试函数的第一个元素的<strong>索引</strong>。否则返回<code>-1</code>。</p><h2 id="arr-includes-valueToFind-fromIndex"><a href="#arr-includes-valueToFind-fromIndex" class="headerlink" title="arr.includes(valueToFind[, fromIndex])"></a>arr.includes(valueToFind[, fromIndex])</h2><p><code>includes()</code> 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。</p><h2 id="arr-indexOf-searchElement-fromIndex"><a href="#arr-indexOf-searchElement-fromIndex" class="headerlink" title="arr.indexOf(searchElement[, fromIndex])"></a>arr.indexOf(searchElement[, fromIndex])</h2><p>返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。</p><h2 id="arr-lastIndexOf-searchElement-fromIndex"><a href="#arr-lastIndexOf-searchElement-fromIndex" class="headerlink" title="arr.lastIndexOf(searchElement[, fromIndex])"></a>arr.lastIndexOf(searchElement[, fromIndex])</h2><ul><li>fromIndex<ul><li>从此位置开始逆向查找。默认为数组的长度减 1(arr.length - 1)，即整个数组都被查找。如果该值大于或等于数组的长度，则整个数组会被查找。<strong>如果为负值，将其视为从数组末尾向前的偏移</strong>。</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js执行上下文与词法环境</title>
    <link href="/2020/07/14/notes/web/js/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%8E%E8%AF%8D%E6%B3%95%E7%8E%AF%E5%A2%83/"/>
    <url>/2020/07/14/notes/web/js/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%8E%E8%AF%8D%E6%B3%95%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.im/post/5eaabf895188256d7f12f412" target="_blank" rel="noopener">https://juejin.im/post/5eaabf895188256d7f12f412</a></p><h2 id="执行上下文-Execution-Context"><a href="#执行上下文-Execution-Context" class="headerlink" title="执行上下文(Execution Context)"></a>执行上下文(Execution Context)</h2><p>用来跟踪记录代码运行时环境的抽象概念。代码都是在执行上下文中运行的。</p><p>执行上下文中记录了代码执行过程中的状态信息，根据不同运行场景，执行上下文会细分为如下几种类型：</p><ul><li>全局执行上下文(Global Context)：当运行代码是处于全局作用域内，则会生成全局执行上下文，这也是程序最基础的执行上下文。</li><li>函数执行上下文：当调用函数时，都会为函数调用创建一个新的执行上下文。</li><li>eval执行上下文：eval函数执行时，会生成专属它的上下文，因eval很少使用，故不作讨论。</li></ul><h2 id="执行栈-Execution-Context-Stack"><a href="#执行栈-Execution-Context-Stack" class="headerlink" title="执行栈(Execution Context Stack)"></a>执行栈(Execution Context Stack)</h2><p>程序开始运行时，会先创建一个全局执行上下文并压入到执行栈中，之后每当有函数被调用，都会创建一个新的函数执行上下文并压入栈内。</p><h2 id="执行上下文的创建"><a href="#执行上下文的创建" class="headerlink" title="执行上下文的创建"></a>执行上下文的创建</h2><p>执行上下文创建会做两件事情：</p><ul><li>创建词法环境<code>Lexical Environment</code></li><li>创建变量环境<code>Variable Environment</code></li></ul><h3 id="词法环境-Lexical-Environment"><a href="#词法环境-Lexical-Environment" class="headerlink" title="词法环境(Lexical Environment)"></a>词法环境(Lexical Environment)</h3><p>词法环境就是建立了<strong>标识符——变量的映射表</strong>。这里的<strong>标识符</strong>指的是变量名称或函数名，而<strong>变量</strong>则是实际变量原始值或者对象/函数的引用地址。</p><p>在词法环境(Lexical Environment)中由三个部分构成：</p><ul><li>环境记录(Environment Record)：存放变量和函数声明的地方；</li><li>外层引用(outer)：提供了访问父词法环境的引用，可能为null；</li><li>this绑定ThisBinding：确定当前环境中this的指向；</li></ul><p>词法环境的类型:</p><ul><li>全局环境(Global Environment),代码运行开始,绑定内置的全局对象,全局环境的outer引用为null。</li><li>模块环境(Module Environment),在模块环境中你可以读取到export、module等变量，这些变量都是记录在模块环境的ER中。模块环境的outer引用指向全局环境。</li><li>函数环境(Function Environment),每一次调用函数时都会产生函数环境，在函数环境中会涉及this的绑定或super的调用。outer引用指向调起该函数的父环境。</li></ul><h3 id="变量环境-Variable-Environment"><a href="#变量环境-Variable-Environment" class="headerlink" title="变量环境(Variable Environment)"></a>变量环境(Variable Environment)</h3><p>变量环境本质上仍是词法环境，但它只存储var声明的变量，这样在初始化变量时可以赋值为undefined。</p><h4 id="let-const-与-var-区别"><a href="#let-const-与-var-区别" class="headerlink" title="let/const 与 var 区别"></a>let/const 与 var 区别</h4><ul><li>存放位置，let/const声明的变量是归属于Lexical Environment，而var声明的变量归属于Variable Environment。</li><li>初始化(词法阶段)，<code>let/const</code>暂时性死区，<code>var</code>在初始化时先被赋值为undefined</li><li>块作用域，let/const变量仅在块中有效</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js异常处理</title>
    <link href="/2020/07/14/notes/web/js/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <url>/2020/07/14/notes/web/js/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try ... catch ... finally"></a><code>try ... catch ... finally</code></h2><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> r1, r2, s = <span class="hljs-literal">null</span>;<span class="hljs-keyword">try</span> &#123;    r1 = s.length; <span class="hljs-comment">// 此处应产生错误</span>    r2 = <span class="hljs-number">100</span>; <span class="hljs-comment">// 该语句不会执行</span>&#125; <span class="hljs-keyword">catch</span> (e) &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'出错了：'</span> + e);&#125; <span class="hljs-keyword">finally</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'finally'</span>);&#125;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'r1 = '</span> + r1); <span class="hljs-comment">// r1应为undefined</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'r2 = '</span> + r2); <span class="hljs-comment">// r2应为undefined</span></code></pre></div><h2 id="错误类型"><a href="#错误类型" class="headerlink" title="错误类型"></a>错误类型</h2><p>JavaScript有一个标准的<code>Error</code>对象表示错误，还有从<code>Error</code>派生的<code>TypeError</code>、<code>ReferenceError</code>等错误对象。我们在处理错误时，可以通过<code>catch(e)</code>捕获的变量e访问错误对象：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">try</span> &#123;    ...&#125; <span class="hljs-keyword">catch</span> (e) &#123;    <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">TypeError</span>) &#123;        alert(<span class="hljs-string">'Type error!'</span>);    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Error</span>) &#123;        alert(e.message);    &#125; <span class="hljs-keyword">else</span> &#123;        alert(<span class="hljs-string">'Error: '</span> + e);    &#125;&#125;</code></pre></div><h2 id="抛出错误"><a href="#抛出错误" class="headerlink" title="抛出错误"></a>抛出错误</h2><p><code>throw new Error(&#39;输入错误&#39;);</code></p><h2 id="错误传播"><a href="#错误传播" class="headerlink" title="错误传播"></a>错误传播</h2><p>如果在一个函数内部发生了错误，它自身没有捕获，错误就会被抛到外层调用函数，如果外层函数也没有捕获，该错误会一直沿着函数调用链向上抛出，直到被JavaScript引擎捕获，代码终止执行。</p><h2 id="异步错误处理"><a href="#异步错误处理" class="headerlink" title="异步错误处理"></a>异步错误处理</h2><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// try...catch异步无效</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printTime</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>();&#125;<span class="hljs-keyword">try</span> &#123;    setTimeout(printTime, <span class="hljs-number">1000</span>);    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'done'</span>);&#125; <span class="hljs-keyword">catch</span> (e) &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'error'</span>);&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js垃圾回收机制</title>
    <link href="/2020/07/14/notes/web/js/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <url>/2020/07/14/notes/web/js/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.im/post/5ad3f1156fb9a028b86e78be#heading-3" target="_blank" rel="noopener">https://juejin.im/post/5ad3f1156fb9a028b86e78be#heading-3</a></p><p>JS内存空间分为栈(stack)、堆(heap)、池(一般也会归类为栈中)。 其中栈存放变量，堆存放复杂对象，池存放常量，所以也叫常量池</p><ul><li>基本类型：–&gt; 栈内存（<strong>不包含闭包中的变量</strong>）</li><li>引用类型：–&gt; 堆内存</li></ul><h2 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h2><p>垃圾收集器会每隔一段时间就执行一次释放操作，找出那些不再继续使用的值，然后释放其占用的内存。</p><p>局部变量和全局变量的销毁</p><ul><li>局部变量：局部作用域中，当函数执行完毕，局部变量也就没有存在的必要了，因此垃圾收集器很容易做出判断并回收。</li><li>全局变量：全局变量什么时候需要自动释放内存空间则很难判断，所以在开发中尽量避免使用全局变量。</li></ul><h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><p>核心思想就是如何判断内存已经不再使用，常用垃圾回收算法有下面两种。</p><ul><li>引用计数（现代浏览器不再使用，存在循环引用问题）</li><li><strong>标记清除</strong>（常用）</li></ul><p>标记清除算法将“不再使用的对象”定义为“<strong>无法到达的对象</strong>”。即从<strong>根部</strong>（在JS中就是<strong>全局对象</strong>）出发<strong>定时扫描</strong>内存中的对象，凡是能从根部到达的对象，即可达内存被标记，其余的被当作垃圾回收。</p><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。 对于不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）</p><h3 id="内存泄漏识别方法"><a href="#内存泄漏识别方法" class="headerlink" title="内存泄漏识别方法"></a>内存泄漏识别方法</h3><p>一、浏览器方法</p><ol><li>打开开发者工具，选择 Memory</li><li>在右侧的Select profiling type字段里面勾选 timeline</li><li>点击左上角的录制按钮。</li><li>在页面上进行各种操作，模拟用户的使用情况。</li><li>一段时间后，点击左上角的 stop 按钮，面板上就会显示这段时间的内存占用情况。</li></ol><p>二、命令行方法</p><p>使用 <code>Node</code> 提供的 <code>process.memoryUsage</code> 方法。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(process.memoryUsage());<span class="hljs-comment">// 输出</span>&#123;  rss: <span class="hljs-number">27709440</span>,        <span class="hljs-comment">// resident set size，所有内存占用，包括指令区和堆栈</span>  heapTotal: <span class="hljs-number">5685248</span>,   <span class="hljs-comment">// "堆"占用的内存，包括用到的和没用到的</span>  heapUsed: <span class="hljs-number">3449392</span>,    <span class="hljs-comment">// 用到的堆的部分</span>  external: <span class="hljs-number">8772</span>        <span class="hljs-comment">// V8 引擎内部的 C++ 对象占用的内存</span>&#125;</code></pre></div><p>判断内存泄漏，以<code>heapUsed</code>字段为准</p><h2 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h2><p>ES6 新出的两种数据结构：WeakSet 和 WeakMap，表示这是弱引用，它们对于值的引用都是不计入垃圾回收机制的。</p><p>先新建一个 Weakmap 实例，然后将一个 DOM 节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在 WeakMap 里面。这时，WeakMap 里面对element的引用就是弱引用，不会被计入垃圾回收机制。</p><h2 id="题"><a href="#题" class="headerlink" title="题"></a>题</h2><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = &#123;<span class="hljs-attr">n</span>: <span class="hljs-number">1</span>&#125;;<span class="hljs-keyword">var</span> b = a;a.x = a = &#123;<span class="hljs-attr">n</span>: <span class="hljs-number">2</span>&#125;;a.x     <span class="hljs-comment">// --&gt; undefined</span>b.x     <span class="hljs-comment">// --&gt; &#123;n: 2&#125;</span></code></pre></div><p>这道题的关键在于</p><ol><li>优先级。<code>.</code>的优先级高于<code>=</code>，所以先执行<code>a.x</code>，堆内存中的<code>{n: 1}</code>就会变成<code>{n: 1, x: undefined}</code>，改变之后相应的<code>b.x</code>也变化了，因为指向的是同一个对象。</li><li>赋值操作是从右到左，所以先执行<code>a = {n: 2}</code>，<code>a</code>的引用就被改变了，然后这个返回值又赋值给了<code>a.x</code>，需要注意的是这时候<code>a.x</code>是第一步中的<code>{n: 1, x: undefined}</code>那个对象，其实就是<code>b.x</code>，相当于<code>b.x = {n: 2}</code></li></ol><h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p>从内存来看 null 和 undefined 本质的区别是什么？</p><p>给一个<strong>全局变量赋值为<code>null</code></strong>，相当于将这个变量的指针对象以及值清空；如果是给<strong>对象的属性</strong>赋值为<code>null</code>，或者<strong>局部变量</strong>赋值为<code>null</code>,相当于给这个属性分配了一块空的内存，然后值为<code>null</code>， JS会回收全局变量为<code>null</code>的对象。</p><p>给一个全局变量赋值为undefined，相当于将这个对象的值清空，但是这个对象依旧存在,如果是给对象的属性赋值 为undefined，说明这个值为空值</p><p><strong>注意</strong>：</p><p>声明了一个变量，但未对其初始化时，这个变量的值就是undefined，它是 JavaScript 基本类型之一。</p><p>对于尚未声明过的变量，只能执行一项操作，即使用typeof操作符检测其数据类型，返回<code>&quot;undefined&quot;</code>使用其他的操作都会报错。</p><h2 id="四种常见的JS内存泄漏"><a href="#四种常见的JS内存泄漏" class="headerlink" title="四种常见的JS内存泄漏"></a>四种常见的JS内存泄漏</h2><p>总体来说，存在意外地引用</p><h3 id="1、意外的全局变量"><a href="#1、意外的全局变量" class="headerlink" title="1、意外的全局变量"></a>1、意外的全局变量</h3><p>未定义的变量会在全局对象创建一个新变量，如下。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">arg</span>) </span>&#123;    bar = <span class="hljs-string">"this is a hidden global variable"</span>;&#125;</code></pre></div><p>另一个意外的全局变量可能由 this 创建。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">this</span>.variable = <span class="hljs-string">"potential accidental global"</span>;&#125;<span class="hljs-comment">// Foo 调用自己，this 指向了全局对象（window）</span><span class="hljs-comment">// 而不是 undefined</span>foo();</code></pre></div><p>解决方法：</p><p>在 <strong>JavaScript</strong> 文件头部加上 <strong>‘use strict’</strong>，使用严格模式避免意外的全局变量，此时上例中的<strong>this</strong>指向<strong>undefined</strong>。如果必须使用全局变量存储大量数据时，<strong>确保用完以后把它设置为 null 或者重新定义</strong>。</p><h3 id="2、被遗忘的计时器或回调函数"><a href="#2、被遗忘的计时器或回调函数" class="headerlink" title="2、被遗忘的计时器或回调函数"></a>2、被遗忘的计时器或回调函数</h3><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> someResource = getData();setInterval(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> node = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'Node'</span>);    <span class="hljs-keyword">if</span>(node) &#123;        <span class="hljs-comment">// 处理 node 和 someResource</span>        node.innerHTML = <span class="hljs-built_in">JSON</span>.stringify(someResource));    &#125;&#125;, <span class="hljs-number">1000</span>);</code></pre></div><p>在节点<code>node</code>或者数据不再需要时，定时器依旧指向这些数据,哪怕当<code>node</code><strong>节点</strong>被移除后，由于<code>interval</code> 仍旧存活,垃圾回收器没办法回收，除非终止定时器。</p><p><code>addEventListener</code></p><p>老版本的 IE 是无法检测 DOM 节点与 JavaScript 代码之间的循环引用，会导致内存泄漏。现代的浏览器（包括 IE 和 Microsoft Edge）使用了更先进的垃圾回收算法（标记清除）,即回收节点内存时，不必非要调用 <code>removeEventListener</code> 了。</p><h3 id="3、脱离-DOM-的引用"><a href="#3、脱离-DOM-的引用" class="headerlink" title="3、脱离 DOM 的引用"></a>3、脱离 DOM 的引用</h3><p>如果把DOM 存成字典（JSON 键值对）或者数组，此时，同样的 DOM 元素存在两个引用：一个在 <strong>DOM 树中</strong>，另一个在<strong>字典</strong>中。那么<strong>将来需要把两个引用都清除</strong>。</p><p>如果代码中保存了表格某一个 <code>&lt;td&gt;</code> 的引用。将来决定删除整个表格的时候，此 <code>&lt;td&gt;</code> 是<strong>表格的子节点，子元素与父元素是引用关系。</strong>由于代码保留了 <code>&lt;td&gt;</code> 的引用，导致整个表格仍待在内存中。所以保存 DOM 元素引用的时候，要小心谨慎。</p><h3 id="4、闭包"><a href="#4、闭包" class="headerlink" title="4、闭包"></a>4、闭包</h3><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> theThing = <span class="hljs-literal">null</span>;<span class="hljs-keyword">var</span> replaceThing = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> originalThing = theThing;    <span class="hljs-keyword">var</span> unused = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">if</span> (originalThing)        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"hi"</span>);    &#125;;    theThing = &#123;        longStr: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">1000000</span>).join(<span class="hljs-string">'*'</span>),        someMethod: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;            <span class="hljs-built_in">console</span>.log(someMessage);        &#125;    &#125;;&#125;;setInterval(replaceThing, <span class="hljs-number">1000</span>);</code></pre></div><p>闭包引用父级作用域的变量，会导致不被回收</p><h2 id="Chrome-内存剖析工具概览"><a href="#Chrome-内存剖析工具概览" class="headerlink" title="Chrome 内存剖析工具概览"></a>Chrome 内存剖析工具概览</h2><p><a href="https://jinlong.github.io/2016/05/01/4-Types-of-Memory-Leaks-in-JavaScript-and-How-to-Get-Rid-Of-Them/" target="_blank" rel="noopener">https://jinlong.github.io/2016/05/01/4-Types-of-Memory-Leaks-in-JavaScript-and-How-to-Get-Rid-Of-Them/</a></p><h2 id="V8的垃圾回收机制详解-待续"><a href="#V8的垃圾回收机制详解-待续" class="headerlink" title="V8的垃圾回收机制详解(待续)"></a>V8的垃圾回收机制详解(待续)</h2><p>V8的垃圾回收机制分为新生代和老生代。</p>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js变量提升机制</title>
    <link href="/2020/07/14/notes/web/js/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/"/>
    <url>/2020/07/14/notes/web/js/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/</url>
    
    <content type="html"><![CDATA[<p><code>var</code> <code>function</code>在当前作用于会变量提升:</p><ul><li><code>var</code>会先声明</li><li><code>function</code>会同时声明和定义</li></ul><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// undefined</span><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;</code></pre></div><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// ReferenceError: a is not defined</span></code></pre></div><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> B = <span class="hljs-number">1</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">B</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<span class="hljs-built_in">console</span>.log(B); <span class="hljs-comment">// 1</span></code></pre></div><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> B = <span class="hljs-number">1</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">B</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<span class="hljs-built_in">console</span>.log(B); <span class="hljs-comment">// 1</span></code></pre></div><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> B;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">B</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<span class="hljs-built_in">console</span>.log(B); <span class="hljs-comment">// ƒ B() &#123;&#125;</span></code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>变量带不带var</title>
    <link href="/2020/07/14/notes/web/js/%E5%8F%98%E9%87%8F%E5%B8%A6%E4%B8%8D%E5%B8%A6var/"/>
    <url>/2020/07/14/notes/web/js/%E5%8F%98%E9%87%8F%E5%B8%A6%E4%B8%8D%E5%B8%A6var/</url>
    
    <content type="html"><![CDATA[<table><thead><tr><th>-</th><th>带var</th><th>不带var</th></tr></thead><tbody><tr><td>全局作用域中</td><td>window添加属性，且不能删除，变量提升</td><td>window添加属性，可以删除</td></tr><tr><td>私有作用域</td><td>私有变量(也会变量提升)</td><td>全局变量</td></tr></tbody></table><p>在函数中直接<code>console.log(a)</code>，会从当前作用域一直向上查询，直到查找到或到达window（闭包）</p>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js作用域和作用域链</title>
    <link href="/2020/07/14/notes/web/js/%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/"/>
    <url>/2020/07/14/notes/web/js/%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="1-作用域-Scope"><a href="#1-作用域-Scope" class="headerlink" title="1 作用域(Scope)"></a>1 作用域(Scope)</h2><p>作用域是在运行时代码中的某些特定部分中变量，函数和对象的可访问性。换句话说，<strong>作用域决定了代码区块中变量和其他资源的可见性</strong>。</p><p>ES6 之前 JavaScript 没有块级作用域,只有全局作用域和函数作用域。ES6 的到来，为我们提供了‘块级作用域’,可通过新增命令 let 和 const 来体现。</p><h3 id="1-1-全局作用域和函数作用域"><a href="#1-1-全局作用域和函数作用域" class="headerlink" title="1.1 全局作用域和函数作用域"></a>1.1 全局作用域和函数作用域</h3><p>在代码中任何地方都能访问到的对象拥有全局作用域</p><p>一般情况下，window 对象的内置属性都拥有全局作用域，例如 window.name、window.location、window.top 等等。</p><p>作用域是分层的，内层作用域可以访问外层作用域的变量，反之则不行。</p><h3 id="1-2-块级作用域"><a href="#1-2-块级作用域" class="headerlink" title="1.2 块级作用域"></a>1.2 块级作用域</h3><p>块级作用域在如下情况被创建：</p><ol><li>在一个函数内部</li><li>在一个代码块（由一对花括号包裹）内部</li></ol><p>暂时性死区</p><h2 id="2-作用域链"><a href="#2-作用域链" class="headerlink" title="2 作用域链"></a>2 作用域链</h2><h3 id="2-1-自由变量"><a href="#2-1-自由变量" class="headerlink" title="2.1 自由变量"></a>2.1 自由变量</h3><p>首先认识一下什么叫做 自由变量 。如下代码中，<code>console.log(a)</code>要得到 <code>a</code> 变量，但是在当前的作用域中没有定义 <code>a</code>（可对比一下 <code>b</code>）。当前作用域没有定义的变量，这成为 自由变量。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">100</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> b = <span class="hljs-number">200</span>    <span class="hljs-built_in">console</span>.log(a) <span class="hljs-comment">// 这里的a在这里就是一个自由变量</span>    <span class="hljs-built_in">console</span>.log(b)&#125;fn()</code></pre></div><h3 id="2-2-什么是作用域链"><a href="#2-2-什么是作用域链" class="headerlink" title="2.2 什么是作用域链"></a>2.2 什么是作用域链</h3><p>如果父级也没呢？再一层一层向上寻找，直到找到全局作用域还是没找到，就宣布放弃。这种一层一层的关系，就是 作用域链 。</p><h3 id="2-3-关于自由变量的取值"><a href="#2-3-关于自由变量的取值" class="headerlink" title="2.3 关于自由变量的取值"></a>2.3 关于自由变量的取值</h3><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> x = <span class="hljs-number">10</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(x)&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">show</span>(<span class="hljs-params">f</span>) </span>&#123;  <span class="hljs-keyword">var</span> x = <span class="hljs-number">20</span>  (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    f()  &#125;)()&#125;show(fn)    <span class="hljs-comment">//10，而不是20</span></code></pre></div><p>在 <code>fn</code> 函数中，取自由变量 <code>x</code> 的值时，要到哪个作用域中取？——<strong>要到创建 <code>fn</code> 函数的那个作用域中取，无论 <code>fn</code> 函数将在哪里调用</strong>。</p><p>这就是所谓的”<strong>静态作用域</strong>“</p><h2 id="3-作用域与执行上下文"><a href="#3-作用域与执行上下文" class="headerlink" title="3 作用域与执行上下文"></a>3 作用域与执行上下文</h2><p>JavaScript 属于解释型语言，JavaScript 的执行分为：<strong>解释</strong>和<strong>执行</strong>两个阶段,这两个阶段所做的事并不一样</p><p>解释阶段：</p><ul><li>词法分析</li><li>语法分析</li><li>作用域规则确定</li></ul><p>执行阶段：</p><ul><li>创建执行上下文(比如<code>this</code>)</li><li>执行函数代码</li><li>垃圾回收</li></ul><h2 id="有三种语句可以加强作用域链：try-catch；with；eval"><a href="#有三种语句可以加强作用域链：try-catch；with；eval" class="headerlink" title="有三种语句可以加强作用域链：try catch；with；eval"></a>有三种语句可以加强作用域链：try catch；with；eval</h2><p><code>trycatch</code>中的<code>catch</code>和<code>with</code>语句都会在作用域链的前端添加一个变量对象。</p><p>对<code>with</code>语句来说，将指定的对象添加到作用域链中</p><p>对<code>catch</code>语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明</p><p>而<code>eval</code>由于可以被赋值给变量，在被赋值的时候会将<code>eval</code>所处的变量作用域也赋值过去，所以可以使得作用域获得扩展。</p><p>eg:</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a=<span class="hljs-number">0</span>;<span class="hljs-keyword">try</span>&#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"error"</span>)&#125;<span class="hljs-keyword">catch</span>(e)&#123;    <span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">//undefined</span>&#125;</code></pre></div><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> x=<span class="hljs-number">1</span>,evalg=<span class="hljs-built_in">eval</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>)</span>&#123;　　<span class="hljs-keyword">var</span> x=<span class="hljs-number">3</span>;　　<span class="hljs-built_in">eval</span>(<span class="hljs-string">"alert(x)"</span>);   <span class="hljs-comment">//3</span>　　evalg(<span class="hljs-string">"alert(x)"</span>);  <span class="hljs-comment">//1</span>&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js的一些优雅写法</title>
    <link href="/2020/07/14/notes/web/js/%E4%BC%98%E9%9B%85%E5%86%99%E6%B3%95/"/>
    <url>/2020/07/14/notes/web/js/%E4%BC%98%E9%9B%85%E5%86%99%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="1-判空赋值"><a href="#1-判空赋值" class="headerlink" title="1 判空赋值"></a>1 判空赋值</h2><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 普通写法</span><span class="hljs-keyword">if</span>(a == <span class="hljs-literal">undefined</span>) a=[];<span class="hljs-keyword">if</span>(p.suc)&#123;    p.suc(res);&#125;<span class="hljs-comment">// 改</span>a = a || [];p.suc &amp;&amp; p.suc(res);</code></pre></div><h2 id="2-多条件判断"><a href="#2-多条件判断" class="headerlink" title="2 多条件判断"></a>2 多条件判断</h2><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> foo1 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-comment">// ...</span>&#125;<span class="hljs-keyword">var</span> foo2 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-comment">// ...</span>&#125;<span class="hljs-comment">// 普通写法</span><span class="hljs-keyword">switch</span>(val)&#123;    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:        foo1();        <span class="hljs-keyword">break</span>;    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:        foo2();        <span class="hljs-keyword">break</span>;&#125;<span class="hljs-comment">// 改</span><span class="hljs-keyword">const</span> switchFunc = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([    [<span class="hljs-number">0</span>, foo0],    [<span class="hljs-number">1</span>, foo1],    [<span class="hljs-number">2</span>, foo2],    [<span class="hljs-number">3</span>, foo3],])switchFunc.get(n) &amp;&amp; switchFunc.get(n)();</code></pre></div><h2 id="3-匿名函数"><a href="#3-匿名函数" class="headerlink" title="3 匿名函数"></a>3 匿名函数</h2><div class="hljs"><pre><code class="hljs js">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;)()<span class="hljs-comment">// 改</span><span class="hljs-comment">/**</span><span class="hljs-comment">* 防止上一条语句忘写";"，造成语法错误</span><span class="hljs-comment">* 少一个字符</span><span class="hljs-comment">*/</span>+<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;()!<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;()</code></pre></div><h2 id="4-取整"><a href="#4-取整" class="headerlink" title="4 取整"></a>4 取整</h2><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1.11</span><span class="hljs-comment">// 1</span><span class="hljs-built_in">parseInt</span>(a);a | <span class="hljs-number">0</span>;~~a;</code></pre></div><h2 id="5-async-await"><a href="#5-async-await" class="headerlink" title="5 async await"></a>5 async await</h2><h2 id="6-解构"><a href="#6-解构" class="headerlink" title="6 解构"></a>6 解构</h2><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = &#123;<span class="hljs-attr">a</span>:<span class="hljs-number">1</span>,<span class="hljs-attr">b</span>:<span class="hljs-number">2</span>&#125;;<span class="hljs-keyword">const</span> &#123;b, c = <span class="hljs-number">3</span>&#125; = obj;b;  <span class="hljs-comment">// 2</span>c;  <span class="hljs-comment">// 3</span></code></pre></div><h2 id="7-取数组最大值"><a href="#7-取数组最大值" class="headerlink" title="7 取数组最大值"></a>7 取数组最大值</h2><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// ES6</span><span class="hljs-built_in">Math</span>.max(...[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]);<span class="hljs-comment">// ES5</span><span class="hljs-built_in">Math</span>.max.apply(<span class="hljs-built_in">Math</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]);</code></pre></div><h2 id="8-生成规律数组"><a href="#8-生成规律数组" class="headerlink" title="8 生成规律数组"></a>8 生成规律数组</h2><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">Array</span>.from(<span class="hljs-built_in">Array</span>(<span class="hljs-number">10</span>), (d, i) =&gt;  i + <span class="hljs-number">1</span>)<span class="hljs-comment">// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span>[...Array(<span class="hljs-number">10</span>)].map(<span class="hljs-function">(<span class="hljs-params">d, i</span>) =&gt;</span>  i + <span class="hljs-number">1</span>);<span class="hljs-comment">// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span></code></pre></div><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = <span class="hljs-built_in">Array</span>.from(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">10</span>), (d, i) =&gt; &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">10</span>).fill(<span class="hljs-number">0</span>) &#125;)arr[<span class="hljs-number">0</span>] === arr[<span class="hljs-number">1</span>] <span class="hljs-comment">// false</span></code></pre></div><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">Array</span>.apply(<span class="hljs-literal">null</span>, &#123; <span class="hljs-attr">length</span>: <span class="hljs-number">20</span> &#125;).map(<span class="hljs-function">(<span class="hljs-params">d, i</span>) =&gt;</span> &#123; <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span> &#125;)<span class="hljs-comment">// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]</span></code></pre></div><h2 id="9-连接数组"><a href="#9-连接数组" class="headerlink" title="9 连接数组"></a>9 连接数组</h2><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr1 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<span class="hljs-keyword">const</span> arr2 = [<span class="hljs-number">5</span>,<span class="hljs-number">6</span>];<span class="hljs-comment">// arr1结果</span><span class="hljs-comment">// [1, 2, 3, 5, 6]</span><span class="hljs-comment">// 1, 改变原数组</span>arr1.push.apply(arr1, arr2);<span class="hljs-comment">// 2, 改变原数组</span>arr1.concat(arr2)<span class="hljs-comment">// 3, 不改变原数组</span>[...arr1, ...arr2]</code></pre></div><h2 id="10-同时遍历对象的key和value"><a href="#10-同时遍历对象的key和value" class="headerlink" title="10 同时遍历对象的key和value"></a>10 同时遍历对象的key和value</h2><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [key, value] <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.entries(obj)) &#123;    <span class="hljs-built_in">console</span>.log(key, value);&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一些代码片段</title>
    <link href="/2020/07/14/notes/web/js/%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/"/>
    <url>/2020/07/14/notes/web/js/%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/</url>
    
    <content type="html"><![CDATA[<h3 id="手动触发dom的事件"><a href="#手动触发dom的事件" class="headerlink" title="手动触发dom的事件"></a>手动触发dom的事件</h3><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 创建var evt = document.createEvent("HTMLEvents");</span><span class="hljs-comment">// 初始化</span>evt.initEvent(<span class="hljs-string">"alert"</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>);<span class="hljs-comment">// 触发, 即弹出文字</span>dom.dispatchEvent(evt);</code></pre></div><p>initEvent()方法用于初始化通过DocumentEvent接口创建的Event的值。</p><p>支持三个参数：initEvent(eventName, canBubble, preventDefault)<br>分别表示：</p><ul><li>事件名称   <code>eventName = eventName.replace(/^on/i,&#39;&#39;);</code></li><li>是否可以冒泡</li><li>是否阻止事件的默认操作</li></ul><h3 id="如果b不等于undefined和null，那a就等于b的值"><a href="#如果b不等于undefined和null，那a就等于b的值" class="headerlink" title="如果b不等于undefined和null，那a就等于b的值"></a>如果b不等于undefined和null，那a就等于b的值</h3><div class="hljs"><pre><code class="hljs js">a=b||<span class="hljs-number">0</span>;undefine||<span class="hljs-number">0</span> === <span class="hljs-number">0</span></code></pre></div><h3 id="乱序数组"><a href="#乱序数组" class="headerlink" title="乱序数组"></a>乱序数组</h3><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shuffle</span>(<span class="hljs-params">a</span>) </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = a.length; i; i--) &#123;        <span class="hljs-keyword">let</span> j = <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * i);        [a[i - <span class="hljs-number">1</span>], a[j]] = [a[j], a[i - <span class="hljs-number">1</span>]];    &#125;    <span class="hljs-keyword">return</span> a;&#125;</code></pre></div><h3 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h3><p><code>Number.prototype.toString.call(num,jinzhi)</code></p><blockquote><p>返回转换进制的字符串,num为数字，jinzhi为指定的进制</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js事件循环中函数执行顺序</title>
    <link href="/2020/07/14/notes/web/js/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E4%B8%AD%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/"/>
    <url>/2020/07/14/notes/web/js/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E4%B8%AD%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="题"><a href="#题" class="headerlink" title="题"></a>题</h2><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//请写出输出内容</span><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async1</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'async1 start'</span>);    <span class="hljs-keyword">await</span> async2();    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'async1 end'</span>);&#125;<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async2</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'async2'</span>);&#125;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'script start'</span>);setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'setTimeout'</span>);&#125;, <span class="hljs-number">0</span>)async1();<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'promise1'</span>);    resolve();&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'promise2'</span>);&#125;);<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'script end'</span>);<span class="hljs-comment">/*</span><span class="hljs-comment">script start</span><span class="hljs-comment">async1 start</span><span class="hljs-comment">async2</span><span class="hljs-comment">promise1</span><span class="hljs-comment">script end</span><span class="hljs-comment">async1 end</span><span class="hljs-comment">promise2</span><span class="hljs-comment">setTimeout</span><span class="hljs-comment">*/</span></code></pre></div><h2 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h2><ul><li>JS分为同步任务和异步任务</li><li>同步任务都在主线程上执行，形成一个执行栈</li><li>主线程之外，事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放置一个事件。</li><li>一旦执行栈中的所有同步任务执行完毕（此时JS引擎空闲），系统就会读取任务队列，将可运行的异步任务添加到可执行栈中，开始执行。</li></ul><p>根据规范，事件循环是通过任务队列的机制来进行协调的。一个 Event Loop 中，可以有一个或者多个任务队列(task queue)，一个任务队列便是一系列有序任务(task)的集合；每个任务都有一个任务源(task source)，源自同一个任务源的 task 必须放到同一个任务队列，从不同源来的则被添加到不同队列。 setTimeout/Promise 等API便是任务源，而进入任务队列的是他们指定的具体执行任务。</p><h2 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h2><p>包括每次从事件队列中获取一个事件回调并放到执行栈中执行</p><p>浏览器为了能够使得JS内部(macro)task与DOM任务能够有序的执行，会在一个(macro)task执行结束后，在下一个(macro)task 执行开始前，对页面进行重新渲染，流程如下：</p><p><code>(macro)task-&gt;渲染-&gt;(macro)task-&gt;...</code></p><p>(macro)task主要包含：<strong>script(整体代码)</strong>、<strong>setTimeout</strong>、<strong>setInterval</strong>、I/O、<strong>UI交互事件</strong>、postMessage、MessageChannel、setImmediate(Node.js 环境)</p><h2 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h2><p>microtask（又称为微任务），可以理解是在当前 task 执行结束后立即执行的任务。也就是说，在当前task任务后，<strong>下一个task之前，在渲染之前</strong>。</p><p>也就是说，在某一个macrotask执行完后，就会将在它<strong>执行期间</strong>产生的所有microtask都执行完毕（在渲染前）。</p><p>microtask主要包含：Promise.then、MutaionObserver、process.nextTick(Node.js 环境)</p><h2 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h2><p>在事件循环中，每进行一次循环操作称为 tick，每一次 tick 的任务处理模型是比较复杂的，但关键步骤如下：</p><ul><li>执行一个宏任务（栈中没有就从事件队列中获取）</li><li>执行过程中如果遇到微任务，就将它添加到微任务的任务队列中</li><li>宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）</li><li>当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染</li><li>渲染完毕后，JS线程继续接管，<strong>开始下一个宏任务（从事件队列中获取）</strong></li></ul><h2 id="Promise和async中的立即执行"><a href="#Promise和async中的立即执行" class="headerlink" title="Promise和async中的立即执行"></a>Promise和async中的立即执行</h2><p>在async/await中，在出现await出现之前，其中的代码也是立即执行的。</p><h2 id="await做了什么"><a href="#await做了什么" class="headerlink" title="await做了什么"></a>await做了什么</h2><p>很多人以为await会一直等待之后的表达式执行完之后才会继续执行后面的代码，<strong>实际上await是一个让出线程的标志。await后面的表达式会先执行一遍，将await后面的代码加入到microtask中，然后就会跳出整个async函数来执行后面的代码。</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js事件</title>
    <link href="/2020/07/14/notes/web/js/%E4%BA%8B%E4%BB%B6/"/>
    <url>/2020/07/14/notes/web/js/%E4%BA%8B%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="触发事件的原因"><a href="#触发事件的原因" class="headerlink" title="触发事件的原因"></a>触发事件的原因</h2><ul><li>窗口， 例如，如果用户最大化窗口或以其他方式更改窗口大小。</li><li>网页的进程加载</li><li>用户与网页内容的交互</li><li>网页结构或内容的修改</li><li>嵌入在HTML文档中的媒体流</li><li>网页发出的网络请求</li></ul><h2 id="监听事件的方法"><a href="#监听事件的方法" class="headerlink" title="监听事件的方法"></a>监听事件的方法</h2><ul><li><code>on-event</code></li><li><code>addEventListener()</code></li></ul><h2 id="监听，创建和触发-events"><a href="#监听，创建和触发-events" class="headerlink" title="监听，创建和触发 events"></a>监听，创建和触发 events</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/Events/Creating_and_triggering_events" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/Guide/Events/Creating_and_triggering_events</a></p><h3 id="监听事件"><a href="#监听事件" class="headerlink" title="监听事件"></a>监听事件</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener</a></p><p><code>target.addEventListener(type, listener, options)</code></p><p><code>target.addEventListener(type, listener, useCapture)</code></p><p>参数:</p><p><code>type</code></p><blockquote><p>事件类型</p></blockquote><p><code>listener</code></p><blockquote><p>回调</p></blockquote><p><code>useCapture(可选)</code></p><blockquote><p>默认为 false, 是否捕获</p></blockquote><p><code>options(可选)</code></p><blockquote><p>可选参数对象</p><ul><li>capture: Boolean</li><li>once: Boolean,listener 在添加之后最多只调用一次</li><li>passive: Boolean，设置为true时，表示 listener 永远不会调用 preventDefault()。如果 listener 仍然调用了这个函数，客户端将会忽略它并抛出一个控制台警告。</li></ul></blockquote><h3 id="创建事件"><a href="#创建事件" class="headerlink" title="创建事件"></a>创建事件</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event/Event" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Event/Event</a></p><p><code>event = new Event(typeArg, eventInit);</code></p><p>参数:</p><p><code>typeArg</code></p><blockquote><p>事件的名称</p></blockquote><p><code>eventInit(可选)</code></p><blockquote><p>字典类型</p><ul><li>“bubbles”，可选，Boolean类型，默认值为 false，表示该事件是否冒泡。</li><li>“cancelable”，可选，Boolean类型，默认值为 false， 表示该事件能否被取消。</li><li>“composed”，可选，Boolean类型，默认值为 false，指示事件是否会在影子DOM根节点之外触发侦听器。</li></ul></blockquote><p>要向事件对象添加更多数据，可以使用 <code>CustomEvent</code> 接口</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> event = <span class="hljs-keyword">new</span> CustomEvent(<span class="hljs-string">'click'</span>, &#123; <span class="hljs-string">'detail'</span>: elem.dataset.time &#125;);<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">eventHandler</span>(<span class="hljs-params">e</span>) </span>&#123;  log(<span class="hljs-string">'The time is: '</span> + e.detail);&#125;</code></pre></div><h3 id="触发内置事件"><a href="#触发内置事件" class="headerlink" title="触发内置事件"></a>触发内置事件</h3><p><code>cancelled = !target.dispatchEvent(event)</code></p><p><code>cancelled</code></p><blockquote><p>当该事件是可取消的(cancelable为true)并且至少一个该事件的 事件处理方法 调用了Event.preventDefault()，则返回值为false；否则返回true。</p></blockquote><h3 id="例"><a href="#例" class="headerlink" title="例"></a>例</h3><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> event = <span class="hljs-keyword">new</span> Event(<span class="hljs-string">'click'</span>);<span class="hljs-comment">// Listen for the event.</span>elem.addEventListener(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123; ... &#125;, <span class="hljs-literal">false</span>);<span class="hljs-comment">// Dispatch the event.</span>elem.dispatchEvent(event);</code></pre></div><h2 id="自定义事件CustomEvent"><a href="#自定义事件CustomEvent" class="headerlink" title="自定义事件CustomEvent()"></a>自定义事件<code>CustomEvent()</code></h2><h2 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Events" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/Events</a></p><h3 id="加载页面相关事件"><a href="#加载页面相关事件" class="headerlink" title="加载页面相关事件"></a>加载页面相关事件</h3><p><code>DOMContentLoaded</code></p><blockquote><p>仅当DOM加载完成，包括defer的<code>script</code>标签执行</p></blockquote><p><code>load</code></p><blockquote><p>页面上所有的DOM，样式表，脚本，图片，flash都已经加载完成，刷新按钮不转了</p></blockquote><h3 id="WebSocket事件"><a href="#WebSocket事件" class="headerlink" title="WebSocket事件"></a>WebSocket事件</h3><table><thead><tr><th>事件名称</th><th>何时触发</th></tr></thead><tbody><tr><td>open</td><td>WebSocket 连接已建立。</td></tr><tr><td>message</td><td>通过 WebSocket 接收到一条消息。</td></tr><tr><td>error</td><td>WebSocket 连接异常被关闭（比如有些数据无法发送）。</td></tr><tr><td>close</td><td>WebSocket 连接已关闭。</td></tr></tbody></table><h3 id="表单事件"><a href="#表单事件" class="headerlink" title="表单事件"></a>表单事件</h3><table><thead><tr><th>事件名称</th><th>何时触发</th></tr></thead><tbody><tr><td>reset</td><td>点击重置按钮时</td></tr><tr><td>submit</td><td>点击提交按钮</td></tr></tbody></table><h3 id="窗口事件"><a href="#窗口事件" class="headerlink" title="窗口事件"></a>窗口事件</h3><table><thead><tr><th>事件名称</th><th>何时触发</th></tr></thead><tbody><tr><td>fullscreenchange</td><td>转换到全屏模式或返回到正常模式</td></tr><tr><td>fullscreenerror</td><td>由于技术原因或权限被拒绝，无法切换到全屏模式。</td></tr><tr><td>resize</td><td>视图已调整大小</td></tr><tr><td>scroll</td><td>视图或元素已被滚动</td></tr></tbody></table><h3 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h3><table><thead><tr><th>事件名称</th><th>何时触发</th></tr></thead><tbody><tr><td>keydown</td><td>按下任意按键。</td></tr><tr><td>keypress</td><td>除 Shift、Fn、CapsLock 外的任意键被按住。（连续触发。）</td></tr><tr><td>keyup</td><td>释放任意按键。</td></tr></tbody></table><h3 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h3><h3 id="拖放事件"><a href="#拖放事件" class="headerlink" title="拖放事件"></a>拖放事件</h3><h3 id="媒体事件"><a href="#媒体事件" class="headerlink" title="媒体事件"></a>媒体事件</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/Events/Media_events" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/Guide/Events/Media_events</a></p><h3 id="存储事件"><a href="#存储事件" class="headerlink" title="存储事件"></a>存储事件</h3>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>事件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js严格模式</title>
    <link href="/2020/07/14/notes/web/js/%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/07/14/notes/web/js/%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>在程序中的最开始增加</p><p><code>&quot;use strict&quot;</code></p><p>如果你在一个文件的顶部加入这个特定的字符串, 则表示该文件的所有内容将始终使用严格模式执行.</p><p>如果你只想在一个函数体内使用严格模式, 则在该函数体内的最开始处(顶部)加入这句指令.</p><h2 id="为什么要使用字符串字面量来实现严格模式"><a href="#为什么要使用字符串字面量来实现严格模式" class="headerlink" title="为什么要使用字符串字面量来实现严格模式?"></a>为什么要使用字符串字面量来实现严格模式?</h2><p>兼容</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ol><li>普通变量<ul><li>变量都必须先声明。</li><li>对不可写属性赋值，将报错。</li><li>对只读属性赋值，将报错。</li><li>对禁止扩展的对象添加新属性，将报错。</li><li>删除一个不可删除的属性，将报错。</li><li>删除声明变量，将报错。</li><li>八进制语法:var n = 023和var s = “\047”将报错</li></ul></li><li>函数不能有重名的参数</li><li>this关键字不再指向全局而是<code>undefined</code></li><li>静态绑定<ul><li>禁止使用with语句</li><li>eval语句本身就是一个作用域，它所生成的变量只能用于eval内部。</li></ul></li><li>arguments对象的限制<ul><li>不允许对arguments赋值</li><li>arguments不再追踪参数的变化<code>[注1]</code></li><li>禁止使用arguments.callee</li></ul></li><li>禁止在函数内部遍历调用栈<code>[注2]</code></li><li>保留字,使用未来保留字作为变量名或函数名会报错。</li></ol><p>注：</p><p>1</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//arguments不再追踪参数的变化</span><span class="hljs-comment">//在非严格模式中,修改arguments对象中某个索引属性的值,和这个属性对应的形参变量的值也会同时变化,反之亦然。</span><span class="hljs-comment">//在严格模式中arguments 对象会以形参变量的拷贝的形式被创建和初始化，因此arguments对象的改变不会影响形参。</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">demo10_1</span>(<span class="hljs-params">a</span>) </span>&#123;    a = <span class="hljs-number">2</span>;    <span class="hljs-keyword">return</span> [a, <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>]];&#125;<span class="hljs-built_in">console</span>.log(demo10_1(<span class="hljs-number">1</span>)); <span class="hljs-comment">// 正常模式为[2,2]</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">demo10_2</span>(<span class="hljs-params">a</span>) </span>&#123;<span class="hljs-meta">    "use strict"</span>    a = <span class="hljs-number">2</span>;    <span class="hljs-keyword">return</span> [a, <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>]];&#125;<span class="hljs-built_in">console</span>.log(demo10_2(<span class="hljs-number">1</span>)); <span class="hljs-comment">// 严格模式为[2,1]</span></code></pre></div><p>2</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">demo12</span>(<span class="hljs-params"></span>)</span>&#123;    demo12.caller; <span class="hljs-comment">// 报错</span>    demo12.arguments; <span class="hljs-comment">// 报错</span>&#125;demo12();</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WebWorker</title>
    <link href="/2020/07/14/notes/web/js/WebWorker/"/>
    <url>/2020/07/14/notes/web/js/WebWorker/</url>
    
    <content type="html"><![CDATA[<p>有以下几个使用注意点:</p><ol><li>同源限制<ul><li>分配给 Worker 线程运行的脚本文件，必须与主线程的脚本文件同源。</li></ul></li><li>DOM 限制<ul><li>Worker 线程所在的全局对象，与主线程不一样，无法读取主线程所在网页的 DOM 对象，也无法使用<code>document</code>、<code>window</code>、<code>parent</code>这些对象。但是，Worker 线程可以<code>navigator</code>对象和<code>location</code>对象。</li></ul></li><li>通信联系<ul><li>Worker 线程和主线程不在同一个上下文环境，它们不能直接通信，必须通过消息完成。</li></ul></li><li>脚本限制<ul><li>Worker 线程不能执行<code>alert()</code>方法和<code>confirm()</code>方法，但可以使用 XMLHttpRequest 对象发出 AJAX 请求。</li></ul></li><li>文件限制<ul><li>Worker 线程无法读取本地文件，即不能打开本机的文件系统（file://），它所加载的脚本，必须来自网络。</li></ul></li><li>传值为拷贝</li></ol><h2 id="1-主线程"><a href="#1-主线程" class="headerlink" title="1 主线程"></a>1 主线程</h2><ul><li>Worker.onerror：指定 error 事件的监听函数。</li><li>Worker.onmessage：指定 message 事件的监听函数，发送过来的数据在Event.data属性中。</li><li>Worker.onmessageerror：指定 messageerror 事件的监听函数。发送的数据无法序列化成字符串时，会触发这个事件。</li><li>Worker.postMessage()：向 Worker 线程发送消息。</li><li>Worker.terminate()：立即终止 Worker 线程。</li></ul><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> worker = <span class="hljs-keyword">new</span> Worker(<span class="hljs-string">'2.js'</span>);worker.postMessage(<span class="hljs-string">"xxx"</span>);worker.onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(event.data);    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;        worker.terminate();    &#125;, <span class="hljs-number">2000</span>)&#125;</code></pre></div><h2 id="2-子线程"><a href="#2-子线程" class="headerlink" title="2 子线程"></a>2 子线程</h2><ul><li>self.name： Worker 的名字。该属性只读，由构造函数指定。</li><li>self.onmessage：指定message事件的监听函数。</li><li>self.onmessageerror：指定 messageerror 事件的监听函数。发送的数据无法序列化成字符串时，会触发这个事件。</li><li>self.close()：关闭 Worker 线程。</li><li>self.postMessage()：向产生这个 Worker 线程发送消息。</li><li>self.importScripts()：加载 JS 脚本。</li></ul><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>===self)    <span class="hljs-comment">// true</span>onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(e.data);    postMessage(<span class="hljs-number">123</span>);&#125;<span class="hljs-comment">// 或</span>addEventListener(<span class="hljs-string">'message'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;  postMessage(e.data);&#125;, <span class="hljs-literal">false</span>);<span class="hljs-comment">// Worker 线程</span><span class="hljs-comment">// self.close();</span></code></pre></div><h3 id="2-1-Worker-内部如果要加载其他脚本，有一个专门的方法importScripts"><a href="#2-1-Worker-内部如果要加载其他脚本，有一个专门的方法importScripts" class="headerlink" title="2.1 Worker 内部如果要加载其他脚本，有一个专门的方法importScripts()"></a>2.1 Worker 内部如果要加载其他脚本，有一个专门的方法importScripts()</h3><p><code>importScripts(&#39;script1.js&#39;, &#39;script2.js&#39;);</code></p>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>valueOf() 与 toString()</title>
    <link href="/2020/07/14/notes/web/js/valueOf()%20%E4%B8%8EtoString()/"/>
    <url>/2020/07/14/notes/web/js/valueOf()%20%E4%B8%8EtoString()/</url>
    
    <content type="html"><![CDATA[<h2 id="计算，比较时"><a href="#计算，比较时" class="headerlink" title="计算，比较时"></a>计算，比较时</h2><p>计算，比较时优先<code>valueOf()</code>，其次<code>toString()</code></p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = &#123;&#125;a.toString = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-number">100</span>a.valueOf = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-number">1</span><span class="hljs-built_in">console</span>.log(a &gt; <span class="hljs-number">5</span>)  <span class="hljs-comment">// true</span><span class="hljs-built_in">console</span>.log(a &lt; <span class="hljs-number">5</span>)  <span class="hljs-comment">// false</span><span class="hljs-built_in">console</span>.log(a == <span class="hljs-number">1</span>) <span class="hljs-comment">// true</span><span class="hljs-built_in">console</span>.log(a === <span class="hljs-number">1</span>)<span class="hljs-comment">// false</span></code></pre></div><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = &#123;&#125;a.toString = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-number">100</span><span class="hljs-comment">// a.valueOf = () =&gt; 1</span><span class="hljs-built_in">console</span>.log(a &gt; <span class="hljs-number">5</span>)      <span class="hljs-comment">// true</span><span class="hljs-built_in">console</span>.log(a &lt; <span class="hljs-number">5</span>)      <span class="hljs-comment">// false</span><span class="hljs-built_in">console</span>.log(a == <span class="hljs-number">100</span>)   <span class="hljs-comment">// true</span><span class="hljs-built_in">console</span>.log(a === <span class="hljs-number">100</span>)  <span class="hljs-comment">// false</span></code></pre></div><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = &#123;&#125;<span class="hljs-comment">// a.toString = () =&gt; 100</span><span class="hljs-comment">// a.valueOf = () =&gt; 1</span><span class="hljs-built_in">console</span>.log(a &gt; <span class="hljs-number">5</span>)  <span class="hljs-comment">// false</span><span class="hljs-built_in">console</span>.log(a &lt; <span class="hljs-number">5</span>)  <span class="hljs-comment">// false</span></code></pre></div><h2 id="数组-对象索引"><a href="#数组-对象索引" class="headerlink" title="数组/对象索引"></a>数组/对象索引</h2><p>只调用<code>toString()</code></p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = &#123;&#125;;a.toString = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-number">0</span>;a.valueOf = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-number">1</span>;<span class="hljs-keyword">let</span> b = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>];<span class="hljs-built_in">console</span>.log(b[<span class="hljs-number">0</span>])   <span class="hljs-comment">// 0</span><span class="hljs-built_in">console</span>.log(b[<span class="hljs-string">"0"</span>]) <span class="hljs-comment">// 0</span><span class="hljs-built_in">console</span>.log(b[a])   <span class="hljs-comment">// 0</span></code></pre></div><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = &#123;&#125;;<span class="hljs-comment">// a.toString = () =&gt; 0;</span>a.valueOf = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-number">1</span>;<span class="hljs-keyword">let</span> b = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>];<span class="hljs-built_in">console</span>.log(b[<span class="hljs-number">0</span>])   <span class="hljs-comment">// 0</span><span class="hljs-built_in">console</span>.log(b[<span class="hljs-string">"0"</span>]) <span class="hljs-comment">// 0</span><span class="hljs-built_in">console</span>.log(b[a])   <span class="hljs-comment">// undefined</span></code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Proxy</title>
    <link href="/2020/07/14/notes/web/js/Proxy/"/>
    <url>/2020/07/14/notes/web/js/Proxy/</url>
    
    <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy</a></p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p><code>const p = new Proxy(target, handler)</code></p><p>target</p><blockquote><p>包装的目标对象（可以是<strong>任何类型的对象</strong>，包括<strong>原生数组</strong>，<strong>函数</strong>，甚至<strong>另一个代理</strong>）。</p></blockquote><p>handler</p><blockquote><p>包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。</p></blockquote><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p><code>Proxy.revocable()</code></p><blockquote><p>创建一个可撤销的Proxy对象。</p></blockquote><h3 id="handler-对象的方法"><a href="#handler-对象的方法" class="headerlink" title="handler 对象的方法"></a>handler 对象的方法</h3><h4 id="get"><a href="#get" class="headerlink" title="get()"></a><code>get()</code></h4><p>用于拦截对象的读取属性操作。</p><p><code>get: function(target, key, receiver)</code></p><p>target</p><blockquote><p>目标对象。</p></blockquote><p>key</p><blockquote><p>被获取的属性名。</p></blockquote><p>receiver</p><blockquote><p>Proxy或者继承Proxy的对象</p></blockquote><h4 id="set"><a href="#set" class="headerlink" title="set()"></a><code>set()</code></h4><p>用于拦截设置属性值的操作</p><p><code>set: function(target, key, value, receiver)</code></p><p>target</p><blockquote><p>目标对象。</p></blockquote><p>key</p><blockquote><p>将被设置的属性名或 Symbol。</p></blockquote><p>value</p><blockquote><p>新属性值。</p></blockquote><p>receiver</p><blockquote><p>最初被调用的对象。通常是 proxy 本身，但 handler 的 set 方法也有可能在原型链上，或以其他方式被间接地调用（因此不一定是 proxy 本身）。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Promise详解</title>
    <link href="/2020/07/14/notes/web/js/Promise%E8%AF%A6%E8%A7%A3/"/>
    <url>/2020/07/14/notes/web/js/Promise%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> promise1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;        resolve(<span class="hljs-string">'foo'</span>);    &#125;, <span class="hljs-number">300</span>);&#125;);promise1.then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(res); <span class="hljs-comment">// "foo"</span>&#125;);</code></pre></div><h2 id="什么是-Promise"><a href="#什么是-Promise" class="headerlink" title="什么是 Promise"></a>什么是 Promise</h2><p>Promise 是异步编程的一种解决方案</p><h2 id="解决的痛点"><a href="#解决的痛点" class="headerlink" title="解决的痛点"></a>解决的痛点</h2><p>回调地狱:</p><ul><li>代码臃肿。</li><li>可读性差。</li><li>耦合度过高，可维护性差。</li><li>代码复用性差。</li><li>容易滋生 bug。</li><li>只能在回调里处理异常。</li></ul><h2 id="Promise有以下几种状态"><a href="#Promise有以下几种状态" class="headerlink" title="Promise有以下几种状态"></a>Promise有以下几种状态</h2><ul><li>pending: 初始状态，既不是成功，也不是失败状态。</li><li>resolved: 意味着操作成功完成。</li><li>rejected: 意味着操作失败。</li></ul><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p><code>new Promise( function(resolve, reject) {...} );</code></p><p><code>Promise.prototype.then(onFulfilled, onRejected)</code></p><blockquote><p>类似catch</p></blockquote><p><code>Promise.prototype.catch(onRejected)</code></p><blockquote><p>返回一个新的promise。<strong>当这个回调函数被调用，新 promise 将以它的返回值来resolve</strong>，<strong>否则以当前promise的完成结果作为新promise的完成结果</strong>.</p></blockquote><p><code>Promise.prototype.finally(onFinally)</code></p><p><code>Promise.resolve(value)</code></p><blockquote><p>返回一个状态由给定value决定的Promise对象。如果该值是thenable(即，带有then方法的对象)，<strong>返回的Promise对象的初始状态为pending，最终状态由then方法执行决定</strong>；否则的话(该value为空，基本类型或者不带then方法的对象),返回的Promise对象状态为<strong>fulfilled</strong>，并且将该value传递给对应的then方法。</p></blockquote><p><code>Promise.reject(value)</code></p><blockquote><p>返回一个状态为失败的Promise对象，并将给定的失败信息传递给对应的处理方法</p></blockquote><p><code>Promise.race(iterable)</code></p><blockquote><p>当iterable参数里的任意一个子promise被成功或失败后，父promise马上也会用子promise的成功返回值或失败详情作为参数调用父promise绑定的相应句柄，并返回该promise对象。</p></blockquote><p><code>Promise.all(iterable)</code></p><blockquote><p>所有的promise对象都成功的时候才会触发成功，一旦有任何一个iterable里面的promise对象失败则立即触发该promise对象的失败。</p></blockquote><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><ol><li><code>Promise</code>内<code>resolve</code>或<code>reject</code>后错误将静默执行，且之后内容不再执行</li><li><code>Promise</code>内<code>resolve</code>或<code>reject</code>之前发生错误，<code>Promise.prototype.catch(onRejected)</code>的<code>onRejected</code>为错误</li><li>在未发生的情况下，<code>new Promise</code>内<code>resolve</code>后的内容也会执行</li></ol><h2 id="unhandledrejection"><a href="#unhandledrejection" class="headerlink" title="unhandledrejection"></a>unhandledrejection</h2><p>当<code>Promise</code> 被 <code>reject</code> 且没有 <code>reject</code> 处理器的时候，会触发 <code>unhandledrejection</code> 事件</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">"unhandledrejection"</span>, event =&gt; &#123;  <span class="hljs-built_in">console</span>.warn(<span class="hljs-string">`UNHANDLED PROMISE REJECTION: <span class="hljs-subst">$&#123;event.reason&#125;</span>`</span>);&#125;);</code></pre></div><h2 id="手写-未完"><a href="#手写-未完" class="headerlink" title="手写(未完)"></a>手写(未完)</h2><div class="hljs"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Promise</span> </span>&#123;    <span class="hljs-keyword">constructor</span>(executor) &#123;        <span class="hljs-comment">//控制状态，使用了一次之后，接下来的都不被使用</span>        <span class="hljs-keyword">this</span>.status = <span class="hljs-string">'pending'</span>        <span class="hljs-keyword">this</span>.value = <span class="hljs-literal">undefined</span>        <span class="hljs-keyword">this</span>.reason = <span class="hljs-literal">undefined</span>        <span class="hljs-comment">//定义resolve函数</span>        <span class="hljs-keyword">let</span> resolve = <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;            <span class="hljs-comment">//这里pendding，主要是为了防止executor中调用了两次resovle或reject方法，而我们只调用一次</span>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === <span class="hljs-string">'pending'</span>) &#123;                <span class="hljs-keyword">this</span>.status = <span class="hljs-string">'resolve'</span>                <span class="hljs-keyword">this</span>.value = data            &#125;        &#125;        <span class="hljs-comment">//定义reject函数</span>        <span class="hljs-keyword">let</span> reject = <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === <span class="hljs-string">'pending'</span>) &#123;                <span class="hljs-keyword">this</span>.status = <span class="hljs-string">'reject'</span>                <span class="hljs-keyword">this</span>.reason = data            &#125;        &#125;        <span class="hljs-comment">//executor方法可能会抛出异常，需要捕获</span>        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//将resolve和reject函数给使用者</span>            executor(resolve, reject)        &#125; <span class="hljs-keyword">catch</span> (e) &#123;            <span class="hljs-comment">//如果在函数中抛出异常则将它注入reject中</span>            reject(e)        &#125;    &#125;&#125;</code></pre></div><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.im/post/5b31a4b7f265da595725f322" target="_blank" rel="noopener">https://juejin.im/post/5b31a4b7f265da595725f322</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise</a><br><a href="https://juejin.im/post/5b32f552f265da59991155f0#heading-3" target="_blank" rel="noopener">https://juejin.im/post/5b32f552f265da59991155f0#heading-3</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>模拟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>parseInt和parseFloat</title>
    <link href="/2020/07/14/notes/web/js/parseInt%E5%92%8CparseFloat/"/>
    <url>/2020/07/14/notes/web/js/parseInt%E5%92%8CparseFloat/</url>
    
    <content type="html"><![CDATA[<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p><code>parseInt(string, radix)</code></p><p><code>radix</code>可选，指定<code>string</code>进制，省略该参数或其值为 0，则为 10，该值介于 2 ~ 36 之间</p><p><code>parseFloat(string)</code></p><p>如果在解析过程中遇到了正负号（+ 或 -）、数字 (0-9)、小数点，或者科学记数法中的指数（e 或 E）<strong>以外</strong>的字符，则它<strong>会忽略</strong>该字符以及之后的所有字符，返回当前已经解析到的浮点数。同时参数字符串首位的空白符会被忽略。</p><p><code>isNaN</code> 函数来判断 <code>parseInt</code>或<code>parseFloat</code> 的返回结果是否是 <code>NaN</code></p>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Object.defineProperty()</title>
    <link href="/2020/07/14/notes/web/js/Object.defineProperty()/"/>
    <url>/2020/07/14/notes/web/js/Object.defineProperty()/</url>
    
    <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty</a></p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p><code>Object.defineProperty(obj, prop, descriptor)</code></p><p><code>obj</code></p><blockquote><p>要定义属性的对象。</p></blockquote><p><code>prop</code></p><blockquote><p>要定义或修改的属性的名称或 Symbol</p></blockquote><p><code>descriptor</code></p><blockquote><p>要定义或修改的属性描述符。</p></blockquote><h3 id="descriptor"><a href="#descriptor" class="headerlink" title="descriptor"></a>descriptor</h3><p><code>value</code></p><blockquote><p>默认为 undefined。该属性对应的值。</p></blockquote><p><code>get</code></p><blockquote><p>默认为 undefined。function(){return temp;}</p></blockquote><p><code>set</code></p><blockquote><p>默认为 undefined。function(value){}</p></blockquote><p><code>configurable</code></p><blockquote><p>默认为 false。表示对象的属性是否可以被删除，以及除 value 和 writable 特性外的其他特性是否可以被修改。</p></blockquote><p><code>enumerable</code></p><blockquote><p>默认为 false。该属性是否是枚举属性</p></blockquote><p><code>writable</code></p><blockquote><p>默认为 false。是否能被重新赋值</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Object.create()、new Object()和{}的区别</title>
    <link href="/2020/07/14/notes/web/js/Object.create()%E3%80%81new%20Object()%E5%92%8C%7B%7D%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2020/07/14/notes/web/js/Object.create()%E3%80%81new%20Object()%E5%92%8C%7B%7D%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a><code>Object.create()</code></h2><p><code>Object.create()</code>方法创建一个新对象，使用现有的对象来提供新创建的对象的<code>__proto__</code>。</p><p>Object.create(proto[, propertiesObject])</p><p>proto</p><p>新创建对象的原型对象。</p><p>propertiesObject</p><p>可选。如果没有指定为 undefined，则是要添加到新创建对象的不可枚举（默认）属性（即其自身定义的属性，而不是其原型链上的枚举属性）对象的属性描述符以及相应的属性名称。这些属性对应Object.defineProperties()的第二个参数。</p><h2 id="new-Object"><a href="#new-Object" class="headerlink" title="new Object(),{}"></a>new Object(),{}</h2><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>().__proto__===&#123;&#125;.__proto__   <span class="hljs-comment">// true</span><span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>(&#123;&#125;).__proto__===&#123;&#125;.__proto__ <span class="hljs-comment">// true</span><span class="hljs-keyword">var</span> a=&#123;<span class="hljs-number">1</span>:<span class="hljs-number">1</span>&#125;;<span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>(a)===a   <span class="hljs-comment">// true</span></code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>new原理及模拟实现</title>
    <link href="/2020/07/14/notes/web/js/new%E5%8E%9F%E7%90%86%E5%8F%8A%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/"/>
    <url>/2020/07/14/notes/web/js/new%E5%8E%9F%E7%90%86%E5%8F%8A%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p>当代码 <code>new Foo(...)</code> 执行时，会发生以下事情：</p><p>一个继承自 <code>Foo.prototype</code> 的新对象被创建。<br>使用指定的参数调用构造函数 <code>Foo</code> ，并将 <code>this</code> 绑定到新创建的对象。<code>new Foo</code> 等同于 <code>new Foo()``，也就是没有指定参数列表，Foo</code> 不带任何参数调用的情况。<br>由构造函数返回的对象就是 <code>new</code> 表达式的结果。如果构造函数没有显式返回一个对象，则使用步骤1创建的对象。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">create</span>(<span class="hljs-params">Con,...args</span>) </span>&#123;    <span class="hljs-comment">// 1、创建一个空的对象</span>    <span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>(),    <span class="hljs-comment">// 2、Con构造函数</span>    <span class="hljs-comment">// 3、链接到原型，obj 可以访问构造函数原型中的属性</span>    <span class="hljs-built_in">Object</span>.setPrototypeOf(obj, Con.prototype);    <span class="hljs-comment">// 4、绑定 this 实现继承，obj 可以访问到构造函数中的属性</span>    <span class="hljs-keyword">var</span> ret = Con.apply(obj, args);    <span class="hljs-comment">// 5、优先返回构造函数返回的对象</span>    <span class="hljs-keyword">return</span> ret <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span> ? ret : obj;&#125;;</code></pre></div><h2 id="优化实现"><a href="#优化实现" class="headerlink" title="优化实现"></a>优化实现</h2><p>不建议使用 <code>__proto__</code></p><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">create</span>(<span class="hljs-params">Con,...args</span>) </span>&#123;    <span class="hljs-comment">// 1、Con构造函数</span>    <span class="hljs-comment">// 2、创建一个空的对象并链接到原型，obj 可以访问构造函数原型中的属性</span>    <span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">Object</span>.create(Con.prototype);    <span class="hljs-comment">// 3、绑定 this 实现继承，obj 可以访问到构造函数中的属性</span>    <span class="hljs-keyword">var</span> ret = Con.apply(obj, args);    <span class="hljs-comment">// 4、优先返回构造函数返回的对象</span>    <span class="hljs-keyword">return</span> ret <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span> ? ret : obj;&#125;;</code></pre></div><p><code>Object.create(proto, [propertiesObject])</code></p><ul><li><code>proto</code> : 必须。<strong>表示新建对象的原型对象</strong>，即该参数会被赋值到目标对象(即新对象，或说是最后返回的对象)的原型上。该参数可以是<code>null</code>， 对象， 函数的<code>prototype</code>属性 （创建空的对象时需传<code>null</code> , 否则会抛出<code>TypeError</code>异常）。</li><li><code>propertiesObject</code> : 可选。 添加到新创建对象的可枚举属性（即其自身的属性，而不是原型链上的枚举属性）对象的属性描述符以及相应的属性名称。这些属性对应<code>Object.defineProperties()</code>的第二个参数。</li></ul><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>箭头函数不能被<code>new</code>，因为其没有原型链，因此没有<code>prototype.constructor</code></p>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>模拟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js数组底层实现</title>
    <link href="/2020/07/14/notes/web/js/js%E6%95%B0%E7%BB%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/"/>
    <url>/2020/07/14/notes/web/js/js%E6%95%B0%E7%BB%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="维基百科"><a href="#维基百科" class="headerlink" title="维基百科"></a>维基百科</h2><p>在计算机科学中，数组数据结构（英语：array data structure），简称数组（英语：Array），是由<strong>相同类型的元素</strong>（element）的集合所组成的数据结构，<strong>分配一块连续的内存</strong>来存储。利用元素的索引（index）可以计算出该元素对应的存储地址。</p><p>特点：</p><ul><li>相同类型</li><li>连续内存(即固定长度)</li></ul><h2 id="V8源码"><a href="#V8源码" class="headerlink" title="V8源码"></a>V8源码</h2><p>js-array.h: <a href="https://github.com/v8/v8/blob/master/src/objects/js-array.h" target="_blank" rel="noopener">https://github.com/v8/v8/blob/master/src/objects/js-array.h</a></p><div class="hljs"><pre><code class="hljs c++"><span class="hljs-comment">// The JSArray describes JavaScript Arrays</span><span class="hljs-comment">//  Such an array can be in one of two modes:</span><span class="hljs-comment">//    - fast, backing storage is a FixedArray and length &lt;= elements.length();</span><span class="hljs-comment">//       Please note: push and pop can be used to grow and shrink the array.</span><span class="hljs-comment">//    - slow, backing storage is a HashTable with numbers as keys.</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JSArray</span> :</span> <span class="hljs-keyword">public</span> JSObject</code></pre></div><p><code>JSArray</code>继承自<code>JSObject</code>，因此本质是对象，所以可以存放任意类型</p><p>注释翻译：</p><p>JSArray描述JavaScript数组。</p><p>这样的数组(array)可以是两种模式之一：</p><ul><li>fast, <code>backing storage</code>是一个<code>FixedArray</code>, 并且<code>length &lt;= elements.length()</code>, <code>push</code>和<code>pop</code>可以增大和减小这个<code>array</code></li><li>slow, <code>backing storage</code>是用数字当作<code>keys</code>的<code>HashTable</code></li></ul><p><code>FixedArray</code> 是 V8 实现的一个类似于数组的类，它表示一段固定长度的连续的内存。</p><p><code>HashTable</code>(散列表)</p><h3 id="fast"><a href="#fast" class="headerlink" title="fast"></a>fast</h3><p>快数组是一种线性的存储方式。新创建的空数组，默认的存储方式是快数组，快数组长度是可变的，可以根据元素的增加和删除来动态调整存储空间大小，内部是通过扩容和收缩机制实现</p><h4 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h4><p>扩容后的新容量 = 旧容量的1.5倍 + 16</p><p>扩容后会将数组拷贝到新的内存空间中</p><h4 id="收缩"><a href="#收缩" class="headerlink" title="收缩"></a>收缩</h4><p>如果容量 &gt;= length的2倍 + 16，则进行收缩容量调整，否则用holes对象填充未被初始化的位置</p><h3 id="slow"><a href="#slow" class="headerlink" title="slow"></a>slow</h3><p>慢数组是一种哈希表的内存形式。不用开辟大块连续的存储空间，节省了内存，但是由于需要维护这样一个 HashTable，其效率会比快数组低。</p><h3 id="快数组慢数组之间的转换"><a href="#快数组慢数组之间的转换" class="headerlink" title="快数组慢数组之间的转换"></a>快数组慢数组之间的转换</h3><h4 id="快-gt-慢"><a href="#快-gt-慢" class="headerlink" title="快 -&gt; 慢"></a>快 -&gt; 慢</h4><ul><li>新容量 <code>&gt;= 3 *</code> 扩容后的容量 <code>* 2</code> ，会转变为慢数组。</li><li>当加入的 <code>index- 当前capacity &gt;= kMaxGap（1024）</code> 时（也就是至少有了 1024 个空洞），会转变为慢数组。</li></ul><p>对数组赋值时使用远超当前数组的容量,出现了大于等于 1024 个空洞</p><h4 id="慢-gt-快"><a href="#慢-gt-快" class="headerlink" title="慢 -&gt; 快"></a>慢 -&gt; 快</h4><p>处于哈希表实现的数组，在每次空间增长时， V8 的启发式算法会检查其空间占用量， 若其空洞元素减少到一定程度，则会将其转化为快数组模式。</p><p>关键代码： 当慢数组的元素可存放在快数组中且长度在 smi 之间且仅节省了50%的空间,则会转变为快数组</p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// fase</span><span class="hljs-keyword">let</span> a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>];<span class="hljs-comment">// slow</span>a[<span class="hljs-number">1030</span>] = <span class="hljs-number">1</span>;<span class="hljs-comment">// fast</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">200</span>; i &lt; <span class="hljs-number">1030</span>; i++) &#123;    a[i] = i;&#125;</code></pre></div><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.im/post/5d80919b51882538036fc87d" target="_blank" rel="noopener">https://juejin.im/post/5d80919b51882538036fc87d</a></p><p><a href="https://github.com/v8/v8" target="_blank" rel="noopener">https://github.com/v8/v8</a></p><p><a href="https://github.com/v8/v8/blob/master/src/objects/js-array.h" target="_blank" rel="noopener">https://github.com/v8/v8/blob/master/src/objects/js-array.h</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>instanceof 原理及实现</title>
    <link href="/2020/07/14/notes/web/js/instanceof%20%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <url>/2020/07/14/notes/web/js/instanceof%20%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p><code>instanceof</code> 运算符用来检测 <code>constructor.prototype</code> 是否存在于参数 <code>object</code> 的原型链上。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">C</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">D</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<span class="hljs-keyword">var</span> o = <span class="hljs-keyword">new</span> C();o <span class="hljs-keyword">instanceof</span> C; <span class="hljs-comment">// true，因为 Object.getPrototypeOf(o) === C.prototype</span>o <span class="hljs-keyword">instanceof</span> D; <span class="hljs-comment">// false，因为 D.prototype 不在 o 的原型链上</span></code></pre></div><p><code>instanceof</code> 原理就是一层一层查找 <code>__proto__</code>，如果和 <code>constructor.prototype</code> 相等则返回 <code>true</code>，如果一直没有查找成功则返回 <code>false</code>。</p><h2 id="模拟实现"><a href="#模拟实现" class="headerlink" title="模拟实现"></a>模拟实现</h2><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">instance_of</span>(<span class="hljs-params">L, R</span>) </span>&#123;<span class="hljs-comment">//L 表示左表达式，R 表示右表达式</span>   <span class="hljs-keyword">var</span> O = R.prototype;<span class="hljs-comment">// 取 R 的显示原型</span>   L = <span class="hljs-built_in">Object</span>.getPrototypeOf(L);<span class="hljs-comment">// 取 L 的隐式原型</span>   <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;       <span class="hljs-comment">// Object.prototype.__proto__ === null</span>       <span class="hljs-keyword">if</span> (L === <span class="hljs-literal">null</span>)         <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;       <span class="hljs-keyword">if</span> (O === L)<span class="hljs-comment">// 这里重点：当 O 严格等于 L 时，返回 true</span>         <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;       L = <span class="hljs-built_in">Object</span>.getPrototypeOf(L);   &#125;&#125;<span class="hljs-comment">// 测试</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">C</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">D</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<span class="hljs-keyword">var</span> o = <span class="hljs-keyword">new</span> C();instance_of(o, C); <span class="hljs-comment">// true</span>instance_of(o, D); <span class="hljs-comment">// false</span></code></pre></div><h2 id="isPrototypeOf和instanceof区别"><a href="#isPrototypeOf和instanceof区别" class="headerlink" title="isPrototypeOf和instanceof区别"></a>isPrototypeOf和instanceof区别</h2><ul><li>A.isPrototypeOf(B) 判断的是A对象是否存在于B对象的原型链之中</li><li>A instanceof B  判断的是B.prototype是否存在与A的原型链之中</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>模拟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>globalThis对象</title>
    <link href="/2020/07/14/notes/web/js/globalThis/"/>
    <url>/2020/07/14/notes/web/js/globalThis/</url>
    
    <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/globalThis" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/globalThis</a></p><p>不同环境中，获取全局对象需要不同的语句：</p><ul><li>浏览器：<code>window</code>、<code>self</code> 或者 <code>frames</code></li><li>Web Worker：<code>self</code></li><li>nodejs：<code>global</code></li></ul><p>在松散模式下，可以在函数中返回 <code>this</code> 来获取全局对象，但是在严格模式和模块环境下，<code>this</code> 会返回 <code>undefined</code>。</p><p>并且这种方法在某些情况下会违反 CSP 规则</p><p><code>globalThis</code> 提供了一个标准的方式来获取不同环境下的全局 <code>this</code>  对象（也就是全局对象自身）。</p><h2 id="es6-shim中的方式"><a href="#es6-shim中的方式" class="headerlink" title="es6-shim中的方式"></a>es6-shim中的方式</h2><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> getGlobal = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;     <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> self !== <span class="hljs-string">'undefined'</span>) &#123; <span class="hljs-keyword">return</span> self; &#125;     <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">window</span> !== <span class="hljs-string">'undefined'</span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">window</span>; &#125;     <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> global !== <span class="hljs-string">'undefined'</span>) &#123; <span class="hljs-keyword">return</span> global; &#125;     <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'unable to locate global object'</span>); &#125;; <span class="hljs-keyword">var</span> globals = getGlobal();</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>generator（生成器）</title>
    <link href="/2020/07/14/notes/web/js/generator/"/>
    <url>/2020/07/14/notes/web/js/generator/</url>
    
    <content type="html"><![CDATA[<p><code>generator</code>（生成器）是ES6标准引入的新的数据类型。一个<code>generator</code>看上去像一个函数，但可以返回多次。</p><p>函数在执行过程中，如果没有遇到<code>return</code>语句（函数末尾如果没有<code>return</code>，就是隐含的<code>return undefined;</code>），控制权无法交回被调用的代码。</p><p>定义如下：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">foo</span>(<span class="hljs-params">x</span>) </span>&#123;    <span class="hljs-keyword">yield</span> x + <span class="hljs-number">1</span>;    <span class="hljs-keyword">yield</span> x + <span class="hljs-number">2</span>;    <span class="hljs-keyword">return</span> x + <span class="hljs-number">3</span>;&#125;</code></pre></div><p>除了<code>return</code>语句，还可以用<code>yield</code>返回多次。</p><p>以下都可以</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> * <span class="hljs-title">foo</span>(<span class="hljs-params">x, y</span>) </span>&#123; ··· &#125;<span class="hljs-function"><span class="hljs-keyword">function</span> *<span class="hljs-title">foo</span>(<span class="hljs-params">x, y</span>) </span>&#123; ··· &#125;<span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">foo</span>(<span class="hljs-params">x, y</span>) </span>&#123; ··· &#125;<span class="hljs-function"><span class="hljs-keyword">function</span>*<span class="hljs-title">foo</span>(<span class="hljs-params">x, y</span>) </span>&#123; ··· &#125;</code></pre></div><p>直接调用一个<code>generator</code>和调用函数不一样，仅仅是创建了一个<code>generator</code>对象，还没有去执行它。</p><ul><li><code>next()</code>方法会执行<code>generator</code>的代码，然后，每次遇到<code>yield x;</code>就返回一个对象<code>{value: x, done: true/false}</code>，然后“暂停”。返回的<code>value</code>就是<code>yield</code>的返回值，<code>done</code>表示这个<code>generator</code>是否已经执行结束了。如果<code>done</code>为<code>true</code>，则<code>value</code>就是<code>return</code>的返回值。</li><li>第二个方法是直接用<code>for ... of</code>循环迭代generator对象，这种方式不需要我们自己判断<code>done</code></li></ul><h2 id="next方法的参数"><a href="#next方法的参数" class="headerlink" title="next方法的参数"></a><code>next</code>方法的参数</h2><p><code>yield</code>表达式本身没有返回值，或者说总是返回<code>undefined</code>。<code>next</code>方法可以带一个参数，该参数就会被当作上一个<code>yield</code>表达式的返回值。Generator 函数从暂停状态到恢复运行，它的上下文状态（context）是不变的。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">demo</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">let</span> a = <span class="hljs-number">0</span>;    <span class="hljs-keyword">let</span> b = <span class="hljs-keyword">yield</span> a; <span class="hljs-comment">// 若不赋值，b === undefined</span>    <span class="hljs-keyword">yield</span> b;&#125;<span class="hljs-keyword">let</span> b = demo();b.next();       <span class="hljs-comment">// &#123;value: 0, done: false&#125;</span>b.next();       <span class="hljs-comment">// &#123;value: undefined, done: false&#125;</span>b.next();       <span class="hljs-comment">// &#123;value: undefined, done: true&#125;</span><span class="hljs-keyword">let</span> d = demo();d.next();       <span class="hljs-comment">// &#123;value: 0, done: false&#125;</span>d.next(<span class="hljs-number">10</span>);     <span class="hljs-comment">// &#123;value: 10, done: false&#125;</span>d.next(<span class="hljs-number">10</span>);     <span class="hljs-comment">// &#123;value: undefined, done: true&#125;</span></code></pre></div><h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><ul><li>可以实现需要用面向对象才能实现的功能。例如，保存状态</li><li>另一个巨大的好处，就是把异步回调代码变成“同步”代码。</li></ul><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><ul><li>调用时，仅仅创建<code>generator</code>，内部先不执行</li><li><code>yield</code>表达式只能用在 <code>Generator</code> 函数里面</li><li><code>for(let item of generator)</code>中，<code>item</code>为<code>value</code>值，不包括<code>return</code>结果</li><li><code>yield</code>总是返回<code>undefined</code></li></ul><h3 id="异步任务封装"><a href="#异步任务封装" class="headerlink" title="异步任务封装"></a>异步任务封装</h3><p>封装</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> fetch = <span class="hljs-built_in">require</span>(<span class="hljs-string">'node-fetch'</span>);<span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">gen</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-keyword">var</span> url = <span class="hljs-string">'https://api.github.com/users/github'</span>;  <span class="hljs-keyword">var</span> result = <span class="hljs-keyword">yield</span> fetch(url);  <span class="hljs-built_in">console</span>.log(result.bio);&#125;</code></pre></div><p>执行</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> g = gen();<span class="hljs-keyword">var</span> result = g.next();result.value.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>&#123;  <span class="hljs-keyword">return</span> data.json();&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>&#123;  g.next(data);&#125;);</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js的一些features</title>
    <link href="/2020/07/14/notes/web/js/features/"/>
    <url>/2020/07/14/notes/web/js/features/</url>
    
    <content type="html"><![CDATA[<h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><div class="hljs"><pre><code class="hljs js">nodes=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">in</span> nodes) &#123;    <span class="hljs-keyword">typeof</span> i === <span class="hljs-string">"string"</span>;    <span class="hljs-comment">// true</span>&#125;</code></pre></div><h3 id="2-变量提升"><a href="#2-变量提升" class="headerlink" title="2 变量提升"></a>2 变量提升</h3><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(a);<span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;</code></pre></div><p>相当于</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a;<span class="hljs-built_in">console</span>.log(a);a = <span class="hljs-number">2</span>;</code></pre></div><p>都输出<code>undefined</code></p><p>函数声明与其他声明一起出现的时候，函数声明高于一切，毕竟<strong>函数是js的第一公民</strong>,有多个函数声明的时候，是由<strong>最后面的函数声明来替代前面的</strong>。</p><h3 id="3-右移（左移同理）"><a href="#3-右移（左移同理）" class="headerlink" title="3 右移（左移同理）"></a>3 右移（左移同理）</h3><p>无符号位移（&gt;&gt;&gt;）和有符号位移（&gt;&gt;）的区别是</p><p>有符号位移运算时如果数字为正数时位移后在前面补0，为负数时则在位移后在前面补1</p><h3 id="4-alert"><a href="#4-alert" class="headerlink" title="4 alert()"></a>4 alert()</h3><p>弹出的为字符串</p><p>例：</p><div class="hljs"><pre><code class="hljs js">alert(&#123;&#125;)<span class="hljs-comment">//"[object Object]"</span></code></pre></div><h3 id="5-indexOf"><a href="#5-indexOf" class="headerlink" title="5 indexOf()"></a>5 indexOf()</h3><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-literal">NaN</span>]a.indexOf(<span class="hljs-literal">NaN</span>)  <span class="hljs-comment">// -1</span>a.includes(<span class="hljs-literal">NaN</span>) <span class="hljs-comment">// true</span></code></pre></div><p><code>findIndex()</code>可以传回调,配合JSON.stringify,用于判断对象</p><h2 id="6-一些隐式转换"><a href="#6-一些隐式转换" class="headerlink" title="6 一些隐式转换"></a>6 一些隐式转换</h2><p><a href="https://segmentfault.com/a/1190000004482388" target="_blank" rel="noopener">https://segmentfault.com/a/1190000004482388</a></p><p>遇到算数运算符(<code>-</code> 、<code>*</code> 、<code>/</code> 和 <code>%</code>)的时候会在运算之前将参与运算的双方转换成数字。</p><p><code>+</code></p><div class="hljs"><pre><code class="hljs js"><span class="hljs-number">0</span> / <span class="hljs-number">0</span>       <span class="hljs-comment">// NaN</span><span class="hljs-number">0.1</span> / <span class="hljs-number">0</span>     <span class="hljs-comment">// Infinity</span><span class="hljs-number">-0.1</span> / <span class="hljs-number">0</span>    <span class="hljs-comment">// -Infinity</span><span class="hljs-string">"3"</span> + <span class="hljs-number">2</span>     <span class="hljs-comment">// "32"</span><span class="hljs-string">"3"</span> - <span class="hljs-number">2</span>     <span class="hljs-comment">// 1</span><span class="hljs-string">"3"</span> * <span class="hljs-number">2</span>     <span class="hljs-comment">// 6</span></code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6学习记录</title>
    <link href="/2020/07/14/notes/web/js/ES6/"/>
    <url>/2020/07/14/notes/web/js/ES6/</url>
    
    <content type="html"><![CDATA[<h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><div class="hljs"><pre><code class="hljs js">[[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]].map(<span class="hljs-function">(<span class="hljs-params">[a,b]</span>)=&gt;</span> a+b)&gt;   [<span class="hljs-number">3</span>, <span class="hljs-number">7</span>]</code></pre></div><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">move</span>(<span class="hljs-params">&#123;x=<span class="hljs-number">0</span>,y=<span class="hljs-number">0</span>&#125;=&#123;&#125;</span>) </span>&#123;    <span class="hljs-keyword">return</span> [x,y];&#125;move(&#123;<span class="hljs-attr">x</span>:<span class="hljs-number">3</span>&#125;);&gt;   [<span class="hljs-number">3</span>, <span class="hljs-number">0</span>]</code></pre></div><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">move</span>(<span class="hljs-params">&#123;x=<span class="hljs-number">0</span>,y=<span class="hljs-number">0</span>&#125;</span>) </span>&#123;    <span class="hljs-keyword">return</span> [x,y];&#125;move(&#123;<span class="hljs-attr">x</span>:<span class="hljs-number">3</span>&#125;);&gt;   [<span class="hljs-number">3</span>, <span class="hljs-number">0</span>]move(<span class="hljs-number">3</span>,<span class="hljs-number">7</span>);&gt;   [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>]</code></pre></div><p>注意：<strong>尽量不要在解构模式中用()</strong></p><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>交换变量值</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">let</span> x=<span class="hljs-number">1</span>;<span class="hljs-keyword">let</span> y=<span class="hljs-number">2</span>;[x,y]=[y,x];</code></pre></div><p>函数返回数组或字典</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];&#125;<span class="hljs-keyword">let</span> [a,b,c]=foo();</code></pre></div><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> &#123;        a:<span class="hljs-number">1</span>,        b:<span class="hljs-number">2</span>    &#125;;&#125;<span class="hljs-comment">// key要相同,顺序随意</span><span class="hljs-keyword">let</span> &#123;a,b&#125;=foo();</code></pre></div><p>函数参数</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">[x,y,z]</span>) </span>&#123;    <span class="hljs-keyword">return</span>;&#125;foo([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]);</code></pre></div><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h3><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// true</span><span class="hljs-string">'\z'</span>===<span class="hljs-string">'z'</span><span class="hljs-string">'\172'</span>===<span class="hljs-string">'z'</span><span class="hljs-string">'\x7A'</span>===<span class="hljs-string">'z'</span><span class="hljs-string">'\u007a'</span>===<span class="hljs-string">'z'</span><span class="hljs-string">'\&#123;7A&#125;'</span>===<span class="hljs-string">'z'</span></code></pre></div><h3 id="for-…-of"><a href="#for-…-of" class="headerlink" title="for … of"></a>for … of</h3><h3 id="包含"><a href="#包含" class="headerlink" title="包含"></a>包含</h3><p>es5只有<code>indexOf</code><br>es6有</p><p>. includes():bool,是否包含<br>. startsWith():bool,是否在头部<br>. endsWith():bool,是否在尾部</p><h3 id="repeat"><a href="#repeat" class="headerlink" title="repeat()"></a>repeat()</h3><div class="hljs"><pre><code class="hljs js"><span class="hljs-string">'xa'</span>.repeat(<span class="hljs-number">3</span>)&gt; <span class="hljs-string">"xaxaxa"</span></code></pre></div><div class="hljs"><pre><code class="hljs js"><span class="hljs-string">'xa'</span>.repeat(<span class="hljs-number">2.9</span>)&gt; <span class="hljs-string">"xaxa"</span></code></pre></div><div class="hljs"><pre><code class="hljs js"><span class="hljs-string">'xa'</span>.repeat(<span class="hljs-number">.0</span><span class="hljs-number">.5</span>)   <span class="hljs-comment">//0到.1</span>&gt; <span class="hljs-string">""</span></code></pre></div><h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h3><p>用反引号<code>`</code>标识，可定义多行字符串，或嵌入变量。<code>${}</code>中可以放入任意js表达式。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-string">`asdasd</span><span class="hljs-string">asdasd`</span><span class="hljs-keyword">let</span> a=<span class="hljs-string">"asd"</span>;<span class="hljs-string">`hello <span class="hljs-subst">$&#123;a&#125;</span>`</span>&gt; <span class="hljs-string">"hello asd"</span></code></pre></div><h3 id="标签模板"><a href="#标签模板" class="headerlink" title="标签模板"></a>标签模板</h3><p>模版字符串紧跟在函数名后，该函数将被调用处理该模板字符串。</p><div class="hljs"><pre><code class="hljs js">alert<span class="hljs-string">`123`</span><span class="hljs-comment">// 等同于</span>alert(<span class="hljs-number">123</span>)</code></pre></div><p>如果模板字符串中有变量则：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a=<span class="hljs-number">5</span>;<span class="hljs-keyword">var</span> b=<span class="hljs-number">10</span>;tag<span class="hljs-string">`hello <span class="hljs-subst">$&#123;a&#125;</span> world <span class="hljs-subst">$&#123;b&#125;</span>`</span>;<span class="hljs-comment">// 等同于</span>tag([<span class="hljs-string">'hello '</span>,<span class="hljs-string">' world '</span>],<span class="hljs-number">5</span>,<span class="hljs-number">10</span>);</code></pre></div><h2 id="5-正则的扩展"><a href="#5-正则的扩展" class="headerlink" title="5 正则的扩展"></a>5 正则的扩展</h2><h2 id="6-数值的扩展"><a href="#6-数值的扩展" class="headerlink" title="6 数值的扩展"></a>6 数值的扩展</h2><h3 id="Number-isFinite-Number-isNaN"><a href="#Number-isFinite-Number-isNaN" class="headerlink" title="Number.isFinite(),Number.isNaN()"></a>Number.isFinite(),Number.isNaN()</h3><h3 id="Number-EPSILON"><a href="#Number-EPSILON" class="headerlink" title="Number.EPSILON"></a>Number.EPSILON</h3><p>新增的极小量</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 2.220446049250313e.16</span></code></pre></div><h3 id="安全整数和Number-isSafeInteger"><a href="#安全整数和Number-isSafeInteger" class="headerlink" title="安全整数和Number.isSafeInteger()"></a>安全整数和Number.isSafeInteger()</h3><p>js能准确表示的整数范围是$.2^{53}$到$2^{53}$之间，不含左右端点。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">2</span>,<span class="hljs-number">53</span>)===<span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">2.53</span>)+<span class="hljs-number">1</span><span class="hljs-comment">// true</span></code></pre></div><h3 id=""><a href="#" class="headerlink" title="**"></a>**</h3><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a=<span class="hljs-number">3</span>;a**=<span class="hljs-number">2</span>;<span class="hljs-comment">// a=a*a;</span>a**=<span class="hljs-number">3</span><span class="hljs-comment">// a=a*a*a</span></code></pre></div><h3 id="Integer"><a href="#Integer" class="headerlink" title="Integer"></a>Integer</h3><h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><p>js所有的数字都保存为64位浮点，精度不够，不适合</p><p>为了与Number区分，Integer类型后要加上后缀n。</p><h2 id="7-函数的扩展"><a href="#7-函数的扩展" class="headerlink" title="7 函数的扩展"></a>7 函数的扩展</h2><h3 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h3><p>ES6才能给函数参数指定默认值。</p><h3 id="解构赋值结合默认值"><a href="#解构赋值结合默认值" class="headerlink" title="解构赋值结合默认值"></a>解构赋值结合默认值</h3><h3 id="参数默认值的位置"><a href="#参数默认值的位置" class="headerlink" title="参数默认值的位置"></a>参数默认值的位置</h3><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">x,y=<span class="hljs-number">5</span>,z</span>) </span>&#123;    <span class="hljs-keyword">return</span>[x,y,z];&#125;f() <span class="hljs-comment">//[undefined,5,undefined]</span><span class="hljs-comment">// 必须显式的输入undefined,null不行</span>f(<span class="hljs-number">1</span>, ,<span class="hljs-number">2</span>)    <span class="hljs-comment">//报错</span>f(<span class="hljs-number">1</span>,<span class="hljs-literal">undefined</span>,<span class="hljs-number">2</span>)    <span class="hljs-comment">//[1,5,2]</span></code></pre></div><h3 id="函数的length"><a href="#函数的length" class="headerlink" title="函数的length"></a>函数的length</h3><p>指定默认值后，length将失效</p><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> x=<span class="hljs-number">1</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">x,y=function(</span>)</span>&#123;x=<span class="hljs-number">2</span>;&#125;) &#123;    <span class="hljs-keyword">var</span> x=<span class="hljs-number">3</span>;    y();    <span class="hljs-built_in">console</span>.log(x);&#125;foo()   <span class="hljs-comment">//3</span>x       <span class="hljs-comment">//1</span></code></pre></div><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> x=<span class="hljs-number">1</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">x,y=function(</span>)</span>&#123;x=<span class="hljs-number">2</span>;&#125;) &#123;    x=<span class="hljs-number">3</span>;    y();    <span class="hljs-built_in">console</span>.log(x);&#125;foo()   <span class="hljs-comment">//2</span>x       <span class="hljs-comment">//1</span></code></pre></div><h3 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a>rest参数</h3><p>形式为<code>...变量名</code>，如：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">...values</span>) </span>&#123;    <span class="hljs-comment">// pass</span>&#125;</code></pre></div><h3 id="7-4-name属性"><a href="#7-4-name属性" class="headerlink" title="7.4 name属性"></a>7.4 name属性</h3><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;&#125;foo.name    <span class="hljs-comment">// "foo"</span></code></pre></div><p>对于赋值给变量的匿名函数：</p><p>. ES5,<code>f.name</code> 返回 <code>&quot;&quot;</code><br>. ES6,<code>f.name</code> 返回 <code>&quot;f&quot;</code></p><h3 id="7-5箭头函数"><a href="#7-5箭头函数" class="headerlink" title="7.5箭头函数"></a>7.5箭头函数</h3><h4 id="7-5-1-基本用法"><a href="#7-5-1-基本用法" class="headerlink" title="7.5.1 基本用法"></a>7.5.1 基本用法</h4><p><code>var f=v=&gt;v;</code></p><p>等同于：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> f=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">v</span>)</span>&#123;    <span class="hljs-keyword">return</span> v;&#125;</code></pre></div><p>当不需要参数或需要多个参数，用<code>()</code></p><p>若代码块多于一条，用<code>{}</code>，并使用<code>return</code></p><p>若需要箭头返回<code>对象</code>，则需要在对象的<code>{}</code>外边加上<code>()</code></p><p>examples:</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 一般写法</span>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>].map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) </span>&#123;    <span class="hljs-keyword">return</span> x*x;&#125;);<span class="hljs-comment">// 箭头函数</span>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>].map(<span class="hljs-function"><span class="hljs-params">x</span>=&gt;</span>x*x);</code></pre></div><h4 id="7-5-2-注意"><a href="#7-5-2-注意" class="headerlink" title="7.5.2 注意"></a>7.5.2 注意</h4><ol><li><code>this</code>对象为定义时所在的对象，而不是使用时的对象。</li><li>不可当作构造函数。</li><li>不能用<code>arguments</code>，可使用<code>rest</code>参数代替。</li><li>不能用<code>yield</code>。</li></ol><p>其中第一点尤其要注意，箭头函数让指针固化，<strong>非常有利于封装回调函数</strong>。</p><p>箭头函数<code>this</code>的机制原因是因为它没有<code>this</code>，也因此不能当构造函数。</p><p>ES5中实现箭头函数<code>this</code>的机制：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> _this=<span class="hljs-keyword">this</span>;</code></pre></div><h3 id="7-6-绑定this"><a href="#7-6-绑定this" class="headerlink" title="7.6 绑定this"></a>7.6 绑定this</h3><div class="hljs"><pre><code class="hljs js">foo::bar;<span class="hljs-comment">// 等同于</span>bar.bind(foo);...</code></pre></div><h3 id="7-7-尾调用优化"><a href="#7-7-尾调用优化" class="headerlink" title="7.7 尾调用优化"></a>7.7 尾调用优化</h3><h4 id="7-7-1-概念"><a href="#7-7-1-概念" class="headerlink" title="7.7.1 概念"></a>7.7.1 概念</h4><p>尾调用(Tail Call)指某个函数的最后一步调用另一个函数。</p><h4 id="7-7-2-尾调用优化"><a href="#7-7-2-尾调用优化" class="headerlink" title="7.7.2 尾调用优化"></a>7.7.2 尾调用优化</h4><p>尾调用时，调用的函数若不再使用外层函数的变量，则直接删除外层函数，节省内存。</p><p>注意：<strong>只在严格模式下生效</strong>。</p><h4 id="7-7-3-尾递归"><a href="#7-7-3-尾递归" class="headerlink" title="7.7.3 尾递归"></a>7.7.3 尾递归</h4><p>尾递归只存在一个调用帧，不会发生“栈溢出”。</p><p>因此ES6中尾递归不会“栈溢出”。</p><h2 id="8-数组的扩展"><a href="#8-数组的扩展" class="headerlink" title="8 数组的扩展"></a>8 数组的扩展</h2><h3 id="8-1-扩展运算符"><a href="#8-1-扩展运算符" class="headerlink" title="8.1 扩展运算符"></a>8.1 扩展运算符</h3><h4 id="8-1-1-含义"><a href="#8-1-1-含义" class="headerlink" title="8.1.1 含义"></a>8.1.1 含义</h4><p>扩展运算符(spread)是三个点(…)，如同rest的逆运算</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(...[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>])<span class="hljs-comment">// 1 2 3</span><span class="hljs-comment">// 常用</span>a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]b=[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]a.push(...b)<span class="hljs-comment">// 或</span>[...a,...b]<span class="hljs-comment">// [1,2,3,4,5]</span></code></pre></div><h4 id="8-1-2-代替apply"><a href="#8-1-2-代替apply" class="headerlink" title="8.1.2 代替apply"></a>8.1.2 代替apply</h4><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> args=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<span class="hljs-comment">//ES5</span>f.apply(<span class="hljs-literal">null</span>,args);<span class="hljs-comment">//ES6</span>f(...args);</code></pre></div><h4 id="8-1-3-其他应用"><a href="#8-1-3-其他应用" class="headerlink" title="8.1.3 其他应用"></a>8.1.3 其他应用</h4><p>解构赋值</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> [a,...b]=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>];a   <span class="hljs-comment">// 1</span>b   <span class="hljs-comment">// [2,3,4,5]</span></code></pre></div><p>字符串,优点：能正确识别32位Unicode字符。</p><div class="hljs"><pre><code class="hljs js">[...<span class="hljs-string">'hello'</span>]<span class="hljs-comment">// ["h", "e", "l", "l", "o"]</span></code></pre></div><p>Map和Set、Generator</p><p>扩展运算符调用的<code>Iterator</code>接口，只要有<code>Iterator</code>接口的对象都可以，如Map结构：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">let</span> map=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([    [<span class="hljs-number">1</span>,<span class="hljs-string">'a'</span>],    [<span class="hljs-number">2</span>,<span class="hljs-string">'b'</span>],    [<span class="hljs-number">3</span>,<span class="hljs-string">'c'</span>],]);<span class="hljs-keyword">let</span> arr=[...map.keys()];    <span class="hljs-comment">// [1,2,3]</span></code></pre></div><h3 id="8-2-Array-from"><a href="#8-2-Array-from" class="headerlink" title="8.2 Array.from()"></a>8.2 Array.from()</h3><p>将两类对象转化为数组：<strong>类似数组对象</strong>和<strong>iterable对象</strong></p><p>类数组对象，<strong>本质特征是有length属性</strong></p><p>常见应用：把arguments转换成一个真正的数组</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arrayLike=&#123;    <span class="hljs-string">'0'</span>:<span class="hljs-string">'a'</span>,    <span class="hljs-string">'1'</span>:<span class="hljs-string">'b'</span>,    length:<span class="hljs-number">2</span>&#125;;<span class="hljs-comment">//ES5</span><span class="hljs-keyword">var</span> arr1=[].slice.call(arrayLike);<span class="hljs-comment">//ES6</span><span class="hljs-keyword">let</span> arr2=<span class="hljs-built_in">Array</span>.from(arrayLike);<span class="hljs-comment">//['a','b']</span></code></pre></div><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">Array</span>.from(<span class="hljs-string">'hello'</span>)<span class="hljs-comment">//['h','e','l','l','o']</span></code></pre></div><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">Array</span>.from(&#123;<span class="hljs-attr">length</span>:<span class="hljs-number">3</span>&#125;);<span class="hljs-comment">//[undefined,undefined,undefined]</span></code></pre></div><p><code>Array.from</code>可以接受第二参数，类似于<code>map</code></p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">Array</span>.from(arr,x=&gt;x*x);<span class="hljs-comment">//等同于</span><span class="hljs-built_in">Array</span>.from(arr).map(<span class="hljs-function"><span class="hljs-params">x</span>=&gt;</span>x*x);</code></pre></div><p><code>Array.from</code>可以接受第二参数，用于绑定<code>this</code></p><h3 id="8-3-Array-of"><a href="#8-3-Array-of" class="headerlink" title="8.3 Array.of()"></a>8.3 Array.of()</h3><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">Array</span>.of(<span class="hljs-number">3</span>,<span class="hljs-number">11</span>);<span class="hljs-comment">// [3,11]</span></code></pre></div><h3 id="8-4-copyWithin"><a href="#8-4-copyWithin" class="headerlink" title="8.4 copyWithin()"></a>8.4 copyWithin()</h3><h3 id="8-5-find-和findIndex"><a href="#8-5-find-和findIndex" class="headerlink" title="8.5 find()和findIndex()"></a>8.5 find()和findIndex()</h3><p>找到第一个符合条件的</p><p><code>find()</code>的第一参数为回调函数,第二参数绑定<code>this</code></p><div class="hljs"><pre><code class="hljs js">[<span class="hljs-number">.1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>].find(<span class="hljs-function">(<span class="hljs-params">n</span>)=&gt;</span>n&lt;<span class="hljs-number">0</span>)<span class="hljs-comment">// .1</span>[<span class="hljs-number">.1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>].find(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value,index,arr</span>) </span>&#123;    <span class="hljs-keyword">return</span> value&gt;<span class="hljs-number">1</span>;&#125;)<span class="hljs-comment">// 2</span></code></pre></div><p>findIndex()与find()类似，返回位置</p><p>都可以发现<code>NaN</code>,弥补<code>indexOf</code>不足</p><h3 id="8-6-fill"><a href="#8-6-fill" class="headerlink" title="8.6 fill()"></a>8.6 fill()</h3><div class="hljs"><pre><code class="hljs js">[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-string">'a'</span>].fill(<span class="hljs-number">5</span>)<span class="hljs-comment">// [5, 5, 5, 5]</span></code></pre></div><h3 id="8-7-3种遍历数组"><a href="#8-7-3种遍历数组" class="headerlink" title="8.7 3种遍历数组"></a>8.7 3种遍历数组</h3><p>. <code>keys()</code>：遍历键名<br>. <code>values()</code>：遍历键值<br>. <code>entries()</code>：遍历键值对</p><p>都可调用遍历器对象的<code>next()</code></p><h3 id="8-8-includes"><a href="#8-8-includes" class="headerlink" title="8.8 includes()"></a>8.8 includes()</h3><p>第二参数为其实为起始位置，可为负数</p><div class="hljs"><pre><code class="hljs js">[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-literal">NaN</span>].includes(<span class="hljs-literal">NaN</span>)<span class="hljs-comment">// true</span></code></pre></div><h3 id="8-9-数组的空位"><a href="#8-9-数组的空位" class="headerlink" title="8.9 数组的空位"></a>8.9 数组的空位</h3><p>表示没有任何值,ES6的大多数函数会将空位转为<code>undefined</code></p><div class="hljs"><pre><code class="hljs js"><span class="hljs-number">0</span> <span class="hljs-keyword">in</span> [<span class="hljs-literal">undefined</span>,<span class="hljs-literal">undefined</span>]  <span class="hljs-comment">//true</span><span class="hljs-number">0</span> <span class="hljs-keyword">in</span> [,]  <span class="hljs-comment">//false</span></code></pre></div><h2 id="第9章-对象的扩展"><a href="#第9章-对象的扩展" class="headerlink" title="第9章 对象的扩展"></a>第9章 对象的扩展</h2><h3 id="9-1-属性简洁表示"><a href="#9-1-属性简洁表示" class="headerlink" title="9.1 属性简洁表示"></a>9.1 属性简洁表示</h3><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> foo=<span class="hljs-string">'bar'</span>;<span class="hljs-keyword">var</span> baz=&#123;foo&#125;;  <span class="hljs-comment">// 这个</span>baz <span class="hljs-comment">// &#123;foo:"bar"&#125;</span><span class="hljs-comment">// 等同于</span><span class="hljs-keyword">var</span> baz=&#123;<span class="hljs-attr">foo</span>:foo&#125;;</code></pre></div><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">x,y</span>) </span>&#123;    <span class="hljs-keyword">return</span>&#123;x,y&#125;;&#125;f(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)  <span class="hljs-comment">//&#123;x: 1, y: 2&#125;</span></code></pre></div><p>方法也可以简写</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> o=&#123;    f()&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;&#125;<span class="hljs-comment">// 等同于</span><span class="hljs-keyword">var</span> o=&#123;    f:<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;&#125;</code></pre></div><p>如果方法的值是<code>Generator</code>，则在函数前加<code>*</code></p><h3 id="9-2-属性名表达式"><a href="#9-2-属性名表达式" class="headerlink" title="9.2 属性名表达式"></a>9.2 属性名表达式</h3><p><code>[]</code>里为表达式</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a=<span class="hljs-string">'foo'</span>;<span class="hljs-keyword">let</span> d=&#123;    [a]:<span class="hljs-literal">true</span>,    [<span class="hljs-string">'a'</span>+<span class="hljs-string">'bc'</span>]:<span class="hljs-number">123</span>&#125;;<span class="hljs-comment">// &#123;foo: true, abc: 123&#125;</span></code></pre></div><h3 id="9-3-方法的name属性"><a href="#9-3-方法的name属性" class="headerlink" title="9.3 方法的name属性"></a>9.3 方法的name属性</h3><p>返回函数名</p><h3 id="9-4-Object-assign"><a href="#9-4-Object-assign" class="headerlink" title="9.4 Object.assign()"></a>9.4 Object.assign()</h3><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a=&#123;<span class="hljs-attr">a</span>:<span class="hljs-number">1</span>&#125;;<span class="hljs-keyword">var</span> b=&#123;<span class="hljs-attr">b</span>:<span class="hljs-number">2</span>&#125;;<span class="hljs-keyword">var</span> c=&#123;<span class="hljs-attr">c</span>:<span class="hljs-number">3</span>&#125;;<span class="hljs-keyword">var</span> d=&#123;<span class="hljs-attr">c</span>:<span class="hljs-number">4</span>&#125;;    <span class="hljs-comment">// 覆盖</span><span class="hljs-built_in">Object</span>.assign(a,b,c,d);a   <span class="hljs-comment">// &#123;a: 1, b: 2, c: 4&#125;</span></code></pre></div><h3 id="9-7-属性的遍历"><a href="#9-7-属性的遍历" class="headerlink" title="9.7 属性的遍历"></a>9.7 属性的遍历</h3><p>ES6有5种方法遍历</p><ol><li>for…in</li><li>Object.keys(obj)</li><li>Object.getOwnPropertyNames(obj)</li><li>Object.getOwnPropertySymbols(obj)</li><li>Reflect.ownKeys(obj)</li></ol><h3 id="9-8-proto-Object-setPrototypeOf-Object-getPrototypeOf"><a href="#9-8-proto-Object-setPrototypeOf-Object-getPrototypeOf" class="headerlink" title="9.8 __proto__ ,Object.setPrototypeOf() ,Object.getPrototypeOf()"></a>9.8 __proto__ ,Object.setPrototypeOf() ,Object.getPrototypeOf()</h3><h4 id="9-8-1-proto"><a href="#9-8-1-proto" class="headerlink" title="9.8.1 __proto__"></a>9.8.1 __proto__</h4><p>读取或设置当前对象的<code>prototype</code></p><h3 id="9-10-对象的扩展运算符"><a href="#9-10-对象的扩展运算符" class="headerlink" title="9.10 对象的扩展运算符"></a>9.10 对象的扩展运算符</h3><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">let</span> &#123;x,y,...z&#125;=&#123;<span class="hljs-attr">y</span>:<span class="hljs-number">2</span>,<span class="hljs-attr">x</span>:<span class="hljs-number">1</span>,<span class="hljs-attr">a</span>:<span class="hljs-number">3</span>,<span class="hljs-attr">b</span>:<span class="hljs-number">4</span>&#125;;<span class="hljs-comment">// 注意x，y顺序</span>x <span class="hljs-comment">// 1</span>y <span class="hljs-comment">// 2</span>z <span class="hljs-comment">// &#123;a:3,b:4&#125;</span></code></pre></div><h3 id="9-12-Null传到运算符"><a href="#9-12-Null传到运算符" class="headerlink" title="9.12 Null传到运算符"></a>9.12 Null传到运算符</h3><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a=&#123;<span class="hljs-attr">b</span>:&#123;<span class="hljs-attr">c</span>:<span class="hljs-number">1</span>&#125;&#125;;<span class="hljs-keyword">const</span> foo=a?.b?.c || <span class="hljs-string">'default'</span>;</code></pre></div><h2 id="10-Symbol"><a href="#10-Symbol" class="headerlink" title="10 Symbol"></a>10 Symbol</h2><h3 id="10-1"><a href="#10-1" class="headerlink" title="10.1"></a>10.1</h3><p>ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值</p><p>它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">let</span> s = <span class="hljs-built_in">Symbol</span>();<span class="hljs-keyword">typeof</span> s<span class="hljs-comment">// "symbol"</span></code></pre></div><p>由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">let</span> s1 = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">'foo'</span>);<span class="hljs-keyword">let</span> s2 = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">'bar'</span>);s1 <span class="hljs-comment">// Symbol(foo)</span>s2 <span class="hljs-comment">// Symbol(bar)</span>s1.toString() <span class="hljs-comment">// "Symbol(foo)"</span>s2.toString() <span class="hljs-comment">// "Symbol(bar)"</span></code></pre></div><p>如果 Symbol 的参数是一个对象，就会调用该对象的toString方法，将其转为字符串，然后才生成一个 Symbol 值。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;  toString() &#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">'abc'</span>;  &#125;&#125;;<span class="hljs-keyword">const</span> obj1 = &#123;    a:<span class="hljs-number">1</span>&#125;;<span class="hljs-keyword">const</span> sym = <span class="hljs-built_in">Symbol</span>(obj);sym <span class="hljs-comment">// Symbol(abc)</span><span class="hljs-keyword">const</span> sym1 = <span class="hljs-built_in">Symbol</span>(ob1j);sym1 <span class="hljs-comment">// Symbol([object Object])</span></code></pre></div><h3 id="10-2-description"><a href="#10-2-description" class="headerlink" title="10.2 description"></a>10.2 description</h3><p>读取这个描述需要将 Symbol 显式转为字符串，即下面的写法</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> sym = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">'foo'</span>);<span class="hljs-built_in">String</span>(sym) <span class="hljs-comment">// "Symbol(foo)"</span>sym.toString() <span class="hljs-comment">// "Symbol(foo)"</span></code></pre></div><p>ES2019 提供了一个实例属性description，直接返回 Symbol 的描述。</p><h3 id="10-3-作为属性名的-Symbol"><a href="#10-3-作为属性名的-Symbol" class="headerlink" title="10.3 作为属性名的 Symbol"></a>10.3 作为属性名的 Symbol</h3><p>防止某一个键被不小心改写或覆盖</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">let</span> mySymbol = <span class="hljs-built_in">Symbol</span>();<span class="hljs-comment">// 第一种写法</span><span class="hljs-keyword">let</span> a = &#123;&#125;;a[mySymbol] = <span class="hljs-string">'Hello!'</span>;<span class="hljs-comment">// 第二种写法</span><span class="hljs-keyword">let</span> a = &#123;  [mySymbol]: <span class="hljs-string">'Hello!'</span>&#125;;<span class="hljs-comment">// 第三种写法</span><span class="hljs-keyword">let</span> a = &#123;&#125;;<span class="hljs-built_in">Object</span>.defineProperty(a, mySymbol, &#123; <span class="hljs-attr">value</span>: <span class="hljs-string">'Hello!'</span> &#125;);<span class="hljs-comment">// 以上写法都得到同样结果</span>a[mySymbol] <span class="hljs-comment">// "Hello!"</span></code></pre></div><h3 id="10-4-属性名的遍历"><a href="#10-4-属性名的遍历" class="headerlink" title="10.4 属性名的遍历"></a>10.4 属性名的遍历</h3><p>Symbol 作为属性名，遍历对象的时候，该属性不会出现在for…in、for…of循环中，<strong>也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回</strong>。</p><p>但是，它也不是私有属性，有一个Object.<strong>getOwnPropertySymbols()</strong>方法，可以获取<strong>指定对象的所有 Symbol 属性名</strong>。该方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。</p><h3 id="10-5-Symbol-for-，Symbol-keyFor"><a href="#10-5-Symbol-for-，Symbol-keyFor" class="headerlink" title="10.5 Symbol.for()，Symbol.keyFor()"></a>10.5 Symbol.for()，Symbol.keyFor()</h3><p>有时，我们希望重新使用同一个 Symbol 值，<code>Symbol.for()</code>方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，<strong>否则就新建</strong>一个以该字符串为名称的 Symbol 值，并将其注册到全局</p><p>Symbol.for()与Symbol()这两种写法，都会生成新的 Symbol。它们的区别是，<strong>前者</strong>会被<strong>登记在全局环境</strong>中供搜索，后者不会。</p><p>但是调用Symbol(“cat”)30 次，会返回 30 个<strong>不同的</strong> Symbol 值。</p><p>Symbol.keyFor()方法返回一个<strong>已登记</strong>的 Symbol 类型值的key。</p><p>Symbol.for()的这个全局登记特性，<strong>可以用在不同的 iframe 或 service worker 中取到同一个值</strong>。</p><h3 id="10-6-使用Symbol定义类的私有属性-方法"><a href="#10-6-使用Symbol定义类的私有属性-方法" class="headerlink" title="10.6 使用Symbol定义类的私有属性/方法"></a>10.6 使用Symbol定义类的私有属性/方法</h3><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> PASSWORD = <span class="hljs-built_in">Symbol</span>()<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Login</span> </span>&#123;  <span class="hljs-keyword">constructor</span>(username, password) &#123;    <span class="hljs-keyword">this</span>.username = username    <span class="hljs-keyword">this</span>[PASSWORD] = password  &#125;  checkPassword(pwd) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>[PASSWORD] === pwd  &#125;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Login</code></pre></div><h2 id="11-Proxy"><a href="#11-Proxy" class="headerlink" title="11 Proxy"></a>11 Proxy</h2><h3 id="11-1-概述"><a href="#11-1-概述" class="headerlink" title="11.1 概述"></a>11.1 概述</h3><p><code>Proxy</code> 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。</p><p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(&#123;&#125;, &#123;  <span class="hljs-keyword">get</span>: function (target, propKey, receiver) &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`getting <span class="hljs-subst">$&#123;propKey&#125;</span>!`</span>);    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.get(target, propKey, receiver);  &#125;,  <span class="hljs-keyword">set</span>: function (target, propKey, value, receiver) &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`setting <span class="hljs-subst">$&#123;propKey&#125;</span>!`</span>);    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.set(target, propKey, value, receiver);  &#125;&#125;);</code></pre></div><div class="hljs"><pre><code class="hljs js">obj.count = <span class="hljs-number">1</span><span class="hljs-comment">//  setting count!</span>++obj.count<span class="hljs-comment">//  getting count!</span><span class="hljs-comment">//  setting count!</span><span class="hljs-comment">//  2</span></code></pre></div><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(target, handler);</code></pre></div><p>Proxy 对象的所有用法，都是上面这种形式，不同的只是handler参数的写法。其中，<code>new Proxy()</code>表示生成一个Proxy实例，<code>target</code>参数表示所要拦截的目标对象，<code>handler</code>参数也是一个对象，用来定制拦截行为。</p><p>Proxy 支持的拦截操作一览，一共 13 种：</p><ol><li><code>get(target, propKey, receiver)</code>：拦截对象属性的读取，比如<code>proxy.foo和proxy[&#39;foo&#39;]</code>。</li><li><code>set(target, propKey, value, receiver)</code>：拦截对象属性的设置，比如<code>proxy.foo = v</code>或<code>proxy[&#39;foo&#39;] = v</code>，返回一个布尔值。</li><li><code>has(target, propKey)</code>：拦截<code>propKey in proxy</code>的操作，返回一个布尔值。</li><li><code>deleteProperty(target, propKey)</code>：拦截<code>delete proxy[propKey]</code>的操作，返回一个布尔值。</li><li><code>ownKeys(target)</code>：拦截<code>Object.getOwnPropertyNames(proxy)</code>、<code>Object.getOwnPropertySymbols(proxy)</code>、<code>Object.keys(proxy)</code>、<code>for...in</code>循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而<code>Object.keys()</code>的返回结果仅包括目标对象自身的可遍历属性。</li><li><code>getOwnPropertyDescriptor(target, propKey)</code>：拦截<code>Object.getOwnPropertyDescriptor(proxy, propKey)</code>，返回属性的描述对象。</li><li><code>defineProperty(target, propKey, propDesc)</code>：拦截<code>Object.defineProperty(proxy, propKey, propDesc)</code>、<code>Object.defineProperties(proxy, propDescs)</code>，返回一个布尔值。</li><li><code>preventExtensions(target)</code>：拦截<code>Object.preventExtensions(proxy)</code>，返回一个布尔值。</li><li><code>getPrototypeOf(target)</code>：拦截<code>Object.getPrototypeOf(proxy)</code>，返回一个对象。</li><li><code>isExtensible(target)</code>：拦截<code>Object.isExtensible(proxy)</code>，返回一个布尔值。</li><li><code>setPrototypeOf(target, proto)</code>：拦截<code>Object.setPrototypeOf(proxy, proto)</code>，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。</li><li><code>apply(target, object, args)</code>：拦截 Proxy 实例作为函数调用的操作，比如<code>proxy(...args)</code>、<code>proxy.call(object, ...args)</code>、<code>proxy.apply(...)</code>。</li><li><code>construct(target, args)</code>：拦截 Proxy 实例作为构造函数调用的操作，比如<code>new proxy(...args)</code>。</li></ol><h3 id="11-2-Proxy-实例的方法"><a href="#11-2-Proxy-实例的方法" class="headerlink" title="11.2 Proxy 实例的方法"></a>11.2 Proxy 实例的方法</h3><p>如果一个属性不可配置（configurable）且不可写（writable），则 Proxy 不能修改该属性，否则通过 Proxy 对象访问该属性会报错。</p><p><code>get(target, propKey, receiver)</code></p><blockquote><p>拦截某个属性的读取操作,接受三个参数，依次为目标对象、属性名和 proxy 实例本身（严格地说，是操作行为所针对的对象），其中最后一个参数可选。</p></blockquote><p><code>set(target, propKey, value, receiver)</code></p><blockquote><p>set方法用来拦截某个属性的赋值操作，可以接受四个参数，依次为目标对象、属性名、属性值和 Proxy 实例本身，其中最后一个参数可选。</p></blockquote><h3 id="11-3-this-问题"><a href="#11-3-this-问题" class="headerlink" title="11.3 this 问题"></a>11.3 <code>this</code> 问题</h3><p>虽然 Proxy 可以代理针对目标对象的访问，但它不是目标对象的透明代理，即不做任何拦截的情况下，也无法保证与目标对象的行为一致。主要原因就是在 Proxy 代理的情况下，目标对象内部的<code>this</code>关键字会指向 Proxy 代理。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> target = &#123;  m: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>);  &#125;&#125;;<span class="hljs-keyword">const</span> handler = &#123;&#125;;<span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(target, handler);target.m() <span class="hljs-comment">// &#123;m: ƒ&#125;</span>proxy.m()  <span class="hljs-comment">// Proxy &#123;m: ƒ&#125;</span></code></pre></div><p>可以通过绑定this解决</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> target = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">'2015-01-01'</span>);<span class="hljs-keyword">const</span> handler = &#123;  <span class="hljs-keyword">get</span>(target, prop) &#123;    <span class="hljs-keyword">if</span> (prop === <span class="hljs-string">'getDate'</span>) &#123;      <span class="hljs-keyword">return</span> target.getDate.bind(target);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.get(target, prop);  &#125;&#125;;<span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(target, handler);proxy.getDate() <span class="hljs-comment">// 1</span></code></pre></div><h2 id="12-Promise"><a href="#12-Promise" class="headerlink" title="12 Promise"></a>12 Promise</h2><p><code>Promise</code>对象有以下两个特点。</p><ol><li>对象的状态<strong>不受外界影响</strong>。<code>Promise</code>对象代表一个异步操作，有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和<code>rejected</code>（已失败）。<strong>只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态</strong>。</li><li><strong>一旦状态改变，就不会再变，任何时候都可以得到这个结果</strong>。<code>Promise</code>对象的状态改变，只有两种可能：从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 <code>resolved</code>（已定型）。如果改变已经发生了，<strong>你再对<code>Promise</code>对象添加回调函数，也会立即得到这个结果</strong>。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</li></ol><p>Promise也有一些缺点。</p><ul><li>首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。</li><li>其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。</li><li>第三，当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</li></ul><h3 id="12-1-基本用法"><a href="#12-1-基本用法" class="headerlink" title="12.1 基本用法"></a>12.1 基本用法</h3><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>&#123;  <span class="hljs-comment">// ... some code</span>  <span class="hljs-keyword">if</span> (<span class="hljs-comment">/* 异步操作成功 */</span>)&#123;    resolve(value);  &#125; <span class="hljs-keyword">else</span> &#123;    reject(error);  &#125;&#125;);</code></pre></div><p>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code>。</p><ul><li><code>resolve</code>函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；</li><li><code>reject</code>函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</li></ul><p>Promise实例生成以后，可以用<code>then</code>方法分别指定resolved状态和rejected状态的回调函数。</p><p>下面是异步加载图片的例子。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loadImageAsync</span>(<span class="hljs-params">url</span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>&#123;    <span class="hljs-keyword">const</span> image = <span class="hljs-keyword">new</span> Image();    image.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;      resolve(image);    &#125;;    image.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;      reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Could not load image at '</span> + url));    &#125;;    image.src = url;  &#125;);&#125;</code></pre></div><h3 id="12-2-Promise-prototype-then"><a href="#12-2-Promise-prototype-then" class="headerlink" title="12.2 Promise.prototype.then()"></a>12.2 Promise.prototype.then()</h3><p>then方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数。</p><p><code>then</code>方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。<strong>因此可以采用链式写法</strong>，即then方法后面再调用另一个then方法。</p><p>指定两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。</p><h3 id="12-3-Promise-prototype-catch"><a href="#12-3-Promise-prototype-catch" class="headerlink" title="12.3 Promise.prototype.catch()"></a>12.3 Promise.prototype.catch()</h3><p>是<code>.then(null, rejection)</code>或<code>.then(undefined, rejection)</code>的别名，用于指定发生错误时的回调函数。</p><h3 id="12-4-Promise-prototype-finally"><a href="#12-4-Promise-prototype-finally" class="headerlink" title="12.4 Promise.prototype.finally()"></a>12.4 Promise.prototype.finally()</h3><p>用于指定不管 <code>Promise</code> 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。</p><p><code>finally</code>方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 <code>Promise</code> 状态到底是fulfilled还是rejected。这表明，finally方法里面的操作，应该是与状态无关的，不依赖于 <code>Promise</code> 的执行结果。</p><h3 id="12-5-Promise-all"><a href="#12-5-Promise-all" class="headerlink" title="12.5 Promise.all()"></a>12.5 Promise.all()</h3><p>用于将多个 <code>Promise</code> 实例，包装成一个新的 <code>Promise</code> 实例。</p><p><code>Promise.all()</code>方法的参数可以不是数组，但必须具有 <code>Iterator</code> 接口，且返回的每个成员都是 <code>Promise</code> 实例。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p = <span class="hljs-built_in">Promise</span>.all([p1, p2, p3]);</code></pre></div><p>p的状态由p1、p2、p3决定，分成两种情况。</p><ol><li>只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的<strong>返回值组成一个数组</strong>，传递给p的回调函数。</li><li>只要p1、p2、p3之中<strong>有一个</strong>被rejected，p的状态就变成rejected，此时<strong>第一个</strong>被reject的实例的返回值，会传递给p的回调函数。</li></ol><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;  resolve(<span class="hljs-string">'hello'</span>);&#125;).then(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> result).catch(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> e);<span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'报错了'</span>);&#125;).then(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> result).catch(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> e);<span class="hljs-built_in">Promise</span>.all([p1, p2]).then(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(result)).catch(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(e));<span class="hljs-comment">// ["hello", Error: 报错了]</span></code></pre></div><p>上面代码中，<code>p1</code>会resolved，<code>p2</code>首先会rejected，但是<code>p2</code>有自己的catch方法，该方法返回的是一个新的 Promise 实例，<code>p2</code>指向的实际上是这个实例。导致<code>Promise.all()</code>方法参数里面的两个实例都会resolved</p><h3 id="12-6-Promise-race"><a href="#12-6-Promise-race" class="headerlink" title="12.6 Promise.race()"></a>12.6 Promise.race()</h3><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p = <span class="hljs-built_in">Promise</span>.race([p1, p2, p3]);</code></pre></div><p>只要有一个实例率先改变状态，<code>p</code>的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给<code>p</code>的回调函数。</p><h3 id="12-7-Promise-resolve"><a href="#12-7-Promise-resolve" class="headerlink" title="12.7 Promise.resolve()"></a>12.7 Promise.resolve()</h3><p>将现有对象转为 Promise 对象</p><p><code>Promise.resolve()</code>等价于下面的写法。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'foo'</span>)<span class="hljs-comment">// 等价于</span><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> resolve(<span class="hljs-string">'foo'</span>))</code></pre></div><p><strong>需要注意的是</strong>，立即<code>resolve()</code>的 Promise 对象，是在<strong>本轮</strong>“事件循环”（event loop）的结束时执行，而<strong>不是在下一轮</strong>“事件循环”的开始时。</p><p><code>Promise.resolve</code>方法的参数分成四种情况。</p><p><strong>（1）</strong>参数是一个 Promise 实例</p><p>如果参数是 Promise 实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例。</p><p><strong>（2）</strong>参数是一个<code>thenable</code>对象</p><p><code>thenable</code>对象指的是具有<code>then</code>方法的对象，比如下面这个对象。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">let</span> thenable = &#123;  then: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>&#123;    resolve(<span class="hljs-number">42</span>);  &#125;&#125;;</code></pre></div><p>Promise.resolve方法会将这个对象转为 Promise 对象，然后就立即执行<code>thenable</code>对象的<code>then</code>方法。</p><p><strong>（3）</strong>参数不是具有then方法的对象，或根本就不是对象</p><p>返回一个新的 <code>Promise</code> 对象，状态为resolved。</p><p><code>（4）</code>不带有任何参数</p><p>直接返回一个resolved状态的 Promise 对象。</p><h3 id="12-8-Promise-reject"><a href="#12-8-Promise-reject" class="headerlink" title="12.8 Promise.reject()"></a>12.8 Promise.reject()</h3><h3 id="12-9-Promise-try"><a href="#12-9-Promise-try" class="headerlink" title="12.9 Promise.try()"></a>12.9 Promise.try()</h3><p>实际开发中，经常遇到一种情况：不知道或者不想区分，函数f是同步函数还是异步操作，但是想用 Promise 来处理它。因为这样就可以不管f是否包含异步操作，都用then方法指定下一步流程，用catch方法处理f抛出的错误。一般就会采用下面的写法。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">Promise</span>.resolve().then(f)</code></pre></div><p><strong>缺点</strong>，就是如果f是同步函数，那么它会在本轮事件循环的<strong>末尾</strong>执行。</p><p>那么有没有一种方法，让同步函数同步执行，异步函数异步执行，并且让它们具有统一的 API 呢？回答是可以的，并且还有<strong>两种</strong>写法。</p><p>第一种写法是用<code>async</code>函数来写。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> f = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'now'</span>);(<span class="hljs-keyword">async</span> () =&gt; f())();<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'next'</span>);<span class="hljs-comment">// now</span><span class="hljs-comment">// next</span></code></pre></div><p>第二种写法是使用<code>new Promise()</code>。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> f = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'now'</span>);(  () =&gt; <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(    resolve =&gt; resolve(f())  ))();<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'next'</span>);<span class="hljs-comment">// now</span><span class="hljs-comment">// next</span></code></pre></div><p>现在有一个提案，提供<code>Promise.try</code>方法替代上面的写法。</p>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js class</title>
    <link href="/2020/07/14/notes/web/js/class/"/>
    <url>/2020/07/14/notes/web/js/class/</url>
    
    <content type="html"><![CDATA[<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>相当于将属性或方法添加到构造函数上</p><p>例：</p><div class="hljs"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> A &#123;    <span class="hljs-keyword">static</span> b: <span class="hljs-built_in">string</span> = <span class="hljs-string">"b"</span>    a: <span class="hljs-built_in">string</span>    <span class="hljs-keyword">constructor</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">this</span>.a = <span class="hljs-string">"1"</span>    &#125;    getA() &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.a    &#125;    <span class="hljs-keyword">static</span> getB() &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.b    &#125;&#125;</code></pre></div><p>转化为js：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-meta">"use strict"</span>;<span class="hljs-keyword">var</span> A = <span class="hljs-comment">/** @class */</span> (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">A</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">this</span>.a = <span class="hljs-string">"1"</span>;    &#125;    A.prototype.getA = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.a;    &#125;;    A.getB = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.b;    &#125;;    A.b = <span class="hljs-string">"b"</span>;    <span class="hljs-keyword">return</span> A;&#125;());</code></pre></div><h2 id="super"><a href="#super" class="headerlink" title="super"></a>super</h2><h3 id="当做函数使用"><a href="#当做函数使用" class="headerlink" title="当做函数使用"></a>当做函数使用</h3><p>在 <code>constructor</code> 中必须调用 <code>super</code> 方法，因为子类没有自己的 <code>this</code> 对象(在调用<code>super()</code>之前)，而是继承父类的 <code>this</code> 对象，然后对其进行加工,而 <code>super</code> 就代表了父类的构造函数。<code>super</code> 虽然代表了父类 <code>A</code> 的构造函数，但是返回的是子类 <code>B</code> 的实例，即 <code>super</code> 内部的 <code>this</code> 指的是 <code>B</code>，因此 <code>super()</code> 在这里相当于 <code>A.prototype.constructor.call(this, props)</code>。</p><h3 id="当做对象使用"><a href="#当做对象使用" class="headerlink" title="当做对象使用"></a>当做对象使用</h3><p>在普通方法中，指向父类的原型对象；在静态方法中，指向父类。</p><p>通过 <code>super</code> 调用父类的方法时，<code>super</code> 会绑定子类的 <code>this</code>。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;  <span class="hljs-keyword">constructor</span> &#123;    <span class="hljs-keyword">this</span>.x = <span class="hljs-number">1</span>;  &#125;  s() &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.x);  &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;  <span class="hljs-keyword">constructor</span> &#123;    <span class="hljs-keyword">super</span>();    <span class="hljs-keyword">this</span>.x = <span class="hljs-number">2</span>;  &#125;  m() &#123;    <span class="hljs-keyword">super</span>.s();  &#125;&#125;<span class="hljs-keyword">let</span> b = <span class="hljs-keyword">new</span> B();b.m(); <span class="hljs-comment">// 2</span></code></pre></div><p><code>super.s()</code> 虽然调用的是 <code>A.prototytpe.s()</code>，但是 <code>A.prototytpe.s()</code>会绑定子类 <code>B</code> 的 <code>this</code>，导致输出的是 2，而不是 1。也就是说，实际上执行的是 <code>super.s.call(this)</code>。</p>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>模拟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>call和apply</title>
    <link href="/2020/07/14/notes/web/js/call%E5%92%8Capply/"/>
    <url>/2020/07/14/notes/web/js/call%E5%92%8Capply/</url>
    
    <content type="html"><![CDATA[<p>call() 和 apply()的区别在于，call()方法接受的是若干个参数的列表，而apply()方法接受的是一个包含多个参数的数组</p><div class="hljs"><pre><code class="hljs js">fun.call(thisArg, arg1, arg2, ...)</code></pre></div><p>非严格模式下，则指定为null和undefined的this值会自动指向全局对象(浏览器中就是window对象)，同时值为原始值(数字，字符串，布尔值)的this自动用 Object() 转换</p><p>apply从 ECMAScript 第5版开始，可以使用任何种类的<strong>类数组对象</strong></p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">Array</span>.apply(<span class="hljs-literal">null</span>, &#123; <span class="hljs-string">'length'</span>: <span class="hljs-number">3</span>, <span class="hljs-string">'0'</span>: <span class="hljs-string">'eat'</span>, <span class="hljs-string">'1'</span>: <span class="hljs-string">'bananas'</span> &#125;)<span class="hljs-comment">// ["eat", "bananas", undefined]</span></code></pre></div><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><h3 id="1、合并两个数组"><a href="#1、合并两个数组" class="headerlink" title="1、合并两个数组"></a>1、合并两个数组</h3><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> vegetables = [<span class="hljs-string">'parsnip'</span>, <span class="hljs-string">'potato'</span>];<span class="hljs-keyword">var</span> moreVegs = [<span class="hljs-string">'celery'</span>, <span class="hljs-string">'beetroot'</span>];<span class="hljs-comment">// 将第二个数组融合进第一个数组</span><span class="hljs-comment">// 相当于 vegetables.push('celery', 'beetroot');</span><span class="hljs-built_in">Array</span>.prototype.push.apply(vegetables, moreVegs);<span class="hljs-comment">// 4</span>vegetables;<span class="hljs-comment">// ['parsnip', 'potato', 'celery', 'beetroot']</span></code></pre></div><p>当第二个数组(如示例中的 moreVegs )<strong>太大时不要使用这个方法</strong>来合并数组，因为一个函数能够接受的参数个数是有限制的。不同的引擎有不同的限制,有些引擎会抛出异常，有些不抛出异常但丢失多余参数。</p><p>如何解决呢？方法就是将参数数组<strong>切块</strong>后循环传入目标方法</p><h3 id="2、获取数组中的最大值和最小值"><a href="#2、获取数组中的最大值和最小值" class="headerlink" title="2、获取数组中的最大值和最小值"></a>2、获取数组中的最大值和最小值</h3><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">Math</span>.max.apply(<span class="hljs-built_in">Math</span>, numbers);</code></pre></div><h3 id="3、验证是否是数组"><a href="#3、验证是否是数组" class="headerlink" title="3、验证是否是数组"></a>3、验证是否是数组</h3><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isArray</span>(<span class="hljs-params">obj</span>)</span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.prototype.toString.call(obj) === <span class="hljs-string">'[object Array]'</span>;&#125;isArray([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<span class="hljs-comment">// true</span><span class="hljs-comment">// 直接使用 toString()</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].toString(); <span class="hljs-comment">// "1,2,3"</span><span class="hljs-string">"123"</span>.toString(); <span class="hljs-comment">// "123"</span><span class="hljs-number">123.</span>toString(); <span class="hljs-comment">// SyntaxError: Invalid or unexpected token</span><span class="hljs-built_in">Number</span>(<span class="hljs-number">123</span>).toString(); <span class="hljs-comment">// "123"</span><span class="hljs-built_in">Object</span>(<span class="hljs-number">123</span>).toString(); <span class="hljs-comment">// "123"</span></code></pre></div><h3 id="4、类数组对象（Array-like-Object）使用数组方法"><a href="#4、类数组对象（Array-like-Object）使用数组方法" class="headerlink" title="4、类数组对象（Array-like Object）使用数组方法"></a>4、类数组对象（Array-like Object）使用数组方法</h3><p>类数组对象有下面两个特性</p><ul><li>1、具有：指向对象元素的数字索引下标和 length 属性</li><li>2、不具有：比如 push 、shift、 forEach 以及 indexOf等数组对象具有的方法</li></ul><p>JS中存在一种名为类数组的对象结构，比如 <code>arguments</code> 对象，还有DOM API 返回的 <code>NodeList</code> 对象都属于类数组对象</p><p>通过 <code>Array.prototype.slice.call</code> ,<code>Array.from()</code>,扩展运算符转换成真正的数组</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 上面代码等同于</span><span class="hljs-keyword">var</span> arr = [].slice.call(<span class="hljs-built_in">arguments</span>)；ES6:<span class="hljs-keyword">let</span> arr = <span class="hljs-built_in">Array</span>.from(<span class="hljs-built_in">arguments</span>);<span class="hljs-keyword">let</span> arr = [...arguments];</code></pre></div><h3 id="call的模拟实现"><a href="#call的模拟实现" class="headerlink" title="call的模拟实现"></a>call的模拟实现</h3><p>ES6:</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">Function</span>.prototype.call = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">context, ...args</span>) </span>&#123;    context = context === <span class="hljs-literal">undefined</span> || context === <span class="hljs-literal">null</span> ? <span class="hljs-built_in">window</span> : <span class="hljs-built_in">Object</span>(context)    <span class="hljs-keyword">const</span> fn = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">'fn'</span>)    context[fn] = <span class="hljs-keyword">this</span>    <span class="hljs-keyword">const</span> result = context[fn](...args)    <span class="hljs-keyword">delete</span> context[fn]    <span class="hljs-keyword">return</span> result&#125;</code></pre></div><h3 id="apply的模拟实现"><a href="#apply的模拟实现" class="headerlink" title="apply的模拟实现"></a>apply的模拟实现</h3><p>ES6：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">Function</span>.prototype.apply = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">context, args</span>) </span>&#123;    context = context === <span class="hljs-literal">undefined</span> || context === <span class="hljs-literal">null</span> ? <span class="hljs-built_in">window</span> : <span class="hljs-built_in">Object</span>(context)    <span class="hljs-keyword">const</span> fn = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">'fn'</span>)    context[fn] = <span class="hljs-keyword">this</span>    <span class="hljs-keyword">const</span> result = context[fn](...args)    <span class="hljs-keyword">delete</span> context[fn]    <span class="hljs-keyword">return</span> result&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>模拟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>this的绑定规则</title>
    <link href="/2020/07/14/notes/web/js/5%E7%A7%8Dthis%E7%BB%91%E5%AE%9A(%E9%83%A8%E5%88%86)/"/>
    <url>/2020/07/14/notes/web/js/5%E7%A7%8Dthis%E7%BB%91%E5%AE%9A(%E9%83%A8%E5%88%86)/</url>
    
    <content type="html"><![CDATA[<p>this的绑定规则总共有下面5种。</p><ul><li>1、默认绑定（严格/非严格模式）</li><li>2、隐式绑定</li><li>3、显式绑定</li><li>4、new绑定</li><li>5、箭头函数绑定</li></ul><h2 id="绑定规则"><a href="#绑定规则" class="headerlink" title="绑定规则"></a>绑定规则</h2><h3 id="1-默认绑定"><a href="#1-默认绑定" class="headerlink" title="1 默认绑定"></a>1 默认绑定</h3><ul><li>独立函数调用，可以把默认绑定看作是无法应用其他规则时的默认规则，this指向全局对象。</li><li>严格模式下，不能将全局对象用于默认绑定，this会绑定到undefined。只有函数运行在非严格模式下，默认绑定才能绑定到全局对象。在严格模式下调用函数则不影响默认绑定</li></ul><h3 id="2-隐式绑定"><a href="#2-隐式绑定" class="headerlink" title="2 隐式绑定"></a>2 隐式绑定</h3><p>当函数引用有上下文对象时，隐式绑定规则会把函数中的this绑定到这个上下文对象。对象属性引用链中只有上一层或者说最后一层在调用中起作用。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log( <span class="hljs-keyword">this</span>.a );&#125;<span class="hljs-keyword">var</span> obj = &#123;    a: <span class="hljs-number">2</span>,    foo: foo&#125;;obj.foo(); <span class="hljs-comment">// 2</span></code></pre></div><h4 id="隐式丢失"><a href="#隐式丢失" class="headerlink" title="隐式丢失"></a>隐式丢失</h4><p>特定情况下会丢失绑定对象</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 虽然bar是obj.foo的一个引用，但是实际上，它引用的是foo函数本身。</span><span class="hljs-comment">// bar()是一个不带任何修饰的函数调用，应用默认绑定。</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log( <span class="hljs-keyword">this</span>.a );&#125;<span class="hljs-keyword">var</span> obj = &#123;    a: <span class="hljs-number">2</span>,    foo: foo&#125;;<span class="hljs-keyword">var</span> bar = obj.foo; <span class="hljs-comment">// 函数别名</span><span class="hljs-keyword">var</span> a = <span class="hljs-string">"oops, global"</span>; <span class="hljs-comment">// a是全局对象的属性</span>bar(); <span class="hljs-comment">// "oops, global"</span>obj.foo(); <span class="hljs-comment">// 2</span></code></pre></div><h3 id="3-显式绑定"><a href="#3-显式绑定" class="headerlink" title="3 显式绑定"></a>3 显式绑定</h3><p>call(..) 或者 apply(..)。第一个参数是一个对象，在调用函数时将这个对象绑定到this。</p><p><strong>无法解决丢失绑定</strong>问题</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log( <span class="hljs-keyword">this</span>.a );&#125;<span class="hljs-keyword">var</span> obj = &#123;    a: <span class="hljs-number">2</span>&#125;;foo.call( obj ); <span class="hljs-comment">// 2  调用foo时强制把foo的this绑定到obj上</span></code></pre></div><p>解决方案：</p><h4 id="1、硬绑定"><a href="#1、硬绑定" class="headerlink" title="1、硬绑定"></a>1、硬绑定</h4><p>创建函数bar()，并在它的内部手动调用foo.call(obj)，强制把foo的this绑定到了obj。</p><p>ES5内置了Function.prototype.bind，bind会返回一个硬绑定的新函数，用法如下。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">something</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log( <span class="hljs-keyword">this</span>.a, something );    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.a + something;&#125;<span class="hljs-keyword">var</span> obj = &#123;    a: <span class="hljs-number">2</span>&#125;;<span class="hljs-keyword">var</span> bar = foo.bind( obj );<span class="hljs-keyword">var</span> b = bar( <span class="hljs-number">3</span> ); <span class="hljs-comment">// 2 3</span><span class="hljs-built_in">console</span>.log( b ); <span class="hljs-comment">// 5</span></code></pre></div><h4 id="2、API调用的“上下文”"><a href="#2、API调用的“上下文”" class="headerlink" title="2、API调用的“上下文”"></a>2、API调用的“上下文”</h4><p>JS许多内置函数提供了一个可选参数，被称之为“上下文”（context），其作用和bind(..)一样，确保回调函数使用指定的this。这些函数实际上通过call(..)和apply(..)实现了显式绑定。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">el</span>) </span>&#123;<span class="hljs-built_in">console</span>.log( el, <span class="hljs-keyword">this</span>.id );&#125;<span class="hljs-keyword">var</span> obj = &#123;    id: <span class="hljs-string">"awesome"</span>&#125;<span class="hljs-keyword">var</span> myArray = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<span class="hljs-comment">// 调用foo(..)时把this绑定到obj</span>myArray.forEach( foo, obj );<span class="hljs-comment">// 1 awesome 2 awesome 3 awesome</span></code></pre></div><h3 id="4-new绑定"><a href="#4-new绑定" class="headerlink" title="4 new绑定"></a>4 new绑定</h3><p>使用new来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。</p><ul><li>1、创建（或者说构造）一个新对象。</li><li>2、这个新对象会被执行<code>[[Prototype]]</code>连接。</li><li>3、这个新对象会绑定到函数调用的this。</li><li>4、如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。</li></ul><p>手写一个new实现</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">create</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-comment">// 创建一个空的对象</span>    <span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>(),    <span class="hljs-comment">// 获得构造函数，arguments中去除第一个参数</span>    Con = [].shift.call(<span class="hljs-built_in">arguments</span>);    <span class="hljs-comment">// 链接到原型，obj 可以访问到构造函数原型中的属性</span>    obj.__proto__ = Con.prototype;    <span class="hljs-comment">// 绑定 this 实现继承，obj 可以访问到构造函数中的属性</span>    <span class="hljs-keyword">var</span> ret = Con.apply(obj, <span class="hljs-built_in">arguments</span>);    <span class="hljs-comment">// 优先返回构造函数返回的对象</span>    <span class="hljs-keyword">return</span> ret <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span> ? ret : obj;&#125;;</code></pre></div><h3 id="bind实现柯里化"><a href="#bind实现柯里化" class="headerlink" title="bind实现柯里化"></a>bind实现柯里化</h3><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">a, b</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log( <span class="hljs-string">"a:"</span> + a + <span class="hljs-string">"，b:"</span> + b );&#125;<span class="hljs-comment">// 把数组”展开“成参数</span>foo.apply( <span class="hljs-literal">null</span>, [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>] ); <span class="hljs-comment">// a:2，b:3</span><span class="hljs-comment">// 使用bind(..)进行柯里化</span><span class="hljs-keyword">var</span> bar = foo.bind( <span class="hljs-literal">null</span>, <span class="hljs-number">2</span> );bar( <span class="hljs-number">3</span> ); <span class="hljs-comment">// a:2，b:3</span></code></pre></div><p>总是传入<code>null</code>来忽略this绑定可能产生一些<strong>副作用</strong>。如果某个函数确实使用了this，那默认绑定规则会把this绑定到全局对象中</p><p>安全的做法就是传入一个特殊的对象（空对象），把this绑定到这个对象不会对你的程序产生任何副作用。</p><p>JS中创建一个空对象最简单的方法是<strong>Object.create(null)</strong>，这个和{}很像，但是并不会创建Object.prototype这个委托，所以比{}更空。</p>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>this</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>canvas基本</title>
    <link href="/2020/07/14/notes/web/HTML/canvas/%E5%9F%BA%E6%9C%AC/"/>
    <url>/2020/07/14/notes/web/HTML/canvas/%E5%9F%BA%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API</a></p><p><a href="https://www.html5canvastutorials.com/tutorials/html5-canvas-circles/" target="_blank" rel="noopener">https://www.html5canvastutorials.com/tutorials/html5-canvas-circles/</a></p><h2 id="初始"><a href="#初始" class="headerlink" title="初始"></a>初始</h2><h3 id="画布大小"><a href="#画布大小" class="headerlink" title="画布大小"></a>画布大小</h3><p>直接在html标签中设置width和height属性或者使用JavaScript来指定画布尺寸，这将改变一个画布的水平像素和垂直像素数，就像定义了一张图片的大小一样。</p><p>使用CSS的width和height以在渲染期间缩放图像以适应样式大小，就像<code>&lt;img&gt;</code>元素一样。</p><h3 id="检查支持性"><a href="#检查支持性" class="headerlink" title="检查支持性"></a>检查支持性</h3><p>pass</p><h3 id="ctx"><a href="#ctx" class="headerlink" title="ctx"></a>ctx</h3><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> canvas = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">".canvas"</span>);<span class="hljs-keyword">const</span> ctx = canvas.getContext(<span class="hljs-string">'2d'</span>);</code></pre></div><h3 id="设置颜色"><a href="#设置颜色" class="headerlink" title="设置颜色"></a>设置颜色</h3><div class="hljs"><pre><code class="hljs js">ctx.fillStyle = <span class="hljs-string">'green'</span>;ctx.fillStyle = <span class="hljs-string">"rgba(0, 0, 200, 0.5)"</span>;</code></pre></div><h2 id="形状"><a href="#形状" class="headerlink" title="形状"></a>形状</h2><p><code>&lt;canvas&gt;</code> 只支持两种形式的图形绘制：矩形和路径</p><h3 id="矩形"><a href="#矩形" class="headerlink" title="矩形"></a>矩形</h3><p>即时生效。</p><p><code>fillRect(x, y, width, height)</code></p><blockquote><p>绘制一个填充的矩形</p></blockquote><p><code>strokeRect(x, y, width, height)</code></p><blockquote><p>绘制一个矩形的边框</p></blockquote><p><code>rect(x, y, width, height)</code></p><blockquote><p>将一个矩形路径增加到当前路径上。之后moveTo()方法自动设置坐标参数（0,0）</p></blockquote><p><code>clearRect(x, y, width, height)</code></p><blockquote><p>清除指定矩形区域，让清除部分完全透明。</p></blockquote><h3 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h3><p>步骤:</p><ol><li>创建路径起始点</li><li>画出路径</li><li>路径封闭(非必需),当前点为开始点</li><li>一旦路径生成，就能通过描边或填充路径区域来渲染图形。</li></ol><p><code>beginPath()</code></p><blockquote><p>新建一条路径，生成之后，图形绘制命令被指向到路径上生成路径。</p></blockquote><p><code>closePath()</code></p><blockquote><p>闭合路径之后图形绘制命令又重新指向到上下文中。</p></blockquote><p><code>moveTo(x, y)</code></p><blockquote><p>移动画笔</p></blockquote><p><code>lineTo(x, y)</code></p><blockquote><p>绘制直线</p></blockquote><p><code>stroke()</code></p><blockquote><p>通过线条来绘制图形轮廓。</p></blockquote><p><code>fill()</code></p><blockquote><p>通过填充路径的内容区域生成实心的图形。</p></blockquote><p><code>arc(x, y, radius, startAngle, endAngle, anticlockwise)</code></p><blockquote><p>x,y为绘制圆弧所在圆上的圆心坐标。radius为半径。startAngle以及endAngle参数用弧度定义了开始以及结束的弧度。这些都是以x轴为基准。参数anticlockwise为一个布尔值。为true时，是逆时针方向，否则顺时针方向。</p></blockquote><p><code>quadraticCurveTo(cp1x, cp1y, x, y)</code></p><blockquote><p>绘制二次贝塞尔曲线，cp1x,cp1y为一个控制点，x,y为结束点。</p></blockquote><p><code>bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)</code></p><blockquote><p>绘制三次贝塞尔曲线，cp1x,cp1y为控制点一，cp2x,cp2y为控制点二，x,y为结束点。</p></blockquote><h3 id="Path2D"><a href="#Path2D" class="headerlink" title="Path2D()"></a><code>Path2D()</code></h3><p>会返回一个新初始化的Path2D对象（可能将某一个路径作为变量——创建一个它的副本，或者将一个包含SVG path数据的字符串作为变量）。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">new</span> Path2D();     <span class="hljs-comment">// 空的Path对象</span><span class="hljs-keyword">new</span> Path2D(path); <span class="hljs-comment">// 克隆Path对象</span><span class="hljs-keyword">new</span> Path2D(d);    <span class="hljs-comment">// 从SVG建立Path对象</span></code></pre></div><h3 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h3><h4 id="色彩-Colors"><a href="#色彩-Colors" class="headerlink" title="色彩 Colors"></a>色彩 Colors</h4><p><code>fillStyle = color</code></p><blockquote><p>设置图形的填充颜色。</p></blockquote><p><code>strokeStyle = color</code></p><blockquote><p>设置图形轮廓的颜色。</p></blockquote><h4 id="透明度-Transparency"><a href="#透明度-Transparency" class="headerlink" title="透明度 Transparency"></a>透明度 Transparency</h4><ol><li>Colors里设置</li><li><code>ctx.globalAlpha = 0.2;</code>,画笔设置透明度值</li></ol><h4 id="线样式-Line-styles"><a href="#线样式-Line-styles" class="headerlink" title="线样式 Line styles"></a>线样式 Line styles</h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial/Applying_styles_and_colors" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial/Applying_styles_and_colors</a></p><h4 id="…"><a href="#…" class="headerlink" title="…"></a>…</h4><h3 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h3><p>设置样式后</p><p>canvas 提供了两种方法来渲染文本:</p><p><code>fillText(text, x, y [, maxWidth])</code></p><blockquote><p>在指定的(x,y)位置填充指定的文本，绘制的最大宽度是可选的.</p></blockquote><p><code>strokeText(text, x, y [, maxWidth])</code></p><blockquote><p>在指定的(x,y)位置绘制文本边框，绘制的最大宽度是可选的</p></blockquote><h3 id="使用图片"><a href="#使用图片" class="headerlink" title="使用图片"></a>使用图片</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial/Using_images" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial/Using_images</a></p><h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial/Advanced_animations" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial/Advanced_animations</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>html</tag>
      
      <tag>canvas</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ImageData 对象</title>
    <link href="/2020/07/14/notes/web/HTML/canvas/ImageData%20%E5%AF%B9%E8%B1%A1/"/>
    <url>/2020/07/14/notes/web/HTML/canvas/ImageData%20%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<p>ImageData对象中存储着canvas对象真实的像素数据，它包含以下几个只读属性：</p><p><code>width</code></p><blockquote><p>图片宽度，单位是像素<br><code>height</code><br>图片高度，单位是像素<br><code>data</code><br><code>Uint8ClampedArray</code>类型的一维数组，包含着RGBA格式的整型数据，范围在0至255之间（包括255）。</p></blockquote><p>每个像素用4个1bytes值,按照红，绿，蓝和透明值的顺序,每个颜色值部份用0至255来代表。</p><p><code>Uint8ClampedArray</code>包含高度 × 宽度 × 4 bytes数据，索引值从0到(高度×宽度×4)-1</p><p>Uint8ClampedArray.length属性来读取像素数组的大小（以bytes为单位）：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> numBytes = imageData.data.length;</code></pre></div><h2 id="创建一个ImageData对象"><a href="#创建一个ImageData对象" class="headerlink" title="创建一个ImageData对象"></a>创建一个ImageData对象</h2><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 所有像素被预设为透明黑。</span><span class="hljs-keyword">var</span> myImageData = ctx.createImageData(width, height);<span class="hljs-comment">// 相同像素的ImageData对象,像素全部被预设为透明黑</span><span class="hljs-keyword">var</span> anotherImageData = ctx.createImageData(myImageData);</code></pre></div><h2 id="得到场景像素数据"><a href="#得到场景像素数据" class="headerlink" title="得到场景像素数据"></a>得到场景像素数据</h2><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> myImageData = ctx.getImageData(left, top, width, height);</code></pre></div><h2 id="保存图片"><a href="#保存图片" class="headerlink" title="保存图片"></a>保存图片</h2><p><code>canvas.toDataURL(&#39;image/png&#39;)</code></p><blockquote><p>默认设定。创建一个PNG图片。</p></blockquote><p><code>canvas.toDataURL(&#39;image/jpeg&#39;, quality)</code></p><blockquote><p>创建一个JPG图片。你可以有选择地提供从0到1的品质量，1表示最好品质，0基本不被辨析但有比较小的文件大小。</p></blockquote><p>当你从画布中生成了一个数据链接，例如，你可以将它用于任何<code>&lt;image&gt;</code>元素，或者将它放在一个有download属性的超链接里用于保存到本地。</p>]]></content>
    
    
    
    <tags>
      
      <tag>html</tag>
      
      <tag>canvas</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重排（重构/回流/reflow）, 重绘（repaint或redraw）</title>
    <link href="/2020/07/14/notes/web/HTML/%E9%87%8D%E6%8E%92%E5%92%8C%E9%87%8D%E7%BB%98/"/>
    <url>/2020/07/14/notes/web/HTML/%E9%87%8D%E6%8E%92%E5%92%8C%E9%87%8D%E7%BB%98/</url>
    
    <content type="html"><![CDATA[<p>当DOM的变化引发了元素几何属性的变化，导致浏览器不得不重新计算元素的几何属性，并重新构建渲染树，这个过程称为“重排”。</p><p>完成重排后，要将重新构建的渲染树渲染到屏幕上，这个过程就是“重绘”。</p><p>同步任务 =&gt; 重绘 =&gt; 同步任务</p><h2 id="1-重排触发机制"><a href="#1-重排触发机制" class="headerlink" title="1 重排触发机制"></a>1 重排触发机制</h2><h3 id="1-1-重排触发机制"><a href="#1-1-重排触发机制" class="headerlink" title="1.1 重排触发机制"></a>1.1 重排触发机制</h3><p>改变几何属性:</p><ol><li>添加或删除可见的DOM元素</li><li>元素位置改变</li><li>元素本身的尺寸发生改变</li><li>内容改变</li><li>页面渲染器初始化</li><li>浏览器窗口大小发生改变</li><li>读取某些元素属性：（offsetLeft/Top/Height/Width,　clientTop/Left/Width/Height,　scrollTop/Left/Width/Height,　width/height,　getComputedStyle(),currentStyle(IE)　）</li></ol><h3 id="1-2-重绘触发机制"><a href="#1-2-重绘触发机制" class="headerlink" title="1.2 重绘触发机制"></a>1.2 重绘触发机制</h3><ol><li>改变元素外观属性。如：<code>color</code>，<code>background-color</code>等。</li><li>重排</li></ol><h2 id="2-如何进行性能优化"><a href="#2-如何进行性能优化" class="headerlink" title="2 如何进行性能优化"></a>2 如何进行性能优化</h2><p>当代的浏览器对此进行了优化，这种思路类似于现在流行的MVVM框架使用的虚拟DOM，对改变的DOM节点进行依赖收集，确认没有改变的节点，就进行一次更新。</p><p>大多数浏览器通过队列化修改并批量执行来优化重排过程。</p><p>但是还是有一些特殊的元素几何属性会造成这种优化失效(实时回馈给用户的几何属性或者是布局属性)。</p><h3 id="2-1-单个节点，最小化重绘和重排"><a href="#2-1-单个节点，最小化重绘和重排" class="headerlink" title="2.1 单个节点，最小化重绘和重排"></a>2.1 单个节点，最小化重绘和重排</h3><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> el = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.el'</span>);el.style.borderLeft = <span class="hljs-string">'1px'</span>;el.style.borderRight = <span class="hljs-string">'2px'</span>;el.style.padding = <span class="hljs-string">'5px'</span>;</code></pre></div><p>改为：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> el = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.el'</span>);el.style.cssText = <span class="hljs-string">'border-left: 1px; border-right: 2px; padding: 5px'</span>;</code></pre></div><p><code>cssText</code>或直接改<code>className</code></p><h3 id="2-2-批量修改DOM"><a href="#2-2-批量修改DOM" class="headerlink" title="2.2 批量修改DOM"></a>2.2 批量修改DOM</h3><p>批量修改DOM元素的核心思想是：</p><ol><li>让该元素脱离文档流</li><li>对其进行多重改变</li><li>将元素带回文档中</li></ol><p>这个过程引发俩次重排</p><p>方法：</p><ol><li>隐藏元素(<code>display:none</code>)，进行修改后，然后再显示该元素，<strong>但会造成元素短暂消失</strong></li><li>使用文档片段(<code>document.createDocumentFragment()</code>)创建一个子树，然后再拷贝到文档中</li><li>将原始元素拷贝到一个独立的节点中，操作这个节点，然后覆盖原始元素</li></ol><h3 id="2-3-缓存布局信息"><a href="#2-3-缓存布局信息" class="headerlink" title="2.3 缓存布局信息"></a>2.3 缓存布局信息</h3><p>当访问诸如<code>offsetLeft</code>，<code>clientTop</code>这种属性时，会冲破浏览器自有的优化</p><p>糟糕的代码：</p><div class="hljs"><pre><code class="hljs js">div.style.left = <span class="hljs-number">1</span> + div.offsetLeft + <span class="hljs-string">'px'</span>;div.style.top = <span class="hljs-number">1</span> + div.offsetTop + <span class="hljs-string">'px'</span>;</code></pre></div><p>这样造成的问题就是，每次都会访问<code>div</code>的<code>offsetLeft</code>，造成浏览器强制刷新渲染队列以获取最新的<code>offsetLeft</code>值。更好的办法就是，将这个值保存下来，避免重复取值</p><div class="hljs"><pre><code class="hljs js">current = div.offsetLeft;div.style.left = <span class="hljs-number">1</span> + ++current + <span class="hljs-string">'px'</span>;div.style.top = <span class="hljs-number">1</span> + ++current + <span class="hljs-string">'px'</span>;</code></pre></div><h2 id="3-重排优化建议"><a href="#3-重排优化建议" class="headerlink" title="3 重排优化建议"></a>3 重排优化建议</h2><h3 id="3-1-分离读写操作"><a href="#3-1-分离读写操作" class="headerlink" title="3.1 分离读写操作"></a>3.1 分离读写操作</h3><p>读操作会立即重排+重绘</p><h3 id="3-2-样式集中改变"><a href="#3-2-样式集中改变" class="headerlink" title="3.2 样式集中改变"></a>3.2 样式集中改变</h3><p>更改className</p><h3 id="3-3-缓存布局信息"><a href="#3-3-缓存布局信息" class="headerlink" title="3.3 缓存布局信息"></a>3.3 缓存布局信息</h3><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// bad 强制刷新 触发两次重排</span>div.style.left = div.offsetLeft + <span class="hljs-number">1</span> + <span class="hljs-string">'px'</span>;div.style.top = div.offsetTop + <span class="hljs-number">1</span> + <span class="hljs-string">'px'</span>;<span class="hljs-comment">// good 缓存布局信息 相当于读写分离</span><span class="hljs-keyword">var</span> curLeft = div.offsetLeft;<span class="hljs-keyword">var</span> curTop = div.offsetTop;div.style.left = curLeft + <span class="hljs-number">1</span> + <span class="hljs-string">'px'</span>;div.style.top = curTop + <span class="hljs-number">1</span> + <span class="hljs-string">'px'</span>;</code></pre></div><h3 id="3-4-虚拟DOM"><a href="#3-4-虚拟DOM" class="headerlink" title="3.4 虚拟DOM"></a>3.4 虚拟DOM</h3><h3 id="3-5-脱离文档流"><a href="#3-5-脱离文档流" class="headerlink" title="3.5 脱离文档流"></a>3.5 脱离文档流</h3><h3 id="3-6-优化逻辑"><a href="#3-6-优化逻辑" class="headerlink" title="3.6 优化逻辑"></a>3.6 优化逻辑</h3>]]></content>
    
    
    
    <tags>
      
      <tag>优化</tag>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>视频Videos</title>
    <link href="/2020/07/14/notes/web/HTML/%E8%A7%86%E9%A2%91Videos/"/>
    <url>/2020/07/14/notes/web/HTML/%E8%A7%86%E9%A2%91Videos/</url>
    
    <content type="html"><![CDATA[<h2 id="使用-lt-embed-gt-标签"><a href="#使用-lt-embed-gt-标签" class="headerlink" title="使用 &lt;embed&gt; 标签"></a>使用 <code>&lt;embed&gt;</code> 标签</h2><p><code>&lt;embed src=&quot;intro.swf&quot; height=&quot;200&quot; width=&quot;200&quot;&gt;</code></p><p>问题：</p><ul><li>HTML4 无法识别 <code>&lt;embed&gt;</code> 标签。您的页面无法通过验证。</li><li>如果浏览器不支持 Flash，那么视频将无法播放</li><li>iPad 和 iPhone 不能显示 Flash 视频。</li><li>如果您将视频转换为其他格式，那么它仍然不能在所有浏览器中播放。</li></ul><h2 id="使用-lt-object-gt-标签"><a href="#使用-lt-object-gt-标签" class="headerlink" title="使用 &lt;object&gt; 标签"></a>使用 <code>&lt;object&gt;</code> 标签</h2><p><code>&lt;object data=&quot;intro.swf&quot; height=&quot;200&quot; width=&quot;200&quot;&gt;&lt;/object&gt;</code></p><p>问题:</p><ul><li>如果浏览器不支持 Flash，将无法播放视频。</li><li>iPad 和 iPhone 不能显示 Flash 视频。</li><li>如果您将视频转换为其他格式，那么它仍然不能在所有浏览器中播放。</li></ul><h2 id="使用-HTML5-lt-video-gt-元素"><a href="#使用-HTML5-lt-video-gt-元素" class="headerlink" title="使用 HTML5 &lt;video&gt; 元素"></a>使用 HTML5 <code>&lt;video&gt;</code> 元素</h2><p><code>&lt;video&gt;</code>元素在所有现代浏览器中都支持。</p><p>问题:</p><ul><li>您必须把视频转换为很多不同的格式。</li><li><code>&lt;video&gt;</code> 元素在老式浏览器中无效。</li></ul><h2 id="最好的-HTML-解决方法"><a href="#最好的-HTML-解决方法" class="headerlink" title="最好的 HTML 解决方法"></a>最好的 HTML 解决方法</h2><p>以下实例中使用了 4 种不同的视频格式。HTML 5 <code>&lt;video&gt;</code> 元素会尝试播放以 mp4、ogg 或 webm 格式中的一种来播放视频。如果均失败，则回退到 <code>&lt;embed&gt;</code> 元素。</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"320"</span> <span class="hljs-attr">height</span>=<span class="hljs-string">"240"</span> <span class="hljs-attr">controls</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"movie.mp4"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"video/mp4"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"movie.ogg"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"video/ogg"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"movie.webm"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"video/webm"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">object</span> <span class="hljs-attr">data</span>=<span class="hljs-string">"movie.mp4"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"320"</span> <span class="hljs-attr">height</span>=<span class="hljs-string">"240"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">embed</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"movie.swf"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"320"</span> <span class="hljs-attr">height</span>=<span class="hljs-string">"240"</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">object</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span></code></pre></div><h2 id="使用超链接"><a href="#使用超链接" class="headerlink" title="使用超链接"></a>使用超链接</h2><p><code>&lt;a href=&quot;intro.swf&quot;&gt;Play a video file&lt;/a&gt;</code></p>]]></content>
    
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>脱离文档流的几种方式</title>
    <link href="/2020/07/14/notes/web/HTML/%E6%96%87%E6%A1%A3%E6%B5%81/"/>
    <url>/2020/07/14/notes/web/HTML/%E6%96%87%E6%A1%A3%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h2 id="脱离文档流的几种方式"><a href="#脱离文档流的几种方式" class="headerlink" title="脱离文档流的几种方式"></a>脱离文档流的几种方式</h2><ul><li>z-index</li><li>fixed</li><li>absolute</li><li>fixed</li><li>float</li><li>…</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>html基本概念及方法</title>
    <link href="/2020/07/14/notes/web/HTML/%E5%9F%BA%E6%9C%AC/"/>
    <url>/2020/07/14/notes/web/HTML/%E5%9F%BA%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<h2 id="1-BOM"><a href="#1-BOM" class="headerlink" title="1 BOM"></a>1 BOM</h2><p>BOM（浏览器对象模型）是浏览器本身的一些信息的设置和获取，例如获取浏览器的宽度、高度，设置让浏览器跳转到哪个地址。</p><ol><li>window</li><li>Location</li><li>navigator</li><li>screen</li><li>history</li></ol><h2 id="2-DOM"><a href="#2-DOM" class="headerlink" title="2 DOM"></a>2 DOM</h2><p>XML 是一种可扩展的标记语言，所谓可扩展就是它可以描述任何结构化的数据</p><p>HTML 是一个有既定标签标准的 XML 格式，标签的名字、层级关系和属性，都被标准化（否则浏览器无法解析）。同样，它也是一棵树。</p><h3 id="2-1-获取-DOM-节点"><a href="#2-1-获取-DOM-节点" class="headerlink" title="2.1 获取 DOM 节点"></a>2.1 获取 DOM 节点</h3><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 通过 id 获取</span><span class="hljs-keyword">var</span> div1 = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'div1'</span>) <span class="hljs-comment">// 元素</span><span class="hljs-comment">// 通过 tagname 获取</span><span class="hljs-keyword">var</span> divList = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">'div'</span>)  <span class="hljs-comment">// HTMLCollection</span><span class="hljs-built_in">console</span>.log(divList.length)<span class="hljs-built_in">console</span>.log(divList[<span class="hljs-number">0</span>])<span class="hljs-comment">// 通过 class 获取</span><span class="hljs-keyword">var</span> containerList = <span class="hljs-built_in">document</span>.getElementsByClassName(<span class="hljs-string">'container'</span>) <span class="hljs-comment">// HTMLCollection</span><span class="hljs-comment">// 通过 CSS 选择器获取</span><span class="hljs-keyword">var</span> pList = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">'p'</span>) <span class="hljs-comment">// NodeList</span></code></pre></div><h4 id="property"><a href="#property" class="headerlink" title="property"></a>property</h4><p>DOM 节点就是一个 JS 对象</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> pList = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">'p'</span>)<span class="hljs-keyword">var</span> p = pList[<span class="hljs-number">0</span>]<span class="hljs-built_in">console</span>.log(p.style.width)  <span class="hljs-comment">// 获取样式</span>p.style.width = <span class="hljs-string">'100px'</span>  <span class="hljs-comment">// 修改样式</span><span class="hljs-built_in">console</span>.log(p.className)  <span class="hljs-comment">// 获取 class</span>p.className = <span class="hljs-string">'p1'</span>  <span class="hljs-comment">// 修改 class</span><span class="hljs-comment">// 获取 nodeName 和 nodeType</span><span class="hljs-built_in">console</span>.log(p.nodeName)<span class="hljs-built_in">console</span>.log(p.nodeType)</code></pre></div><h4 id="attribute"><a href="#attribute" class="headerlink" title="attribute"></a>attribute</h4><p>property 的获取和修改，是直接改变 JS 对象，而 attribute 是直接改变 HTML 的属性，两种有很大的区别。attribute 就是对 HTML 属性的 get 和 set，和 DOM 节点的 JS 范畴的 property 没有关系。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> pList = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">'p'</span>)<span class="hljs-keyword">var</span> p = pList[<span class="hljs-number">0</span>]p.getAttribute(<span class="hljs-string">'data-name'</span>)p.setAttribute(<span class="hljs-string">'data-name'</span>, <span class="hljs-string">'juejin'</span>)p.getAttribute(<span class="hljs-string">'style'</span>)p.setAttribute(<span class="hljs-string">'style'</span>, <span class="hljs-string">'font-size:30px;'</span>)</code></pre></div><p>而且，<code>get</code> 和 <code>set</code> attribute 时，还会触发 DOM 的查询或者重绘、重排，频繁操作会影响页面性能。</p><h3 id="2-2-DOM-树操作"><a href="#2-2-DOM-树操作" class="headerlink" title="2.2 DOM 树操作"></a>2.2 DOM 树操作</h3><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 添加新节点</span><span class="hljs-keyword">var</span> p1 = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'p'</span>)p1.innerHTML = <span class="hljs-string">'this is p1'</span>parent.appendChild(p1)    <span class="hljs-comment">// 尾部添加</span>parent.insertBefore(p1)   <span class="hljs-comment">// 首部添加</span></code></pre></div><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 获取父元素</span><span class="hljs-keyword">var</span> parent = child.parentElement</code></pre></div><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 获取子元素</span><span class="hljs-keyword">var</span> child = parent.childNodes</code></pre></div><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 删除节点</span><span class="hljs-keyword">var</span> child = parent.childNodesparent.removeChild(child[<span class="hljs-number">0</span>])</code></pre></div><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 替换节点</span>parent.replaceChild(para, child);</code></pre></div><h3 id="2-3-HTMLCollection-vs-NodeList"><a href="#2-3-HTMLCollection-vs-NodeList" class="headerlink" title="2.3 HTMLCollection vs. NodeList"></a>2.3 HTMLCollection vs. NodeList</h3><p><code>HTMLCollection</code>与<code>NodeList</code>都是DOM节点的集合，两者都属于Collections范畴，两者的区别在于：</p><ul><li>方法略有差异：<code>HTMLCollection</code>比<code>NodeList</code>多了一个<code>namedItem</code>方法，其他方法保持一致</li><li>包含节点类型不同：<code>NodeList</code>可以包含任何节点类型，<code>HTMLCollection</code>只包含元素节点（ElementNode）</li><li><code>HTMLCollection</code> 元素可以通过 <code>name</code>，<code>id</code> 或索引来获取。<code>NodeList</code> 只能通过索引来获取。</li><li>只有 <code>NodeList</code> 对象有包含属性节点和文本节点。</li></ul><p><strong>啥时候出现</strong>：</p><p>NodeList: <code>parent.childNodes</code>, <code>querySelectorAll()</code>,<code>getElementsByName</code></p><p>HTMLCollection: <code>getElementsByTagName</code>,<code>getElementsByClassName</code>,<code>parent.children</code></p><h2 id="3-事件"><a href="#3-事件" class="headerlink" title="3 事件"></a>3 事件</h2><h3 id="3-1-事件绑定"><a href="#3-1-事件绑定" class="headerlink" title="3.1 事件绑定"></a>3.1 事件绑定</h3><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> btn = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'btn1'</span>)btn.addEventListener(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>&#123;    <span class="hljs-comment">// event.preventDefault() // 阻止默认行为</span>    <span class="hljs-comment">// event.stopPropagation() // 阻止冒泡</span>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'clicked'</span>)&#125;)</code></pre></div><h3 id="3-2-事件代理（事件委托）"><a href="#3-2-事件代理（事件委托）" class="headerlink" title="3.2 事件代理（事件委托）"></a>3.2 事件代理（事件委托）</h3><p>事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。</p><h4 id="3-2-1-为什么要用事件委托"><a href="#3-2-1-为什么要用事件委托" class="headerlink" title="3.2.1 为什么要用事件委托"></a>3.2.1 为什么要用事件委托</h4><p>在JavaScript中，添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能，因为需要不断的与dom节点进行交互，访问dom的次数越多，引起浏览器重绘与重排的次数也就越多，就会延长整个页面的交互就绪时间，这就是为什么性能优化的主要思想之一就是减少DOM操作的原因；如果要用事件委托，就会将所有的操作放到js程序里面，与dom的操作就只需要交互一次，这样就能大大的减少与dom的交互次数，提高性能；</p><p>每个函数都是一个对象，是对象就会占用内存，对象越多，内存占用率就越大，自然性能就越差了（内存不够用，是硬伤，哈哈），比如上面的100个li，就要占用100个内存空间，如果用事件委托，那么我们就可以只对它的父级（如果只有一个父级）这一个对象进行操作，这样我们就需要一个内存空间就够了</p><p>不定长列表不需要为新增的<code>&lt;li&gt;</code>再添加事件</p><h4 id="3-2-2-事件委托的原理"><a href="#3-2-2-事件委托的原理" class="headerlink" title="3.2.2 事件委托的原理"></a>3.2.2 事件委托的原理</h4><p>事件委托是利用事件的冒泡原理来实现的</p><p>给最外面的div加点击事件，那么里面的ul，li，a做点击事件的时候，都会冒泡到最外层的div上，所以都会触发，这就是事件委托，委托它们父级代为执行事件。</p><h4 id="3-2-2-怎么实现"><a href="#3-2-2-怎么实现" class="headerlink" title="3.2.2 怎么实现"></a>3.2.2 怎么实现</h4><p><code>Event</code>对象提供了一个属性叫<code>target</code>，可以返回事件的目标节点，我们成为事件源，也就是说，<code>target</code>就可以表示为当前的事件操作的<code>dom</code>，但是不是真正操作<code>dom</code>(标准浏览器用<code>event.target</code>，万恶的IE浏览器用<code>event.srcElement</code>)</p><p>若是多种事件，可以用<code>switch,case</code></p>]]></content>
    
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图片懒加载及优化</title>
    <link href="/2020/07/14/notes/web/HTML/%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD%E5%8F%8A%E4%BC%98%E5%8C%96/"/>
    <url>/2020/07/14/notes/web/HTML/%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD%E5%8F%8A%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.im/post/583b10640ce463006ba2a71a" target="_blank" rel="noopener">https://juejin.im/post/583b10640ce463006ba2a71a</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>优化</tag>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原生DOM方法</title>
    <link href="/2020/07/14/notes/web/HTML/%E5%8E%9F%E7%94%9FDOM%E6%96%B9%E6%B3%95/"/>
    <url>/2020/07/14/notes/web/HTML/%E5%8E%9F%E7%94%9FDOM%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Client-side_web_APIs/Manipulating_documents" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Client-side_web_APIs/Manipulating_documents</a></p><p><a href="https://www.cnblogs.com/ilovexiaoming/p/6853176.html" target="_blank" rel="noopener">https://www.cnblogs.com/ilovexiaoming/p/6853176.html</a></p><h2 id="移动和删除元素"><a href="#移动和删除元素" class="headerlink" title="移动和删除元素"></a>移动和删除元素</h2><div class="hljs"><pre><code class="hljs js">sect.appendChild(linkPara);sect.removeChild(linkPara);linkPara.parentNode.removeChild(linkPara);</code></pre></div><h2 id="操作样式"><a href="#操作样式" class="headerlink" title="操作样式"></a>操作样式</h2><p><strong>注意</strong>: CSS样式的JavaSript属性版本以小驼峰式命名法书写，而CSS版本带连接符号（backgroundColor 对 background-color）。</p><div class="hljs"><pre><code class="hljs js">para.style.backgroundColor = <span class="hljs-string">'black'</span>;para.setAttribute(<span class="hljs-string">'class'</span>, <span class="hljs-string">'highlight'</span>);para.className</code></pre></div><h2 id="选择父子，兄弟等"><a href="#选择父子，兄弟等" class="headerlink" title="选择父子，兄弟等"></a>选择父子，兄弟等</h2><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> test = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"test"</span>);<span class="hljs-keyword">var</span> parent = test.parentNode; <span class="hljs-comment">// 父节点</span><span class="hljs-keyword">var</span> parent = test.parentNode.parentNode; <span class="hljs-comment">// 父节点的父节点</span><span class="hljs-keyword">var</span> chils = test.childNodes; <span class="hljs-comment">// 全部子节点</span><span class="hljs-keyword">var</span> first = test.firstChild; <span class="hljs-comment">// 第一个子节点</span><span class="hljs-keyword">var</span> last = test.lastChile; <span class="hljs-comment">// 最后一个子节点</span><span class="hljs-keyword">var</span> previous = test.previousSibling; <span class="hljs-comment">// 上一个兄弟节点.!!!!!!!!!!!!</span><span class="hljs-keyword">var</span> next = test.nextSbiling; <span class="hljs-comment">// 下一个兄弟节点,!!!!!!!!!</span></code></pre></div><ul><li><p>childNodes: 获取元素节点与文本节点</p></li><li><p>children: 获取元素节点</p></li><li><p>firstChild: 文本节点或者元素节点</p></li><li><p>firstElementChild: 第一个元素节点</p></li></ul><h2 id="createElement"><a href="#createElement" class="headerlink" title="createElement()"></a>createElement()</h2><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> btn=<span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">"BUTTON"</span>);</code></pre></div><p>语法:</p><p><code>var element = document.createElement(tagName[, options]);</code></p><p>在 HTML 文档上调用 <code>createElement()</code> 方法创建元素之前会将tagName 转化成小写，在 Firefox、Opera 和 Chrome 内核中，<code>createElement(null)</code> 等同于 <code>createElement(&quot;null&quot;)</code></p><p>options可选</p><h2 id="insertBefore"><a href="#insertBefore" class="headerlink" title="insertBefore()"></a>insertBefore()</h2><p><code>var insertedNode = parentNode.insertBefore(newNode, referenceNode);</code></p><ul><li><code>insertedNode</code> 被插入节点(newNode)</li><li><code>parentNode</code> 新插入节点的<strong>父节点</strong></li><li><code>newNode</code> 用于插入的节点</li><li><code>referenceNode</code> <code>newNode</code> 将要插在这个节点之前</li></ul><p>如果 <code>referenceNode</code> 为 <code>null</code> 则 <code>newNode</code> 将被插入到子节点的末尾。</p><div class="hljs"><pre><code class="hljs js">newNode === insertedNode<span class="hljs-comment">// true</span></code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WebSocket</title>
    <link href="/2020/07/14/notes/web/HTML/WebSocket/"/>
    <url>/2020/07/14/notes/web/HTML/WebSocket/</url>
    
    <content type="html"><![CDATA[<h2 id="1-WebSocket"><a href="#1-WebSocket" class="headerlink" title="1 WebSocket"></a>1 WebSocket</h2><p>WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议</p><p>允许服务端主动向客户端推送数据。</p><p>在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</p><p>Ajax 轮询缺点：</p><ul><li>可能包含较长的头部，其中真正有效的数据可能只是很小的一部分，浪费很多的带宽等资源</li><li>增大服务器压力</li><li>不能实时</li><li>每次都要建立HTTP连接</li><li>被动性</li></ul><p>长轮询原理：客户端发起Long Polling，此时如果服务端没有相关数据，会hold住请求，直到服务端有相关数据，或者等待一定时间超时才会返回。返回后，客户端又会立即再次发起下一次Long Polling。</p><p>长轮询缺点：</p><ul><li>每次都要建立HTTP连接</li><li>对服务器的并行要求比较大</li><li>被动性</li></ul><p>获取 Web Socket 连接后，你可以通过 <code>send()</code> 方法来向服务器发送数据，并通过 <code>onmessage</code> 事件来接收服务器返回的数据。</p><p>创建 WebSocket 对象</p><p><code>var Socket = new WebSocket(url, [protocol] );</code></p><h3 id="1-1-WebSocket-属性"><a href="#1-1-WebSocket-属性" class="headerlink" title="1.1 WebSocket 属性"></a>1.1 WebSocket 属性</h3><p><code>Socket.readyState</code></p><p>只读属性 readyState 表示连接状态，可以是以下值：</p><ul><li>0 - 表示连接尚未建立。</li><li>1 - 表示连接已建立，可以进行通信。</li><li>2 - 表示连接正在进行关闭。</li><li>3 - 表示连接已经关闭或者连接不能打开。</li></ul><p><code>Socket.bufferedAmount</code></p><p>只读属性 bufferedAmount 已被 <code>send()</code> 放入正在队列中等待传输，但是还没有发出的 UTF-8 文本字节数。</p><h3 id="1-2-WebSocket-事件"><a href="#1-2-WebSocket-事件" class="headerlink" title="1.2 WebSocket 事件"></a>1.2 WebSocket 事件</h3><table><thead><tr><th>事件</th><th>事件处理程序</th><th>描述</th></tr></thead><tbody><tr><td>open</td><td>Socket.onopen</td><td>连接建立时触发</td></tr><tr><td>message</td><td>Socket.onmessage</td><td>客户端接收服务端数据时触发</td></tr><tr><td>error</td><td>Socket.onerror</td><td>通信发生错误时触发</td></tr><tr><td>close</td><td>Socket.onclose</td><td>连接关闭时触发</td></tr></tbody></table><h3 id="1-3-WebSocket-方法"><a href="#1-3-WebSocket-方法" class="headerlink" title="1.3 WebSocket 方法"></a>1.3 WebSocket 方法</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>Socket.send()</code></td><td>使用连接发送数据</td></tr><tr><td><code>Socket.close()</code></td><td>关闭连接</td></tr></tbody></table><h3 id="1-4-pywebsocket"><a href="#1-4-pywebsocket" class="headerlink" title="1.4 pywebsocket"></a>1.4 pywebsocket</h3><h2 id="3-WebSocket和SSE对比"><a href="#3-WebSocket和SSE对比" class="headerlink" title="3 WebSocket和SSE对比"></a>3 WebSocket和SSE对比</h2><ul><li>WebSocket是全双工通道，可以双向通信，功能更强；SSE是单向通道，只能服务器向浏览器端发送。</li><li>WebSocket是一个新的协议，需要服务器端支持；SSE则是部署在 HTTP协议之上的，现有的服务器软件都支持。</li><li>SSE是一个轻量级协议，相对简单；WebSocket是一种较重的协议，相对复杂。</li><li>SSE默认支持断线重连，WebSocket则需要额外部署。</li><li>SSE支持自定义发送的数据类型。</li><li>SSE不支持CORS 参数url就是服务器网址，必须与当前网页的网址在同一个网域（domain），而且协议和端口都必须相同。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Web Worker</title>
    <link href="/2020/07/14/notes/web/HTML/Web%20Worker/"/>
    <url>/2020/07/14/notes/web/HTML/Web%20Worker/</url>
    
    <content type="html"><![CDATA[<p>web worker 是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能。</p><h2 id="检测浏览器是否支持-Web-Worker"><a href="#检测浏览器是否支持-Web-Worker" class="headerlink" title="检测浏览器是否支持 Web Worker"></a>检测浏览器是否支持 Web Worker</h2><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span>(Worker)!==<span class="hljs-string">"undefined"</span>)&#123;    <span class="hljs-comment">// 是的! Web worker 支持!</span>    <span class="hljs-comment">// 一些代码.....</span>&#125;<span class="hljs-keyword">else</span>&#123;    <span class="hljs-comment">//抱歉! Web Worker 不支持</span>&#125;</code></pre></div><h2 id="创建-web-worker-文件"><a href="#创建-web-worker-文件" class="headerlink" title="创建 web worker 文件"></a>创建 web worker 文件</h2><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// demo_workers.js</span><span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">timedCount</span>(<span class="hljs-params"></span>)</span><span class="hljs-function"></span>&#123;    i=i+<span class="hljs-number">1</span>;    <span class="hljs-comment">//postMessage() 方法用于向 HTML 页面传回一段消息。</span>    postMessage(i);    setTimeout(<span class="hljs-string">"timedCount()"</span>,<span class="hljs-number">500</span>);&#125;timedCount()</code></pre></div><h2 id="创建-Web-Worker-对象"><a href="#创建-Web-Worker-对象" class="headerlink" title="创建 Web Worker 对象"></a>创建 Web Worker 对象</h2><div class="hljs"><pre><code class="hljs js">w=<span class="hljs-keyword">new</span> Worker(<span class="hljs-string">"demo_workers.js"</span>);w.onmessage=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>)</span>&#123;    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"result"</span>).innerHTML=event.data;&#125;;</code></pre></div><h2 id="终止-Web-Worker"><a href="#终止-Web-Worker" class="headerlink" title="终止 Web Worker"></a>终止 Web Worker</h2><div class="hljs"><pre><code class="hljs js">w.terminate();w = <span class="hljs-literal">null</span>;</code></pre></div><h2 id="Web-Workers-和-DOM"><a href="#Web-Workers-和-DOM" class="headerlink" title="Web Workers 和 DOM"></a>Web Workers 和 DOM</h2><p>由于 web worker 位于外部文件中，它们无法访问下列 JavaScript 对象：</p><ul><li>window 对象</li><li>document 对象</li><li>parent 对象</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Web Components</title>
    <link href="/2020/07/14/notes/web/HTML/Web%20Components/"/>
    <url>/2020/07/14/notes/web/HTML/Web%20Components/</url>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.im/post/5badfc53f265da0af77527b8#heading-12" target="_blank" rel="noopener">https://juejin.im/post/5badfc53f265da0af77527b8#heading-12</a></p><p>Web Components本身不是一个规范，而是由W3C提出的另外4个规范的合集。这四个规范是：</p><ul><li>HTML Template</li><li>HTML Imports</li><li>Shadow DOM</li><li>Custom Elements</li></ul><h2 id="HTML-Template"><a href="#HTML-Template" class="headerlink" title="HTML Template"></a>HTML Template</h2><p>通过<code>&lt;template&gt;</code>标签存放模板</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"mytemplate"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">""</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">"great image"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"comment"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></code></pre></div><h3 id="是否支持"><a href="#是否支持" class="headerlink" title="是否支持"></a>是否支持</h3><p>检查<code>&lt;template&gt;</code>是否拥有 content 属性</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">supportsTemplate</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">'content'</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'template'</span>);&#125;<span class="hljs-keyword">if</span> (supportsTemplate()) &#123;    <span class="hljs-comment">// 检测通过！</span>&#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">// 使用旧的模板技术或库。</span>&#125;</code></pre></div><h3 id="激活模板"><a href="#激活模板" class="headerlink" title="激活模板"></a>激活模板</h3><p>即渲染出模板里面的内容。激活模板最简单的方法就是使用 <code>document.importNode()</code>对模板的 <code>.content</code> 进行深拷贝。</p><p><code>.content</code> 为只读属性，关联一个包含模板内容的 DocumentFragment。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> t = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'#mytemplate'</span>);<span class="hljs-comment">// 在运行时填充 src。</span>t.content.querySelector(<span class="hljs-string">'img'</span>).src = <span class="hljs-string">'logo.png'</span>;<span class="hljs-keyword">var</span> clone = <span class="hljs-built_in">document</span>.importNode(t.content, <span class="hljs-literal">true</span>);<span class="hljs-built_in">document</span>.body.appendChild(clone);</code></pre></div><h2 id="HTML-Imports"><a href="#HTML-Imports" class="headerlink" title="HTML Imports"></a>HTML Imports</h2><p>之前在页面引入另一个页面或片段往往是通过<code>iframe</code>或者<code>ajax</code>异步加载，而现在我们可以这样做：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"import"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/path/to/imports/stuff.html"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">    <span class="hljs-keyword">var</span> content = document.querySelector(<span class="hljs-string">'link[rel="import"]'</span>)<span class="hljs-meta">.<span class="hljs-meta-keyword">import</span>;</span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><h3 id="是否支持-1"><a href="#是否支持-1" class="headerlink" title="是否支持"></a>是否支持</h3><p>可验证 <code>&lt;link&gt;</code> 元素上是否存在 import：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">supportsImports</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">'import'</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'link'</span>);&#125;<span class="hljs-keyword">if</span> (supportsImports()) &#123;    <span class="hljs-comment">// 支持导入</span>&#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">// 使用其他方法加载文件</span>&#125;</code></pre></div><h2 id="Shadow-DOM"><a href="#Shadow-DOM" class="headerlink" title="Shadow DOM"></a>Shadow DOM</h2><h2 id="Custom-Elements"><a href="#Custom-Elements" class="headerlink" title="Custom Elements"></a>Custom Elements</h2><p>自定义元素，首先有个硬性规定，自定义元素的命名中必须要有中划线“<code>-</code>”，否则便是未知元素了。</p><p>自定义元素分为两种:</p><ul><li>自主自定义元素</li><li>自定义内置元素</li></ul><h3 id="自特性主自定义元素-Autonomous-custom-elements"><a href="#自特性主自定义元素-Autonomous-custom-elements" class="headerlink" title="自特性主自定义元素(Autonomous custom elements)"></a>自特性主自定义元素(Autonomous custom elements)</h3><p>不具备任何已有元素的，其样式和行为完全自定义，如我们要定义一个这样的元素：</p><p><code>&lt;flag-icon country=&quot;cn&quot;&gt;&lt;/flag-icon&gt;</code></p><div class="hljs"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlagIcon</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HTMLElement</span> </span>&#123;    <span class="hljs-keyword">constructor</span>() &#123;      <span class="hljs-keyword">super</span>();      <span class="hljs-keyword">this</span>._countryCode = <span class="hljs-literal">null</span>;    &#125;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">get</span> observedAttributes() &#123; <span class="hljs-keyword">return</span> [<span class="hljs-string">"country"</span>]; &#125;    attributeChangedCallback(name, oldValue, newValue) &#123;      <span class="hljs-comment">// name will always be "country" due to observedAttributes</span>      <span class="hljs-keyword">this</span>._countryCode = newValue;      <span class="hljs-keyword">this</span>._updateRendering();    &#125;    connectedCallback() &#123;      <span class="hljs-keyword">this</span>._updateRendering();    &#125;    <span class="hljs-keyword">get</span> country() &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._countryCode;    &#125;    <span class="hljs-keyword">set</span> country(v) &#123;      <span class="hljs-keyword">this</span>.setAttribute(<span class="hljs-string">"country"</span>, v);    &#125;    _updateRendering() &#123;      <span class="hljs-comment">//...</span>    &#125;&#125;<span class="hljs-comment">//全局注册该元素</span>customElements.define(<span class="hljs-string">"flag-icon"</span>, FlagIcon);</code></pre></div><h3 id="自定义内置元素-Customized-built-in-elements"><a href="#自定义内置元素-Customized-built-in-elements" class="headerlink" title="自定义内置元素(Customized built-in elements)"></a>自定义内置元素(Customized built-in elements)</h3><p>继承自已有元素，拥有已有元素的所有特性。</p><p>比如我们自定义一个按钮，集成普通按钮所有的特性，但是当点击的时候会有一个动效，就可以这么做:</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PlasticButton</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HTMLButtonElement</span> </span>&#123;    <span class="hljs-keyword">constructor</span>() &#123;        <span class="hljs-keyword">super</span>();        <span class="hljs-keyword">this</span>.addEventListener(<span class="hljs-string">"click"</span>, () =&gt; &#123;            <span class="hljs-comment">// 动效逻辑</span>        &#125;);    &#125;&#125;</code></pre></div><p>不同的是，注册时要加上一个参数</p><div class="hljs"><pre><code class="hljs js">customElements.define(<span class="hljs-string">"plastic-button"</span>, PlasticButton, &#123; <span class="hljs-attr">extends</span>: <span class="hljs-string">"button"</span> &#125;);</code></pre></div><p>使用时也稍有不同</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">is</span>=<span class="hljs-string">"plastic-button"</span>&gt;</span>点我!<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Shadow DOM</title>
    <link href="/2020/07/14/notes/web/HTML/Shadow%20DOM/"/>
    <url>/2020/07/14/notes/web/HTML/Shadow%20DOM/</url>
    
    <content type="html"><![CDATA[<p><a href="https://aotu.io/notes/2016/06/24/Shadow-DOM/?o2src=juejin&amp;o2layout=compat" target="_blank" rel="noopener">https://aotu.io/notes/2016/06/24/Shadow-DOM/?o2src=juejin&amp;o2layout=compat</a></p><h2 id="待整理"><a href="#待整理" class="headerlink" title="待整理"></a>待整理</h2><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Shadow DOM它允许在文档（document）渲染时插入一棵DOM元素子树，但是这棵子树不在主DOM树中。</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">controls</span> <span class="hljs-attr">autoplay</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"media"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"500"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"mp4"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"http://7ryl2t.com2.z0.glb.qiniucdn.com/572ffc37a2e5a.mp4"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"video/mp4"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span></code></pre></div><p>在浏览器chrome中打开，然后打开 Chrome 的开发者工具，点击右上角的“Settings”按钮，勾选“Show user agent shadow DOM”。</p><p><img src="http://pic.aizf.ink/md/html/1.jpg" alt="avatar"></p><p><code>#shadow-root</code>称为影子根</p><h2 id="怎样创建Shadow-DOM"><a href="#怎样创建Shadow-DOM" class="headerlink" title="怎样创建Shadow DOM"></a>怎样创建Shadow DOM</h2><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"shadowhost"</span>&gt;</span>Hello, world!<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">        <span class="hljs-comment">// 影子宿主（shadow host）</span></span><span class="javascript">        <span class="hljs-keyword">var</span> shadowHost = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.shadowhost'</span>);</span><span class="actionscript">        <span class="hljs-comment">// 创建影子根（shadow root）</span></span><span class="actionscript">        <span class="hljs-keyword">var</span> shadowRoot = shadowHost.createShadowRoot();</span><span class="actionscript">        <span class="hljs-comment">// 影子根作为影子树的第一个节点，其他的节点比如p节点都是它的子节点。</span></span><span class="handlebars"><span class="xml">        shadowRoot.innerHTML = '<span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"shadowroot_son"</span>&gt;</span>夏天夏天悄悄过去留下小秘密！<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>';</span></span>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></div><p>影子宿主和影子根之间存在<strong>影子边界</strong>（shadow boundary），影子边界保证主 DOM写的 CSS 选择器和 JavaScript 代码都不会影响到Shadow DOM，当然也保护主文档不受 shadow DOM 样式的侵袭。</p>]]></content>
    
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>script</title>
    <link href="/2020/07/14/notes/web/HTML/script/"/>
    <url>/2020/07/14/notes/web/HTML/script/</url>
    
    <content type="html"><![CDATA[<h2 id="async-defer"><a href="#async-defer" class="headerlink" title="async defer"></a>async defer</h2><ul><li>没有 defer 或 async，浏览器会立即加载并执行指定的脚本</li><li>async，异步加载，加载后立即执行</li><li>defer,异步加载，所有元素解析完成之后，DOMContentLoaded 事件触发之前执行</li></ul><p><img src="http://pic.aizf.ink/md/html/2.webp" alt="avatar"></p>]]></content>
    
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>postMessage和onmessage</title>
    <link href="/2020/07/14/notes/web/HTML/postMessage%E5%92%8Conmessage/"/>
    <url>/2020/07/14/notes/web/HTML/postMessage%E5%92%8Conmessage/</url>
    
    <content type="html"><![CDATA[<p>postMessage和onmessage是HTML5的方法，用来解决跨页面通信，或者通过iframe嵌套的不同页面的通信的。</p><p>postMessage为发送方，onmessage为接收方。</p><p><code>otherWindow.postMessage(message, targetOrigin)</code></p><blockquote><p>otherWindow:其它窗口（window）的引用<br>message: 就是传递给iframe的内容, 通常是string</p><p>targetOrigin: 接受你传递消息的域名，可以设置绝对路径，也可以设置<code>&quot;*&quot;</code>或者<code>&quot;/&quot;</code>。 <code>&quot;*&quot;</code>表示任意域名都行，<code>&quot;/&quot;</code>表示只能传递给同域域名。在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配targetOrigin提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>meta,link和script</title>
    <link href="/2020/07/14/notes/web/HTML/meta,link%E5%92%8Cscript/"/>
    <url>/2020/07/14/notes/web/HTML/meta,link%E5%92%8Cscript/</url>
    
    <content type="html"><![CDATA[<h2 id="1-meta"><a href="#1-meta" class="headerlink" title="1 meta"></a>1 meta</h2><p>可提供有关页面的元信息(meta-information),比如针对搜索引擎和更新频度的描述和关键词。</p><h3 id="1-1-常用"><a href="#1-1-常用" class="headerlink" title="1.1 常用"></a>1.1 常用</h3><p>设置编码格式</p><p><code>&lt;meta charset=&#39;utf-8&#39;&gt;</code></p><p>设置关键字</p><p><code>&lt;meta name=&quot;keywords&quot; content=&quot;音乐 播放器 H5&quot;&gt;</code></p><p>设置描述</p><p><code>&lt;meta name=&quot;description&quot; content=&quot;用H5实现音乐播放器控件&quot;&gt;</code></p><p><code>viewport</code> 可以让布局在移动端的浏览器上更好的显示</p><p><code>width = device-width</code> 布局宽度等于设备宽度</p><p><code>intial-scale</code>:页面首次被显示是可视区域的缩放级别，取值1.0则页面按实际尺寸显示，无任何缩放</p><p><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0,maximum-scale=1.0, minimum-scale=1.0,user-scalable=no&quot;&gt;</code></p><p>IE 支持通过特定的 <code>&lt;meta&gt;</code> 标签来确定绘制当前页面所应该采用的 IE 版本。除非有强烈的特殊需求，否则最好是设置为<code>edge mode</code>，从而通知IE采用其所支持的最新的模式。</p><p><code>&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge&quot;&gt;</code></p><h2 id="2-link"><a href="#2-link" class="headerlink" title="2 link"></a>2 link</h2><p><code>&lt;link&gt;</code> 标签定义文档与外部资源的关系。</p><p>此元素只能存在于 <code>head</code> 部分，不过它可出现任何次数。</p><p>不会阻塞dom tree的生成，但是会阻塞paint（也有可能是render tree）(阻止了css tree)</p><h3 id="2-2-常用"><a href="#2-2-常用" class="headerlink" title="2.2 常用"></a>2.2 常用</h3><p>浏览器左上角图标</p><p><code>&lt;link rel=&#39;icon&#39; href=&#39;1.ico&#39;&gt;</code></p><p>引入css文件路径</p><p><code>&lt;link rel=&#39;stylesheet&#39; type=&#39;text/css&#39; href=&#39;&#39;&gt;</code></p><h2 id="3-script"><a href="#3-script" class="headerlink" title="3 script"></a>3 script</h2><p>直接codeing js代码</p><p><code>&lt;script type=&#39;text/javascript&#39;&gt;&lt;/script&gt;</code></p><p>引入js文件</p><p><code>&lt;script src=&#39;&#39;&gt;&lt;/script&gt;</code></p><h3 id="3-1-属性"><a href="#3-1-属性" class="headerlink" title="3.1 属性"></a>3.1 属性</h3><h4 id="type指示脚本的-MIME-类型"><a href="#type指示脚本的-MIME-类型" class="headerlink" title="type指示脚本的 MIME 类型"></a><code>type</code>指示脚本的 MIME 类型</h4><h4 id="async规定异步执行脚本（仅适用于外部脚本）"><a href="#async规定异步执行脚本（仅适用于外部脚本）" class="headerlink" title="async规定异步执行脚本（仅适用于外部脚本）"></a><code>async</code>规定异步执行脚本（仅适用于外部脚本）</h4><p><code>async</code>的执行，并不会按着script在页面中的顺序来执行，而是谁先加载完谁执行。</p><p><code>DOMContentLoaded</code>事件的触发并不受<code>async</code>脚本加载的影响，在脚本加载完之前，就已经触发了<code>DOMContentLoaded</code>。</p><blockquote><p><code>DOMContentLoaded</code> 事件：当初始的 HTML 文档被完全加载和解析完成之后，<code>DOMContentLoaded</code> 事件被触发，而无需等待样式表、图像和子框架的完成加载。</p></blockquote><p><strong>应用场景</strong>:脚本并不关心页面中的DOM元素,也不被依赖</p><h4 id="defer规定是否对脚本执行进行延迟，直到页面加载为止"><a href="#defer规定是否对脚本执行进行延迟，直到页面加载为止" class="headerlink" title="defer规定是否对脚本执行进行延迟，直到页面加载为止"></a><code>defer</code>规定是否对脚本执行进行延迟，直到页面加载为止</h4><p><code>defer</code>脚本会在文档渲染完毕后，DOMContentLoaded事件调用前执行。</p><p><strong>应用场景</strong>:脚本代码依赖于页面中的DOM元素,或者被其他脚本文件依赖</p><p><code>async</code>和<code>defer</code>，这两个属性使得script都不会阻塞DOM的渲染</p><h4 id="src外部脚本文件的-URL"><a href="#src外部脚本文件的-URL" class="headerlink" title="src外部脚本文件的 URL"></a><code>src</code>外部脚本文件的 URL</h4><h3 id="3-2-异步加载-defer、async、module-和预加载-preload、prefetch、dns-prefetch、preconnect-、prerender"><a href="#3-2-异步加载-defer、async、module-和预加载-preload、prefetch、dns-prefetch、preconnect-、prerender" class="headerlink" title="3.2 异步加载(defer、async、module)和预加载(preload、prefetch、dns-prefetch、preconnect 、prerender)"></a>3.2 异步加载(defer、async、module)和预加载(preload、prefetch、dns-prefetch、preconnect 、prerender)</h3><h4 id="3-2-1-module"><a href="#3-2-1-module" class="headerlink" title="3.2.1 module"></a>3.2.1 module</h4><ul><li>默认使用了”use strict”模式</li><li>模块只会加载一次，无论前后你写了多少次。</li><li>不支持&lt;!–const a = 1–&gt;注释。</li><li>module有自己的词法作用域，比如定义一个 var a = 1，并不会创建一个全局变量，因此你并不能通过window.a 访问到它的值。</li></ul><h4 id="3-2-2-preload"><a href="#3-2-2-preload" class="headerlink" title="3.2.2 preload"></a>3.2.2 preload</h4><p>preload翻译过来就是预加载，一旦启用后便会告知浏览器应该尽快的加载某个资源，如果提取的资源3s内未在当前使用，在谷歌开发工具将会触发警告消息</p><h4 id="3-2-3-prefetch"><a href="#3-2-3-prefetch" class="headerlink" title="3.2.3 prefetch"></a>3.2.3 prefetch</h4><p>简而言之预提取就是在我们页面加载完成后，在带宽可用的情况下，加载用户下一步期待的页面资源</p>]]></content>
    
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>link标签</title>
    <link href="/2020/07/14/notes/web/HTML/link/"/>
    <url>/2020/07/14/notes/web/HTML/link/</url>
    
    <content type="html"><![CDATA[<h2 id="preload-prefetch和preconnect"><a href="#preload-prefetch和preconnect" class="headerlink" title="preload,  prefetch和preconnect"></a>preload,  prefetch和preconnect</h2><p><a href="https://juejin.im/post/5b5984b851882561da216311" target="_blank" rel="noopener">https://juejin.im/post/5b5984b851882561da216311</a></p><p>浏览器预加载<strong>只预先加载在HTML中声明的资源</strong>。preload 指令事实上克服了这个限制并且<strong>允许预加载在 CSS 和JavaScript 中定义的资源</strong>，并允许决定何时应用每个资源。</p><h3 id="prefetch"><a href="#prefetch" class="headerlink" title="prefetch"></a>prefetch</h3><p>低优先级的资源提示，允许浏览器在后台（空闲时）获取将来可能用得到的资源，并且将他们存储在浏览器的缓存中。</p><p>有三种不同的 prefetch 的类型，link，DNS 和 prerendering</p><p>DNS 请求在带宽方面流量非常小，可是延迟会很高，尤其是在移动设备上。通过 prefetching 指定的 DNS 可以在特定的场景显著的减小延迟</p><p>prerendering 在后台渲染了整个页面，整个页面所有的资源。要小心的使用 prerender，因为它将会加载很多资源并且可能造成带宽的浪费，尤其是在移动设备上。</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"prefetch"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/uploads/images/pic.png"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"dns-prefetch"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"//fonts.googleapis.com"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"prerender"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://www.keycdn.com"</span>&gt;</span></code></pre></div><h3 id="preload"><a href="#preload" class="headerlink" title="preload"></a>preload</h3><p>可以指明哪些资源是在页面加载完成后即刻需要的,不会阻塞 <code>window</code> 的 <code>onload</code> 事件。</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"preload"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"style.css"</span> <span class="hljs-attr">as</span>=<span class="hljs-string">"style"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"preload"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"main.js"</span> <span class="hljs-attr">as</span>=<span class="hljs-string">"script"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"preload"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://example.com/fonts/font.woff"</span> <span class="hljs-attr">as</span>=<span class="hljs-string">"font"</span> <span class="hljs-attr">crossorigin</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"preload"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"image.png"</span>&gt;</span></code></pre></div><h3 id="preconnect"><a href="#preconnect" class="headerlink" title="preconnect"></a>preconnect</h3><p>允许浏览器在一个 HTTP 请求正式发给服务器前预先执行一些操作，这包括 DNS 解析，TLS 协商，TCP 握手，这消除了往返延迟并为用户节省了时间。</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://cdn.domain.com"</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"preconnect"</span> <span class="hljs-attr">crossorigin</span>&gt;</span></code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>img标签相关</title>
    <link href="/2020/07/14/notes/web/HTML/img/"/>
    <url>/2020/07/14/notes/web/HTML/img/</url>
    
    <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/img" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/img</a></p><h2 id="支持类型"><a href="#支持类型" class="headerlink" title="支持类型"></a>支持类型</h2><p>常用：</p><ul><li>image/bmp</li><li>image/gif</li><li>image/jpeg</li><li>image/png</li><li>image/svg+xml</li><li>image/webp</li></ul><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p><code>src</code>：图片的文件路径</p><p><code>alt</code>：备用文本描述</p><p><code>width</code>:图像的宽度,在 HTML5 中单位是 CSS 像素</p><p>可以只指定 width 和 height 中的一个值，浏览器会根据原始图像进行缩放。</p><p><code>height</code>:图像的高度在 HTML5 中单位是 CSS 像素</p><p><code>onerror</code>:加载或渲染图像时发生错误时调用，包括以下情况：</p><ul><li>src 属性的属性值为空（<code>&quot;&quot;</code>）或者 <code>null</code>。</li><li>src 属性的 URL 和用户正在浏览的页面的 URL 完全相同。</li><li>图像出于某些原因损坏了，从而无法加载。</li><li>图像的元数据被破坏了，无法检索它的分辨率/宽高，而且在 <code>&lt;img&gt;</code> - 元素的属性中没有指定宽度和/或高度。</li><li>用户代理尚未支持该图片所用的格式。</li></ul><p><code>crossorigin</code>：表明是否必须使用 CORS 完成相关图像的抓取。启用 CORS 的图像 可以在 <code>&lt;canvas&gt;</code> 元素中重复使用，而不会被污染（tainted）。默认不使用 CORS 发起请求</p><p>允许的值有：</p><ul><li>anonymous,执行一个跨域请求</li><li>use-credentials,一个有证书的跨域请求。如果服务器没有给源站发送证书（通过 Access-Control-Allow-Credentials HTTP header），图像将会被污染，且它的使用会受限制。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iframe相关</title>
    <link href="/2020/07/14/notes/web/HTML/iframe%E7%9B%B8%E5%85%B3/"/>
    <url>/2020/07/14/notes/web/HTML/iframe%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<p>把iframe解释成“浏览器中的浏览器“是很恰当的。iframe可以嵌在网页中的任意部分。</p><h2 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h2><p><code>src</code></p><blockquote><p><code>&lt;iframe src=&quot;https://www.baidu.com/&quot;&gt;&lt;/iframe&gt;</code>,指定iframe调用的文件或图片(html,htm,gif,jpeg,jpg,png,txt,<em>.</em>)</p></blockquote><p><code>name</code></p><blockquote><p>框架的名称，<code>window.frames[name]</code>时专用的属性</p></blockquote><p><code>scrolling</code></p><blockquote><p>是否有滚动条（yes,no,auto）</p></blockquote><p><code>&lt;iframe height=&quot;31&quot; width=&quot;88&quot;&gt;&lt;/iframe&gt;</code></p><blockquote><p>边框的宽度和高度</p></blockquote><p><code>frameborder</code></p><blockquote><p>是否显示边框（0无边框 1有边框(默认)）</p></blockquote><p><code>allowtransparency</code></p><blockquote><p>背景是否透明 （yes透明 no不透明）</p></blockquote><p><code>sandbox</code></p><blockquote><p>对iframe进行一些列限制，IE10+支持</p></blockquote><p>同域，父页面可以对子页面进行改写</p><p>不同域，父页面没有权限改动子页面,但可以实现页面的跳转</p><h2 id="同域时"><a href="#同域时" class="headerlink" title="同域时"></a>同域时</h2><h3 id="获取iframe里的内容"><a href="#获取iframe里的内容" class="headerlink" title="获取iframe里的内容"></a>获取iframe里的内容</h3><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> iframe = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"iframe1"</span>);<span class="hljs-comment">// iframe的window对象</span><span class="hljs-keyword">var</span> iwindow = iframe.contentWindow;<span class="hljs-built_in">window</span>.frames[<span class="hljs-string">'ifr1'</span>].window<span class="hljs-comment">// iframe的document对象</span><span class="hljs-keyword">var</span> idoc = iwindow.document;</code></pre></div><h3 id="在iframe中获取父级内容"><a href="#在iframe中获取父级内容" class="headerlink" title="在iframe中获取父级内容"></a>在iframe中获取父级内容</h3><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">window</span>.parent   <span class="hljs-comment">//获取上一级的window对象，如果还是iframe则是该iframe的window对象</span><span class="hljs-built_in">window</span>.top  <span class="hljs-comment">// 获取最顶级容器的window对象，即，就是你打开页面的文档</span><span class="hljs-built_in">window</span>.self <span class="hljs-comment">// 返回自身window的引用。可以理解 window===window.self(脑残)</span></code></pre></div><h2 id="iframe的轮询"><a href="#iframe的轮询" class="headerlink" title="iframe的轮询"></a>iframe的轮询</h2><h2 id="iframe安全性"><a href="#iframe安全性" class="headerlink" title="iframe安全性"></a>iframe安全性</h2><p>有两个方面:</p><ul><li>你的网页被别人iframe</li><li>你iframe别人的网页</li></ul><h3 id="防嵌套网页"><a href="#防嵌套网页" class="headerlink" title="防嵌套网页"></a>防嵌套网页</h3><p>最出名的clickhacking就是使用iframe来 拦截click事件。因为iframe享有着click的最优先权，当有人在伪造的主页中进行点击的话，如果点在iframe上，则会默认是在操作iframe的页面。</p><p>限定你的网页不能嵌套在任意网页内:</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">if</span>(<span class="hljs-built_in">window</span> != <span class="hljs-built_in">window</span>.top)&#123;    <span class="hljs-built_in">window</span>.top.location.href = correctURL;&#125;</code></pre></div><h3 id="X-Frame-Options"><a href="#X-Frame-Options" class="headerlink" title="X-Frame-Options"></a>X-Frame-Options</h3><p><code>X-Frame-Options</code>是一个相应头，主要是描述服务器的网页资源的<code>iframe</code>权限。目前的支持度是IE8+</p><ul><li><code>DENY</code>：当前页面不能被嵌套iframe里，即便是在相同域名的页面中嵌套也不允许,也不允许网页中有嵌套iframe</li><li><code>SAMEORIGIN</code>：iframe页面的地址只能为同源域名下的页面</li><li><code>ALLOW-FROM</code>：可以在指定的origin url的iframe中加载</li></ul><h2 id="解决跨域"><a href="#解决跨域" class="headerlink" title="解决跨域"></a>解决跨域</h2><h3 id="主域相同而子域不同的跨域"><a href="#主域相同而子域不同的跨域" class="headerlink" title="主域相同而子域不同的跨域"></a>主域相同而子域不同的跨域</h3><p>对于主域相同而子域不同的跨域,可以使用<code>iframe</code>进行解决。</p><p>默认情况下<code>document.domain</code> 是指<code>window.location.hostname</code>,可以手动更改，但是最多只能设置为主域名。</p><p>对于<code>http: //www.foo.com/a.html</code>和<code>http: //script.foo.com/b.html</code>,两个文件中分别加上<code>document.domain = &quot;foo.com&quot;</code>,指定相同的主域，然后,两个文档就可以进行交互。</p><h3 id="域名完全不同"><a href="#域名完全不同" class="headerlink" title="域名完全不同"></a>域名完全不同</h3><ul><li>发送消息: 使用postmessage方法,异步方式进行有限的通信</li><li>接受消息: 监听message事件</li></ul><p>需要拥有另一个页面的<code>window</code>对象</p><p><code>otherWindow.postMessage(message, targetOrigin)</code></p><blockquote><p>otherWindow:其它窗口（window）的引用<br>message: 就是传递给iframe的内容, 通常是string</p><p>targetOrigin: 接受你传递消息的域名，可以设置绝对路径，也可以设置<code>&quot;*&quot;</code>或者<code>&quot;/&quot;</code>。 <code>&quot;*&quot;</code>表示任意域名都行，<code>&quot;/&quot;</code>表示只能传递给同域域名。在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配targetOrigin提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。</p></blockquote><p>当targetOrigin接受到message消息之后,会触发message事件。</p><p>message提供的event对象上有3个重要的属性，data,origin,source.</p><ul><li>data：postMessage传递进来的值</li><li>origin：发送消息的文档所在的域</li><li>source：发送消息文档的window对象的代理，如果是来自同一个域，则该对象就是window，可以使用其所有方法，如果是不同的域，则window只能调用postMessage()方法返回信息</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>document.ready和window.onload的区别</title>
    <link href="/2020/07/14/notes/web/HTML/document.ready%E5%92%8Cwindow.onload%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2020/07/14/notes/web/HTML/document.ready%E5%92%8Cwindow.onload%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>都是在都是在页面加载完执行的函数</p><p><code>document.ready</code>:DOM树加载完毕，就执行，不必等到页面中图片或其他外部文件都加载完毕。并且可以写多个.ready。</p><p><code>window.onload</code>:是页面所有元素都加载完毕，包括图片等所有元素。只能执行一次。</p>]]></content>
    
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sass学习笔记</title>
    <link href="/2020/07/14/notes/web/CSS/Sass/%E5%9F%BA%E6%9C%AC/"/>
    <url>/2020/07/14/notes/web/CSS/Sass/%E5%9F%BA%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.sass.hk/guide/" target="_blank" rel="noopener">https://www.sass.hk/guide/</a></p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>sass使用<code>$</code>符号来标识变量</p><h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><div class="hljs"><pre><code class="hljs sass">$highlight-color: #F90;$highlight-border: 1px solid $highlight-color;.selected &#123;  border: $highlight-border;&#125;$basic-border: 1px solid black;</code></pre></div><p>变量可以在css规则块定义之外存在。</p><p>当变量定义在css规则块内，那么该变量只能在此规则块内使用。</p><p>在sass的大 多数地方，中划线(-)命名的内容和下划线(_)命名的内容是互通的</p><h2 id="嵌套CSS-规则"><a href="#嵌套CSS-规则" class="headerlink" title="嵌套CSS 规则"></a>嵌套CSS 规则</h2><div class="hljs"><pre><code class="hljs sass">#content &#123;  article &#123;    h1 &#123; color: #333 &#125;    p &#123; margin-bottom: 1.4em &#125;  &#125;  aside &#123; background-color: #EEE &#125;&#125;</code></pre></div><h3 id="父选择器的标识符-amp"><a href="#父选择器的标识符-amp" class="headerlink" title="父选择器的标识符&amp;"></a>父选择器的标识符&amp;</h3><div class="hljs"><pre><code class="hljs sass">article a &#123;  color: blue;  :hover &#123; color: red &#125;&#125;&#x2F;* &#x3D;&gt; *&#x2F;article a &#123;  color: blue;&#125;article a :hover &#123;  color: red;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs sass">article a &#123;  color: blue;  &amp;:hover &#123; color: red &#125;&#125;&#x2F;* &#x3D;&gt; *&#x2F;article a &#123;  color: blue;&#125;article a:hover &#123;  color: red;&#125;</code></pre></div><h3 id="群组选择器的嵌套"><a href="#群组选择器的嵌套" class="headerlink" title="群组选择器的嵌套"></a>群组选择器的嵌套</h3><p><strong>注意：</strong>群组选择器的规则嵌套生成的css。虽然sass让你的样式表看上去很小，但实际生成的css却可能非常大，这会降低网站的速度。</p><div class="hljs"><pre><code class="hljs sass">.container &#123;  h1, h2, h3 &#123;margin-bottom: .8em&#125;&#125;nav,aside &#123;  a &#123;    color: blue  &#125;&#125;</code></pre></div><h3 id="子组合选择器和同层组合选择器：-gt-、-和"><a href="#子组合选择器和同层组合选择器：-gt-、-和" class="headerlink" title="子组合选择器和同层组合选择器：&gt;、+和~"></a>子组合选择器和同层组合选择器：&gt;、+和~</h3><div class="hljs"><pre><code class="hljs sass">article &#123;  ~ article &#123; border-top: 1px dashed #ccc &#125;  &gt; section &#123; background: #eee &#125;  dl &gt; &#123;    dt &#123; color: #333 &#125;    dd &#123; color: #555 &#125;  &#125;  nav + &amp; &#123; margin-top: 0 &#125;&#125;</code></pre></div><h3 id="嵌套属性"><a href="#嵌套属性" class="headerlink" title="嵌套属性"></a>嵌套属性</h3><p>在sass中，除了CSS选择器，属性也可以进行嵌套。</p><p>加<code>:</code></p><div class="hljs"><pre><code class="hljs sass">nav &#123;  border: &#123;  style: solid;  width: 1px;  color: #ccc;  &#125;&#125;&#x2F;* &#x3D;&gt; *&#x2F;nav &#123;  border-style: solid;  border-width: 1px;  border-color: #ccc;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs sass">nav &#123;  border: 1px solid #ccc &#123;  left: 0px;  right: 0px;  &#125;&#125;&#x2F;* &#x3D;&gt; *&#x2F;nav &#123;  border: 1px solid #ccc;  border-left: 0px;  border-right: 0px;&#125;</code></pre></div><h2 id="导入SASS文件"><a href="#导入SASS文件" class="headerlink" title="导入SASS文件"></a>导入SASS文件</h2><p>sass也有一个<code>@import</code>规则，但不同的是，sass的<code>@import</code>规则在生成css文件时就把相关文件导入进来。</p><p>这意味着所有相关的样式被<strong>归纳到了同一个css文件中</strong>，而<strong>无需发起额外的下载请求</strong>。</p><p>使用sass的@import规则并不需要指明被导入文件的全名。你可以省略.sass或.scss文件后缀</p><h3 id="使用SASS部分文件"><a href="#使用SASS部分文件" class="headerlink" title="使用SASS部分文件"></a>使用SASS部分文件</h3><p>sass<strong>局部文件</strong>的文件名以下划线开头。</p><p>这样，sass就不会在编译时单独编译这个文件输出css，而只把这个文件用作导入。</p><p>当你<code>@import</code>一个局部文件时，还可以不写文件的全名，即省略文件名开头的下划线。</p><p>局部文件可以被多个不同的文件引用。</p><h3 id="默认变量值"><a href="#默认变量值" class="headerlink" title="默认变量值"></a>默认变量值</h3><p>你可能希望导入者可以定制修改sass库文件中的某些值。使用sass的!default标签可以实现这个目的。</p><p>!default用于变量, 像css属性中!important标签的对立面，含义是：如果这个变量被声明赋值了，那就用它声明的值，否则就用这个默认值。</p><h3 id="嵌套导入"><a href="#嵌套导入" class="headerlink" title="嵌套导入"></a>嵌套导入</h3><div class="hljs"><pre><code class="hljs sass">.blue-theme &#123;@import &quot;blue-theme&quot;&#125;</code></pre></div><h3 id="原生的CSS导入"><a href="#原生的CSS导入" class="headerlink" title="原生的CSS导入"></a>原生的CSS导入</h3><p>会造成浏览器阻塞</p><p>下列三种情况下会生成原生的CSS@import</p><ul><li>被导入文件的名字以.css结尾；</li><li>被导入文件的名字是一个URL地址（比如<a href="http://www.sass.hk/css/css.css），由此可用谷歌字体API提供的相应服务；" target="_blank" rel="noopener">http://www.sass.hk/css/css.css），由此可用谷歌字体API提供的相应服务；</a></li><li>被导入文件的名字是CSS的url()值。</li></ul><p>可以把原始的css文件改名为.scss后缀，即可直接导入。</p><h2 id="静默注释"><a href="#静默注释" class="headerlink" title="静默注释"></a>静默注释</h2><div class="hljs"><pre><code class="hljs sass">&#x2F;&#x2F; 这种注释内容不会出现在生成的css文件中&#x2F;* 这种注释内容会出现在生成的css文件中 *&#x2F;</code></pre></div><h2 id="混合器"><a href="#混合器" class="headerlink" title="混合器"></a>混合器</h2><p>混合器使用<code>@mixin</code>标识符定义</p><p>通过<code>@include</code>来使用这个混合器</p><div class="hljs"><pre><code class="hljs sass">@mixin rounded-corners &#123;    -moz-border-radius: 5px;    -webkit-border-radius: 5px;    border-radius: 5px;&#125;notice &#123;    background-color: green;    border: 2px solid #00aa00;    @include rounded-corners;&#125;</code></pre></div><p>转换为=&gt;</p><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.notice</span> &#123;  <span class="hljs-attribute">background-color</span>: green;  <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid <span class="hljs-number">#00aa00</span>;  <span class="hljs-attribute">-moz-border-radius</span>: <span class="hljs-number">5px</span>;  <span class="hljs-attribute">-webkit-border-radius</span>: <span class="hljs-number">5px</span>;  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">5px</span>;&#125;</code></pre></div><h3 id="何时使用混合器"><a href="#何时使用混合器" class="headerlink" title="何时使用混合器"></a>何时使用混合器</h3><p>重复的一段样式</p><h3 id="混合器中的CSS规则"><a href="#混合器中的CSS规则" class="headerlink" title="混合器中的CSS规则"></a>混合器中的CSS规则</h3><h3 id="给混合器传参"><a href="#给混合器传参" class="headerlink" title="给混合器传参"></a>给混合器传参</h3><div class="hljs"><pre><code class="hljs sass">@mixin link-colors($normal, $hover, $visited) &#123;  color: $normal;  &amp;:hover &#123; color: $hover; &#125;  &amp;:visited &#123; color: $visited; &#125;&#125;a &#123;  @include link-colors(blue, red, green);&#125;&#x2F;&#x2F;Sass最终生成的是：a &#123; color: blue; &#125;a:hover &#123; color: red; &#125;a:visited &#123; color: green; &#125;</code></pre></div><h3 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a>默认参数值</h3><div class="hljs"><pre><code class="hljs sass">@mixin link-colors(    $normal,    $hover: $normal,    $visited: $normal  )&#123;  color: $normal;  &amp;:hover &#123; color: $hover; &#125;  &amp;:visited &#123; color: $visited; &#125;&#125;</code></pre></div><h2 id="使用选择器继承来精简CSS"><a href="#使用选择器继承来精简CSS" class="headerlink" title="使用选择器继承来精简CSS"></a>使用选择器继承来精简CSS</h2>]]></content>
    
    
    
    <tags>
      
      <tag>sass</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高度塌陷</title>
    <link href="/2020/07/14/notes/web/CSS/%E9%AB%98%E5%BA%A6%E5%A1%8C%E9%99%B7/"/>
    <url>/2020/07/14/notes/web/CSS/%E9%AB%98%E5%BA%A6%E5%A1%8C%E9%99%B7/</url>
    
    <content type="html"><![CDATA[<p>clear属性不允许被清除浮动的元素的左边/右边挨着浮动元素，<strong>底层原理是在被清除浮动的元素上边或者下边添加足够的清除空间</strong>。</p><h2 id="成因"><a href="#成因" class="headerlink" title="成因"></a>成因</h2><h2 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h2><ul><li>BFC</li><li>末尾增加一个清除浮动的子元素（通过该子元素撑开底部）</li><li>容器添加<code>::after</code>（伪元素在DOM内，因此<code>::after</code>在容器末尾）</li></ul><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span><span class="hljs-selector-pseudo">::after</span>&#123;    <span class="hljs-attribute">content</span>: <span class="hljs-string">""</span>;    <span class="hljs-comment">/* 必须变成block */</span>    <span class="hljs-attribute">display</span>: block;    <span class="hljs-attribute">clear</span>: both;    &#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>css</tag>
      
      <tag>bfc</tag>
      
      <tag>float</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>边距折叠</title>
    <link href="/2020/07/14/notes/web/CSS/%E8%BE%B9%E8%B7%9D%E6%8A%98%E5%8F%A0/"/>
    <url>/2020/07/14/notes/web/CSS/%E8%BE%B9%E8%B7%9D%E6%8A%98%E5%8F%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="父子和兄弟都会折叠"><a href="#父子和兄弟都会折叠" class="headerlink" title="父子和兄弟都会折叠"></a>父子和兄弟都会折叠</h2><p>父子：</p><p>父上子上折叠，父下子下折叠</p><p>兄弟：</p><p>A上和B下折叠</p><h2 id="2个或多个块级相邻元素的外边距（margin）的折叠规则："><a href="#2个或多个块级相邻元素的外边距（margin）的折叠规则：" class="headerlink" title="2个或多个块级相邻元素的外边距（margin）的折叠规则："></a>2个或多个块级相邻元素的外边距（margin）的折叠规则：</h2><ul><li>外边距都为正值时，取最大值</li><li>不全是正值时，则用正值减去（所有值的绝对值中）最大值</li><li>全为负值时，则取最小值</li></ul><h2 id="不发生折叠情况-BFC-："><a href="#不发生折叠情况-BFC-：" class="headerlink" title="不发生折叠情况(BFC)："></a>不发生折叠情况(BFC)：</h2><ul><li>水平（左右）外边距不会折叠</li><li>浮动元素的外边距不会折叠，并且浮动元素与它的子元素之间也不会发生折叠</li><li>设置了overflow且值不为visible的块级元素与它的子元素之间的外边距也不会被折叠</li><li>绝对定位（position:absolute;）元素的margin不与任何margin发生折叠，并且与它的子元素之间的margin也不会发生折叠</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简单层与复合层</title>
    <link href="/2020/07/14/notes/web/CSS/%E7%AE%80%E5%8D%95%E5%B1%82%E4%B8%8E%E5%A4%8D%E5%90%88%E5%B1%82/"/>
    <url>/2020/07/14/notes/web/CSS/%E7%AE%80%E5%8D%95%E5%B1%82%E4%B8%8E%E5%A4%8D%E5%90%88%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<ul><li>可以认为默认只有一个复合图层，所有的DOM节点都是在这个复合图层下的</li><li>如果开启了硬件加速功能，可以将某个节点变成复合图层</li><li>复合图层之间的绘制互不干扰，由GPU直接控制</li><li>而简单图层中，就算是absolute等布局，变化时不影响整体的回流，但是由于在同一个图层中，仍然是会影响绘制的，因此做动画时性能仍然很低。而复合层是独立的，所以一般做动画推荐使用硬件加速</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>水平垂直居中</title>
    <link href="/2020/07/14/notes/web/CSS/%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/"/>
    <url>/2020/07/14/notes/web/CSS/%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/</url>
    
    <content type="html"><![CDATA[<h2 id="1-position"><a href="#1-position" class="headerlink" title="1 position"></a>1 position</h2><p>父<code>position: relative;</code></p><p>子<code>position: absolute;</code></p><h3 id="1-1-设置子left，top50-margin的left，top"><a href="#1-1-设置子left，top50-margin的left，top" class="headerlink" title="1.1 设置子left，top50%,margin的left，top"></a>1.1 设置子left，top50%,margin的left，top</h3><h3 id="1-2-设置left，top50-transform-translate-50-50"><a href="#1-2-设置left，top50-transform-translate-50-50" class="headerlink" title="1.2 设置left，top50%,transform:translate(50%,50%)"></a>1.2 设置left，top50%,transform:translate(50%,50%)</h3><h3 id="1-3"><a href="#1-3" class="headerlink" title="1.3"></a>1.3</h3><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-id">#fa</span> &#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">50%</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">50%</span>;    <span class="hljs-attribute">position</span>: relative;    <span class="hljs-attribute">background</span>: burlywood;&#125;<span class="hljs-selector-id">#ch</span> &#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">50%</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">50%</span>;    <span class="hljs-attribute">position</span>: absolute;    <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;    <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;    <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;    <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;    <span class="hljs-attribute">margin</span>: auto;    <span class="hljs-attribute">background</span>: cornflowerblue;&#125;</code></pre></div><h3 id="1-4-display-flex"><a href="#1-4-display-flex" class="headerlink" title="1.4 display:flex"></a>1.4 display:flex</h3><h3 id="1-5-display-table-cell"><a href="#1-5-display-table-cell" class="headerlink" title="1.5 display:table-cell"></a>1.5 display:table-cell</h3><h3 id="1-6-js计算"><a href="#1-6-js计算" class="headerlink" title="1.6 js计算"></a>1.6 js计算</h3>]]></content>
    
    
    
    <tags>
      
      <tag>css</tag>
      
      <tag>布局</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>替换元素、非替换元素</title>
    <link href="/2020/07/14/notes/web/CSS/%E6%9B%BF%E6%8D%A2%E5%85%83%E7%B4%A0%E3%80%81%E9%9D%9E%E6%9B%BF%E6%8D%A2%E5%85%83%E7%B4%A0/"/>
    <url>/2020/07/14/notes/web/CSS/%E6%9B%BF%E6%8D%A2%E5%85%83%E7%B4%A0%E3%80%81%E9%9D%9E%E6%9B%BF%E6%8D%A2%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="替换元素"><a href="#替换元素" class="headerlink" title="替换元素"></a>替换元素</h2><p>就是浏览器根据其标签的元素属性来判断显示具体的内容的元素，且元素一般拥有固定的尺寸（宽高或宽高比）</p><p>举例说明：img标签根据src来显示内容</p><p>img, input, textarea, select, video 等</p><h2 id="非替换元素"><a href="#非替换元素" class="headerlink" title="非替换元素"></a>非替换元素</h2><p>非替换元素：html中大多数都是非替换元素，他们直接将内容告诉浏览器，直接显示出来。</p><p>div, span, p 等</p>]]></content>
    
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DOM层叠顺序</title>
    <link href="/2020/07/14/notes/web/CSS/%E5%B1%82%E5%8F%A0%E9%A1%BA%E5%BA%8F/"/>
    <url>/2020/07/14/notes/web/CSS/%E5%B1%82%E5%8F%A0%E9%A1%BA%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p><img src="http://pic.aizf.ink/md/css/1.jpg" alt="avatar"></p><p>高度顺序：</p><ol><li>正z-index</li><li><code>z-index:auto</code>或<code>z-index:0</code></li><li>inline/inline-block盒子</li><li>float</li><li>block盒子</li><li>负z-index</li><li>层叠上下文(background/border)</li></ol><p>元素层叠水平相当时的规则：</p><ul><li>后来居上原则</li><li>谁 z-index 大，谁在上的准则</li></ul><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>首先，<code>z-index</code>属性值并不是在任何元素上都有效果。它仅在定位元素（定义了position属性，且属性值为非static值的元素）上有效果。</p>]]></content>
    
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>块级元素,行内元素和行内块状元素</title>
    <link href="/2020/07/14/notes/web/CSS/%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0,%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E5%92%8C%E8%A1%8C%E5%86%85%E5%9D%97%E7%8A%B6%E5%85%83%E7%B4%A0/"/>
    <url>/2020/07/14/notes/web/CSS/%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0,%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E5%92%8C%E8%A1%8C%E5%86%85%E5%9D%97%E7%8A%B6%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="标签分为3种等级"><a href="#标签分为3种等级" class="headerlink" title="标签分为3种等级"></a>标签分为3种等级</h2><p>行内元素 块级元素 行内块状元素</p><h2 id="相互转换"><a href="#相互转换" class="headerlink" title="相互转换"></a>相互转换</h2><p>(1)<code>display:inline;</code>转换为行内元素</p><p>(2)<code>display:block;</code>转换为块状元素</p><p>(3)<code>display:inline-block;</code>转换为行内块状元素</p><h2 id="行内元素和块级元素的区别"><a href="#行内元素和块级元素的区别" class="headerlink" title="行内元素和块级元素的区别"></a>行内元素和块级元素的区别</h2><p>行内元素：　　</p><ul><li>与其他行内元素并排</li><li>不能设置宽高，默认的宽度就是文字的宽度</li></ul><p>块级元素：</p><ul><li>霸占一行，不能与其他任何元素并列。</li><li>能接受宽高，如果不设置宽度，那么宽度将默认变为父级的100%。</li></ul><h3 id="块级元素和行内元素的分类"><a href="#块级元素和行内元素的分类" class="headerlink" title="块级元素和行内元素的分类"></a>块级元素和行内元素的分类</h3><p>在<strong>HTML的角度</strong>来讲，标签分为：</p><ul><li>文本级标签：p , span , a , b , i , u , em</li><li>容器级标签：div , h系列 , li , dt ,dd</li><li>p：里面只能放文字和图片和表单元素，p里面不能放h和ul，也不能放p。</li></ul><p>从<strong>CSS的角度</strong>讲，CSS的分类和上面的很像，就p不一样：</p><ul><li>行内元素：除了p之外，所有的文本级标签，都是行内元素。p是个文本级标签，但是是个块级元素。</li><li>块级元素：所有的容器级标签，都是块级元素，以及p标签。</li></ul><h3 id="块级元素和行内元素的相互转换"><a href="#块级元素和行内元素的相互转换" class="headerlink" title="块级元素和行内元素的相互转换"></a>块级元素和行内元素的相互转换</h3><p>可以通过display属性将块级元素(比如div)和行内元素进行相互转换。</p><p><code>display：inline;</code></p><blockquote><p>这个标签将变为行内元素</p></blockquote><p><code>display：block;</code></p><blockquote><p>这个标签将变为块级标签</p></blockquote><h2 id="行内块状元素"><a href="#行内块状元素" class="headerlink" title="行内块状元素"></a>行内块状元素</h2><p>行内块状元素特征：</p><p>(1)不自动换行</p><p>(2)能够识别宽高</p><p>(3)默认排列方式为从左到右</p>]]></content>
    
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>几种盒子模型</title>
    <link href="/2020/07/14/notes/web/CSS/%E5%87%A0%E7%A7%8D%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/"/>
    <url>/2020/07/14/notes/web/CSS/%E5%87%A0%E7%A7%8D%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="标准盒模型"><a href="#标准盒模型" class="headerlink" title="标准盒模型"></a>标准盒模型</h2><p><code>box-sizing:content-box</code></p><p>height,width为content的宽高</p><h2 id="怪异盒模型-IE盒模型"><a href="#怪异盒模型-IE盒模型" class="headerlink" title="怪异盒模型(IE盒模型)"></a>怪异盒模型(IE盒模型)</h2><p><code>box-sizing:border-box</code></p><p>height,width为border外部</p><h2 id="弹性盒模型-flex"><a href="#弹性盒模型-flex" class="headerlink" title="弹性盒模型(flex)"></a>弹性盒模型(flex)</h2>]]></content>
    
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>几大经典布局方案</title>
    <link href="/2020/07/14/notes/web/CSS/%E5%87%A0%E5%A4%A7%E7%BB%8F%E5%85%B8%E5%B8%83%E5%B1%80%E6%96%B9%E6%A1%88/"/>
    <url>/2020/07/14/notes/web/CSS/%E5%87%A0%E5%A4%A7%E7%BB%8F%E5%85%B8%E5%B8%83%E5%B1%80%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h2 id="1-圣杯布局"><a href="#1-圣杯布局" class="headerlink" title="1 圣杯布局"></a>1 圣杯布局</h2><p>左右固定，中间自适应</p><h2 id="2-双飞翼布局"><a href="#2-双飞翼布局" class="headerlink" title="2 双飞翼布局"></a>2 双飞翼布局</h2><p>左右固定，中间自适应</p><h2 id="3-方法"><a href="#3-方法" class="headerlink" title="3 方法"></a>3 方法</h2><ol><li>float(麻烦)</li><li>flex</li><li>position</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>伪元素before和after</title>
    <link href="/2020/07/14/notes/web/CSS/%E4%BC%AA%E5%85%83%E7%B4%A0before%E5%92%8Cafter/"/>
    <url>/2020/07/14/notes/web/CSS/%E4%BC%AA%E5%85%83%E7%B4%A0before%E5%92%8Cafter/</url>
    
    <content type="html"><![CDATA[<p>一个<code>:</code>两个<code>:</code></p><p>css3 为了区分伪类和伪元素两者，已经明确规定了<strong>伪类</strong>用<code>:</code>来表示，而<strong>伪元素</strong>则用<code>::</code>来表示。对于CSS2之前已有的伪元素，比如<code>:before</code>，单冒号和双冒号的写法作用是一样的。</p><h2 id="1-基本"><a href="#1-基本" class="headerlink" title="1 基本"></a>1 基本</h2><p>在 CSS 渲染层加入，不能通过js来操作</p><p>使用content 属性来指定要插入的内容，content必须有值，至少是空。</p><p>默认情况下，伪类元素的<code>display</code>是默认值<code>inline</code>，可以通过设置<code>display:block</code>来改变其显示。</p><p>content可取以下值:</p><ol><li><code>string</code>, 将会向元素内容中添加字符串</li><li><code>attr()</code>,伪元素的内容跟主元素的某个属性值进行关联，其内容为主元素的某指定属性的值</li><li><code>url()/uri()</code>, 引用外部资源，比如图片</li><li><code>counter()</code>,调用计数器，可以不使用列表元素实现序号功能。</li></ol><p>例如：</p><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">::before</span>&#123;    <span class="hljs-comment">/* ::before在&lt;p&gt;标签内，所有内容之前 */</span>    <span class="hljs-comment">/* ::after同理 */</span>    <span class="hljs-attribute">content</span>: <span class="hljs-string">"11111"</span>;    &#125;</code></pre></div><h2 id="2-实例"><a href="#2-实例" class="headerlink" title="2 实例"></a>2 实例</h2><h3 id="2-1-清除浮动"><a href="#2-1-清除浮动" class="headerlink" title="2.1 清除浮动"></a>2.1 清除浮动</h3><p>清除浮动方法有多种，现在最常用的就是下面这种方法，仅需要以下样式即可在元素尾部自动清除浮动</p><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.cf</span><span class="hljs-selector-pseudo">:after</span> &#123;    <span class="hljs-attribute">clear</span>: both;&#125;</code></pre></div><h3 id="2-2-模拟float-center的效果"><a href="#2-2-模拟float-center的效果" class="headerlink" title="2.2 模拟float:center的效果"></a>2.2 模拟float:center的效果</h3><p>float没有center这个取值，但是可以通过伪类来模拟实现。</p><h3 id="2-3-做出各种图形效果"><a href="#2-3-做出各种图形效果" class="headerlink" title="2.3 做出各种图形效果"></a>2.3 做出各种图形效果</h3><p>各种方向形状的三角形，六边形,带小三角的对话框</p><p>原理：<a href="http://caibaojian.com/css-border-triangle.html" target="_blank" rel="noopener">http://caibaojian.com/css-border-triangle.html</a></p><h3 id="2-4-超链接特效"><a href="#2-4-超链接特效" class="headerlink" title="2.4 超链接特效"></a>2.4 超链接特效</h3><p><a href="https://tympanus.net/Development/CreativeLinkEffects/" target="_blank" rel="noopener">https://tympanus.net/Development/CreativeLinkEffects/</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>will-change属性</title>
    <link href="/2020/07/14/notes/web/CSS/will-change%E5%B1%9E%E6%80%A7/"/>
    <url>/2020/07/14/notes/web/CSS/will-change%E5%B1%9E%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="1-css"><a href="#1-css" class="headerlink" title="1 css"></a>1 css</h2><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.will-change-parent</span><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-selector-class">.will-change</span> &#123;  <span class="hljs-attribute">will-change</span>: transform;&#125;<span class="hljs-selector-class">.will-change</span> &#123;  <span class="hljs-attribute">transition</span>: transform <span class="hljs-number">0.3s</span>;&#125;<span class="hljs-selector-class">.will-change</span><span class="hljs-selector-pseudo">:hover</span> &#123;  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">1.5</span>);&#125;</code></pre></div><h2 id="2-js"><a href="#2-js" class="headerlink" title="2 js"></a>2 js</h2><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> el = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'element'</span>);<span class="hljs-comment">// 当鼠标移动到该元素上时给该元素设置 will-change 属性</span>el.addEventListener(<span class="hljs-string">'mouseenter'</span>, hintBrowser);<span class="hljs-comment">// 当 CSS 动画结束后清除 will-change 属性</span>el.addEventListener(<span class="hljs-string">'animationEnd'</span>, removeHint);<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hintBrowser</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-comment">// 填写在CSS动画中发生改变的CSS属性名</span>  <span class="hljs-keyword">this</span>.style.willChange = <span class="hljs-string">'transform, opacity'</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeHint</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">this</span>.style.willChange = <span class="hljs-string">'auto'</span>;&#125;</code></pre></div><h2 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3 注意事项"></a>3 注意事项</h2><ol><li>不要将will-change应用到太多元素上：浏览器已经尽力尝试去优化一切可以优化的东西了。有一些更强力的优化，如果与will-change结合在一起的话，有可能会消耗很多机器资源，如果<strong>过度使用</strong>的话，<strong>可能导致页面响应缓慢或者消耗非常多的资源</strong></li><li>有节制地使用：通常，当元素恢复到初始状态时，浏览器会丢弃掉之前做的优化工作。但是如果直接在样式表中显式声明了will-change属性，则表示目标元素可能会经常变化，浏览器会将优化工作保存得比之前更久。所以最佳实践是当元素变化之前和之后通过脚本来切换will-change的值</li><li>不要过早应用will-change优化：如果页面在性能方面没什么问题，则不要添加will-change属性来榨取一丁点的速度。<strong>will-change的设计初衷是作为最后的优化手段</strong>，用来尝试解决现有的性能问题。它不应该被用来预防性能问题。过度使用will-change会导致大量的内存占用，并会导致更复杂的渲染过程，因为浏览器会试图准备可能存在的变化过程。这会导致更严重的性能问题</li><li>给它足够的工作时间：这个属性是用来让页面开发者告知浏览器哪些属性可能会变化的。然后浏览器可以选择在变化发生前提前去做一些优化工作。所以给浏览器一点时间去真正做这些优化工作是非常重要的。使用时需要尝试去找到一些方法提前一定时间获知元素可能发生的变化，然后为它加上will-change属性</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>requestAnimationFrame相关</title>
    <link href="/2020/07/14/notes/web/CSS/requestAnimationFrame/"/>
    <url>/2020/07/14/notes/web/CSS/requestAnimationFrame/</url>
    
    <content type="html"><![CDATA[<div class="hljs"><pre><code class="hljs js">setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'setTimeout'</span>)&#125;, <span class="hljs-number">0</span>)requestAnimationFrame(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'requestAnimationFrame'</span>)&#125;)<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> &#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'promise'</span>)  r()&#125;).then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'then'</span>))<span class="hljs-comment">// promise</span><span class="hljs-comment">// then</span><span class="hljs-comment">// requestAnimationFrame</span><span class="hljs-comment">// setTimeout</span></code></pre></div><p>浏览器可以优化并行的动画动作，更合理的重新排列动作序列，并把能够合并的动作放在一个渲染周期内完成，从而呈现出更流畅的动画效果。requestAnimationFrame就是为了这个而出现的。</p><p>requestAnimationFrame绘制间隔等于浏览设备绘制间隔,这样就不会存在过度绘制的问题，动画不会掉帧。</p><p>setTimeout会存在过度绘制，会造成帧丢失，继而导致动画断续显示。</p><p>如果在一个浏览器标签页里运行一个动画，当这个标签页不可见时，浏览器会暂停它，这会减少CPU，内存的压力，节省电池电量。</p><p>希望执行一个动画，并且要求浏览器在<strong>下次重绘之前</strong>调用指定的回调函数更新动画。</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><div class="hljs"><pre><code class="hljs js">handle = requestAnimationFrame(callback);cancelAnimationFrame(handle);</code></pre></div><ul><li>当页面被最小化或者被切换成后台标签页时，页面为不可见，浏览器会触发一个visibilitychange事件，并设置document.hidden属性为true</li><li>当页面切换到显示状态，页面变为可见，同时触发一个visibilitychange事件，设置document.hidden属性为false</li></ul><h2 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h2><ol><li>首先判断document.hidden属性是否为true（页面是否可见），页面处于可见状态才会执行后面步骤</li><li>浏览器清空上一轮的动画函数</li><li>requestAnimationFrame将回调函数追加到动画帧请求回调函数列表的末尾<ul><li>当执行requestAnimationFrame(callback)的时候，不会立即调用 callback 函数，只是将其放入队列。每个回调函数都有一个布尔标识cancelled，该标识初始值为false，并且对外不可见。</li></ul></li><li>当浏览器再执行列表中的回调函数的时候，判断每个元组的 callback 的cancelled，如果为false，则执行 callback<ul><li>当页面可见并且动画帧请求回调函数列表不为空，浏览器会定期将这些回调函数加入到浏览器 UI 线程的队列中</li></ul></li><li>递归调用。要想实现一个完整的动画，应该在回调函数中递归调用回调函数</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pointer-events属性</title>
    <link href="/2020/07/14/notes/web/CSS/pointer-events/"/>
    <url>/2020/07/14/notes/web/CSS/pointer-events/</url>
    
    <content type="html"><![CDATA[<p>指定在什么情况下 (如果有) 某个特定的图形元素可以成为鼠标事件的 target。</p><div class="hljs"><pre><code class="hljs css"><span class="hljs-comment">/* Keyword values */</span><span class="hljs-selector-tag">pointer-events</span>: <span class="hljs-selector-tag">auto</span>;<span class="hljs-selector-tag">pointer-events</span>: <span class="hljs-selector-tag">none</span>;<span class="hljs-selector-tag">pointer-events</span>: <span class="hljs-selector-tag">visiblePainted</span>; <span class="hljs-comment">/* SVG only */</span><span class="hljs-selector-tag">pointer-events</span>: <span class="hljs-selector-tag">visibleFill</span>;    <span class="hljs-comment">/* SVG only */</span><span class="hljs-selector-tag">pointer-events</span>: <span class="hljs-selector-tag">visibleStroke</span>;  <span class="hljs-comment">/* SVG only */</span><span class="hljs-selector-tag">pointer-events</span>: <span class="hljs-selector-tag">visible</span>;        <span class="hljs-comment">/* SVG only */</span><span class="hljs-selector-tag">pointer-events</span>: <span class="hljs-selector-tag">painted</span>;        <span class="hljs-comment">/* SVG only */</span><span class="hljs-selector-tag">pointer-events</span>: <span class="hljs-selector-tag">fill</span>;           <span class="hljs-comment">/* SVG only */</span><span class="hljs-selector-tag">pointer-events</span>: <span class="hljs-selector-tag">stroke</span>;         <span class="hljs-comment">/* SVG only */</span><span class="hljs-selector-tag">pointer-events</span>: <span class="hljs-selector-tag">all</span>;            <span class="hljs-comment">/* SVG only */</span><span class="hljs-comment">/* Global values */</span><span class="hljs-selector-tag">pointer-events</span>: <span class="hljs-selector-tag">inherit</span>;<span class="hljs-selector-tag">pointer-events</span>: <span class="hljs-selector-tag">initial</span>;<span class="hljs-selector-tag">pointer-events</span>: <span class="hljs-selector-tag">unset</span>;</code></pre></div><h2 id="值"><a href="#值" class="headerlink" title="值"></a>值</h2><p>auto</p><blockquote><p>默认，对于SVG内容，该值与visiblePainted效果相同</p></blockquote><p>none</p><blockquote><p>不会成为鼠标事件的target。但是，当其后代元素的pointer-events属性指定其他值时，鼠标事件可以指向后代元素，在这种情况下，鼠标事件将在捕获或冒泡阶段触发父元素的事件侦听器。常应用为设置点击穿透</p></blockquote><p>visiblePainted</p><blockquote><p>visibility为visible，1、指针在元素内部，且fill属性指定了none之外的值; 2、指针在元素边界上，且stroke属性指定了none之外的值</p></blockquote><p>visibleFill</p><blockquote><p>visibility为visible，鼠标指针在元素内部时</p></blockquote><p>visibleStroke</p><blockquote><p>visibility为visible，鼠标指针在元素边界时</p></blockquote><p>visible</p><blockquote><p>visibility为visible，鼠标指针在元素内部或边界时,元素才会成为鼠标事件的目标，fill和stroke属性的值不影响事件处理。</p></blockquote><p>painted</p><blockquote><p>visibility不影响事件处理。内部或边界</p></blockquote><p>fill</p><p>stroke</p><p>all</p><blockquote><p>只有鼠标指针在元素内部或边界时,元素才会成为鼠标事件的目标，fill、stroke和visibility属性的值不影响事件处理。</p></blockquote><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p><code>pointer-events: none;</code></p><ul><li>设置事件穿透</li><li>滚动时设置该属性，从而提高的帧数</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>css</tag>
      
      <tag>svg</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>flex布局</title>
    <link href="/2020/07/14/notes/web/CSS/flex/"/>
    <url>/2020/07/14/notes/web/CSS/flex/</url>
    
    <content type="html"><![CDATA[<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><ul><li>flex-direction,主轴的方向,(row(默认) | row-reverse | column | column-reverse)</li><li>flex-wrap,如何换行,[nowrap（默认）不换行。 | wrap换行向下 | wrap-reverse换行向上]</li><li>flex-flow，flex-direction属性和flex-wrap属性的简写，默认值为row nowrap</li><li>justify-content，在主轴上的对齐方式(水平)，flex-start(默认) | flex-end | center | space-between | space-around;</li><li>align-items，在交叉轴上如何对齐，flex-start | flex-end | center | baseline | stretch(默认);</li><li>align-content，定义了多根轴线的对齐方式</li></ul><h2 id="item"><a href="#item" class="headerlink" title="item"></a>item</h2><ul><li>order，定义项目的排列顺序。数值越小，排列越靠前，默认为0。</li><li>flex-grow，放大比例，默认为0</li><li>flex-shrink，缩小比例，默认为1</li><li>flex-basis，分配多余空间之前，项目占据的主轴空间</li><li>flex，flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto</li><li>align-self，允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS画各种形状</title>
    <link href="/2020/07/14/notes/web/CSS/CSS%E7%94%BB%E5%90%84%E7%A7%8D%E5%BD%A2%E7%8A%B6/"/>
    <url>/2020/07/14/notes/web/CSS/CSS%E7%94%BB%E5%90%84%E7%A7%8D%E5%BD%A2%E7%8A%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="1-三角形，六角形-带小三角的对话框"><a href="#1-三角形，六角形-带小三角的对话框" class="headerlink" title="1 三角形，六角形,带小三角的对话框"></a>1 三角形，六角形,带小三角的对话框</h2><p>各种方向形状的三角形，六角形,带小三角的对话框</p><p>原理：<a href="http://caibaojian.com/css-border-triangle.html" target="_blank" rel="noopener">http://caibaojian.com/css-border-triangle.html</a></p><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.sanjiao</span> &#123;<span class="hljs-comment">/* 三角 */</span><span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;<span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<span class="hljs-attribute">border-top</span>: <span class="hljs-number">0</span> solid red;<span class="hljs-attribute">border-right</span>: <span class="hljs-number">50px</span> solid transparent;<span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">100px</span> solid red;<span class="hljs-attribute">border-left</span>: <span class="hljs-number">50px</span> solid transparent;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.liujiao</span> &#123;    <span class="hljs-comment">/* 六角形 */</span>    <span class="hljs-attribute">box-sizing</span>: border-box;    <span class="hljs-attribute">position</span>: relative;    <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;    <span class="hljs-attribute">border-top</span>: <span class="hljs-number">0</span>;    <span class="hljs-attribute">border-right</span>: <span class="hljs-number">50px</span> solid transparent;    <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">100px</span> solid red;    <span class="hljs-attribute">border-left</span>: <span class="hljs-number">50px</span> solid transparent;&#125;<span class="hljs-selector-class">.liujiao</span><span class="hljs-selector-pseudo">::after</span> &#123;    <span class="hljs-attribute">content</span>: <span class="hljs-string">""</span>;    <span class="hljs-attribute">position</span>: absolute;    <span class="hljs-attribute">top</span>: <span class="hljs-number">34px</span>;    <span class="hljs-attribute">left</span>: -<span class="hljs-number">50px</span>;    <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;    <span class="hljs-attribute">border-top</span>: <span class="hljs-number">100px</span> solid red;    <span class="hljs-attribute">border-right</span>: <span class="hljs-number">50px</span> solid transparent;    <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">0</span>;    <span class="hljs-attribute">border-left</span>: <span class="hljs-number">50px</span> solid transparent;&#125;</code></pre></div><h2 id="2-圆环，实心圆，椭圆，胶囊，半圆，同心圆"><a href="#2-圆环，实心圆，椭圆，胶囊，半圆，同心圆" class="headerlink" title="2 圆环，实心圆，椭圆，胶囊，半圆，同心圆"></a>2 圆环，实心圆，椭圆，胶囊，半圆，同心圆</h2><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"circle"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"><span class="hljs-selector-class">.circle1</span> &#123;</span><span class="css">    <span class="hljs-comment">/* 圆环 */</span></span>    width: 100px;    height: 100px;    border: 1px solid red;<span class="css">    <span class="hljs-comment">/* border-radius为50%或宽度(长度)的一半 */</span></span>    border-radius: 50%;    &#125;<span class="css"><span class="hljs-selector-class">.circle2</span> &#123;</span><span class="css">    <span class="hljs-comment">/* 实心圆1 */</span></span>    width: 0;    height: 0;<span class="css">    <span class="hljs-comment">/* border为半径 */</span></span>    border: 50px solid red;<span class="css">    <span class="hljs-comment">/* border-radius为边的50% */</span></span>    border-radius: 50%;    &#125;<span class="css"><span class="hljs-selector-class">.circle3</span> &#123;</span><span class="css">    <span class="hljs-comment">/* 实心圆2 */</span></span>    width: 100px;    height: 100px;<span class="css">    <span class="hljs-comment">/* border-radius为边的50% */</span></span>    border-radius: 50%;    background-color: red;    &#125;<span class="css"><span class="hljs-selector-class">.circle4</span> &#123;</span><span class="css">    <span class="hljs-comment">/* 胶囊 */</span></span>    width: 100px;    height: 300px;    border: 2px solid red;<span class="css">    <span class="hljs-comment">/* border-radius为短边的50% */</span></span>    border-radius: 50px;    &#125;<span class="css"><span class="hljs-selector-class">.circle5</span> &#123;</span><span class="css">    <span class="hljs-comment">/* 左上1/4圆 */</span></span>    width: 0;    height: 0;<span class="css">    <span class="hljs-comment">/* 半径为2*50px */</span></span>    border: 50px solid red;<span class="css">    <span class="hljs-comment">/* border-radius和象限顺序一样 */</span></span>    border-radius: 100% 0 0 0;    &#125;<span class="css"><span class="hljs-selector-class">.circle6</span> &#123;</span><span class="css">    <span class="hljs-comment">/* 上1/4圆 */</span></span>    width: 0;    height: 0;<span class="css">    <span class="hljs-comment">/* border为半径 */</span></span>    border-top: 50px solid red;    border-right: 50px solid transparent;    border-bottom: 50px solid transparent;    border-left: 50px solid transparent;<span class="css">    <span class="hljs-comment">/* border-radius和象限顺序一样 */</span></span>    border-radius: 50%;    &#125;<span class="css"><span class="hljs-selector-class">.circle7</span> &#123;</span><span class="css">    <span class="hljs-comment">/* 右上半圆(只显示上和右) */</span></span>    width: 0;    height: 0;<span class="css">    <span class="hljs-comment">/* border为半径 */</span></span>    border-top: 50px solid red;    border-right: 50px solid red;    border-bottom: 50px solid transparent;    border-left: 50px solid transparent;<span class="css">    <span class="hljs-comment">/* border-radius和象限顺序一样 */</span></span>    border-radius: 50%;    &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre></div><h2 id="3-正六边形"><a href="#3-正六边形" class="headerlink" title="3 正六边形"></a>3 正六边形</h2><p><a href="https://www.cnblogs.com/a-cat/p/9053884.html" target="_blank" rel="noopener">https://www.cnblogs.com/a-cat/p/9053884.html</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS效果收集</title>
    <link href="/2020/07/14/notes/web/CSS/CSS%E6%95%88%E6%9E%9C%E6%94%B6%E9%9B%86/"/>
    <url>/2020/07/14/notes/web/CSS/CSS%E6%95%88%E6%9E%9C%E6%94%B6%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h2 id="创意链接-a-特效"><a href="#创意链接-a-特效" class="headerlink" title="创意链接(a)特效"></a>创意链接(a)特效</h2><p><a href="https://tympanus.net/Development/CreativeLinkEffects/" target="_blank" rel="noopener">https://tympanus.net/Development/CreativeLinkEffects/</a></p><h2 id="创意按钮-button-特效"><a href="#创意按钮-button-特效" class="headerlink" title="创意按钮(button)特效"></a>创意按钮(button)特效</h2><p><a href="https://tympanus.net/Development/CreativeButtons/" target="_blank" rel="noopener">https://tympanus.net/Development/CreativeButtons/</a></p><h2 id="IconHoverEffects"><a href="#IconHoverEffects" class="headerlink" title="IconHoverEffects"></a>IconHoverEffects</h2><p><a href="https://tympanus.net/Development/IconHoverEffects/" target="_blank" rel="noopener">https://tympanus.net/Development/IconHoverEffects/</a></p><h2 id="各种三角"><a href="#各种三角" class="headerlink" title="各种三角"></a>各种三角</h2><p><a href="https://www.php.cn/css-tutorial-410604.html" target="_blank" rel="noopener">https://www.php.cn/css-tutorial-410604.html</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS长度单位</title>
    <link href="/2020/07/14/notes/web/CSS/CSS%E5%8D%95%E4%BD%8D/"/>
    <url>/2020/07/14/notes/web/CSS/CSS%E5%8D%95%E4%BD%8D/</url>
    
    <content type="html"><![CDATA[<h2 id="相对长度"><a href="#相对长度" class="headerlink" title="相对长度"></a>相对长度</h2><p>相对长度单位指定了一个长度相对于另一个长度的属性。对于不同的设备相对长度更适用。</p><table><thead><tr><th>单位</th><th>描述</th></tr></thead><tbody><tr><td>em</td><td>它是描述相对于应用在当前元素的字体尺寸，所以它也是相对长度单位。一般浏览器字体大小默认为16px，则2em == 32px；</td></tr><tr><td>ex</td><td>依赖于英文字母小 x 的高度</td></tr><tr><td>ch</td><td>数字 0 的宽度</td></tr><tr><td>rem</td><td>rem 是根 em（root em）的缩写，rem作用于非根元素时，相对于根元素字体大小；rem作用于根元素字体大小时，相对于其出初始字体大小。</td></tr><tr><td>vw</td><td>viewpoint width，视窗宽度，1vw=视窗宽度的1%</td></tr><tr><td>vh</td><td>viewpoint height，视窗高度，1vh=视窗高度的1%</td></tr><tr><td>vmin</td><td>vw和vh中较小的那个。</td></tr><tr><td>vmax</td><td>vw和vh中较大的那个。</td></tr><tr><td>%</td><td></td></tr></tbody></table><h2 id="绝对长度"><a href="#绝对长度" class="headerlink" title="绝对长度"></a>绝对长度</h2><p>绝对长度单位是一个固定的值，它反应一个真实的物理尺寸。绝对长度单位视输出介质而定，不依赖于环境（显示器、分辨率、操作系统等）。</p><table><thead><tr><th>单位</th><th>描述</th></tr></thead><tbody><tr><td>cm</td><td>厘米</td></tr><tr><td>mm</td><td>毫米</td></tr><tr><td>in</td><td>英寸 (1in = 96px = 2.54cm)</td></tr><tr><td>px *</td><td>像素 (1px = 1/96th of 1in)</td></tr><tr><td>pt</td><td>point，大约1/72英寸； (1pt = 1/72in)</td></tr><tr><td>pc</td><td>pica，大约6pt，1/6英寸； (1pc = 12 pt)</td></tr></tbody></table><h2 id="calc-函数"><a href="#calc-函数" class="headerlink" title="calc() 函数"></a>calc() 函数</h2><p><code>calc()</code> 函数用于动态计算长度值。</p><ul><li>需要注意的是，运算符前后都需要保留一个空格，例如：<code>width: calc(100% - 10px)</code>；</li><li>任何长度值都可以使用<code>calc()</code>函数进行计算；</li><li><code>calc()</code>函数支持 “+”, “-“, “*”, “/“ 运算；</li><li><code>calc()</code>函数使用标准的数学运算优先级规则；</li><li>IE 9.0</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS动画对比JS动画</title>
    <link href="/2020/07/14/notes/web/CSS/CSS%E5%8A%A8%E7%94%BB%E5%AF%B9%E6%AF%94JS%E5%8A%A8%E7%94%BB/"/>
    <url>/2020/07/14/notes/web/CSS/CSS%E5%8A%A8%E7%94%BB%E5%AF%B9%E6%AF%94JS%E5%8A%A8%E7%94%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="JS动画"><a href="#JS动画" class="headerlink" title="JS动画"></a>JS动画</h2><p>js实现动画: <code>setInterval</code> <code>setTimeout</code> <code>requestAnimationFrame</code></p><p><code>requestAnimationFrame</code>的优点在于：</p><ol><li>是<strong>浏览器针对动画提出的API</strong>。自动优化，页面不激活状态自动停止。</li><li>集中所有dom，<strong>一次重绘</strong>就完成，重绘事件<strong>跟随浏览器刷新频率</strong>。</li><li><strong>隐藏或不可见元素，不进行回流重绘</strong></li></ol><p>优点：</p><ol><li><strong>过程控制</strong>, 可以在动画播放过程中对动画进行控制：开始、暂停、回放、终止、取消都是可以做到的。</li><li>动画<strong>效果</strong>比css3动画<strong>丰富</strong>,有些动画效果，比如曲线运动,冲击闪烁,视差滚动效果，只有JavaScript动画才能完成</li><li>CSS3有<strong>兼容性</strong>问题，而JS大多时候没有兼容性问题</li></ol><p>缺点：</p><ol><li>JavaScript在浏览器的主线程中运行，而主线程中还有其它需要运行的JavaScript脚本、样式计算、布局、绘制任务等,对其<strong>干扰导致线程可能出现阻塞</strong>，从而造成丢帧的情况。</li><li>代码<strong>的复杂度高</strong>于CSS动画</li><li>无法保证执行时间。timeout interval存在同步任务优先执行的问题。</li></ol><h3 id="requestAnimationFrame执行时机"><a href="#requestAnimationFrame执行时机" class="headerlink" title="requestAnimationFrame执行时机"></a>requestAnimationFrame执行时机</h3><p>跟随浏览器刷新频率</p><p>可能在下次宏任务前，也可能在之后</p><h2 id="CSS动画"><a href="#CSS动画" class="headerlink" title="CSS动画"></a>CSS动画</h2><p>css实现动画：<code>animation</code> <code>transition</code> <code>transform</code></p><p>优点：</p><ol><li>集中所有DOM，<strong>一次重绘重排</strong>，<strong>刷新频率和浏览器刷新频率相同</strong>。</li><li><strong>代码简单</strong>，方便调优</li><li>不可见元素不参与重排，节约cpu</li><li><strong>可以使用硬件加速</strong>GPU(<code>translateZ(0)</code>)</li></ol><p>缺点：</p><ol><li>对<strong>过程无法把控</strong>。无进度报告，无回调函数。</li><li><strong>代码冗长</strong>。</li></ol><h2 id="CSS动画比JS流畅的前提"><a href="#CSS动画比JS流畅的前提" class="headerlink" title="CSS动画比JS流畅的前提"></a>CSS动画比JS流畅的前提</h2><ul><li>在Chromium基础上的浏览器中</li><li>JS在执行一些昂贵的任务</li><li>同时CSS动画不触发layout或paint<br>在CSS动画或JS动画触发了paint或layout时，需要main thread进行Layer树的重计算，这时CSS动画或JS动画都会阻塞后续操作</li></ul><p>只有如下属性的修改才符合,仅触发Composite，不触发layout或paint</p><ul><li>backface-visibility</li><li>opacity</li><li>perspective</li><li>perspective-origin</li><li>transfrom</li></ul><p>所以只有用上了3D加速或修改opacity时，才有机会用得上CSS动画的这一优势。</p><p>因此，在大部分应用场景下，效率角度更值得关注的还是下列问题。</p><ul><li>是否导致layout</li><li>repaint的面积</li><li>是否是有高消耗的属性（css shadow等）</li><li>是否启用硬件加速</li></ul><h2 id="CSS动画流畅的原因"><a href="#CSS动画流畅的原因" class="headerlink" title="CSS动画流畅的原因"></a>CSS动画流畅的原因</h2><p>渲染线程分为main thread(主线程)和compositor thread(合成器线程)。</p><p>如果CSS动画只是改变<code>transform</code>和<code>opacity</code>，这时整个CSS动画得以在compositor thread完成（而JS动画则会在main thread执行，然后触发compositor进行下一步操作）</p><p>在JS执行一些昂贵的任务时，main thread繁忙，CSS动画由于使用了compositor thread可以保持流畅</p><p>CSS3开启硬件加速的使用和坑<a href="https://www.jianshu.com/p/9596c82086d5" target="_blank" rel="noopener">https://www.jianshu.com/p/9596c82086d5</a></p><h2 id="CSS开启硬件加速"><a href="#CSS开启硬件加速" class="headerlink" title="CSS开启硬件加速"></a>CSS开启硬件加速</h2><div class="hljs"><pre><code class="hljs css"><span class="hljs-comment">/**原理上还是使用3d效果来开启硬件加速**/</span><span class="hljs-selector-class">.speed-up</span>&#123;    <span class="hljs-attribute">-webkit-transform</span>: <span class="hljs-built_in">translateZ</span>(<span class="hljs-number">0</span>);    <span class="hljs-attribute">-moz-transform</span>: <span class="hljs-built_in">translateZ</span>(<span class="hljs-number">0</span>);    <span class="hljs-attribute">-ms-transform</span>: <span class="hljs-built_in">translateZ</span>(<span class="hljs-number">0</span>);    <span class="hljs-attribute">-o-transform</span>: <span class="hljs-built_in">translateZ</span>(<span class="hljs-number">0</span>);    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateZ</span>(<span class="hljs-number">0</span>);&#125;</code></pre></div><p>对于safari以及chrome，可能会在使用animation或者transition时<strong>出现闪烁的问题</strong>，可以使用以下的解决方法:</p><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.speed-up</span>&#123;    <span class="hljs-attribute">-webkit-backface-visibility</span>: hidden;    <span class="hljs-attribute">-moz-backface-visibility</span>: hidden;    <span class="hljs-attribute">-ms-backface-visibility</span>: hidden;    <span class="hljs-attribute">backface-visibility</span>: hidden;    <span class="hljs-attribute">-webkit-perspective</span>: <span class="hljs-number">1000</span>;    <span class="hljs-attribute">-moz-perspective</span>: <span class="hljs-number">1000</span>;    <span class="hljs-attribute">-ms-perspective</span>: <span class="hljs-number">1000</span>;    <span class="hljs-attribute">perspective</span>: <span class="hljs-number">1000</span>;<span class="hljs-comment">/**webkit上也可以用以下语句  **/</span>    <span class="hljs-attribute">-webkit-transform</span>: <span class="hljs-built_in">translate3d</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);    <span class="hljs-attribute">-moz-transform</span>: <span class="hljs-built_in">translate3d</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);    <span class="hljs-attribute">-ms-transform</span>: <span class="hljs-built_in">translate3d</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate3d</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);&#125;</code></pre></div><p>硬件加速最好只用在animation或者transform上。不要滥用硬件加速，增加了内存的使用，而且它会减少移动端设备的电池寿命。</p>]]></content>
    
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS3学习记录</title>
    <link href="/2020/07/14/notes/web/CSS/CSS3/"/>
    <url>/2020/07/14/notes/web/CSS/CSS3/</url>
    
    <content type="html"><![CDATA[<h2 id="1-边框"><a href="#1-边框" class="headerlink" title="1 边框"></a>1 边框</h2><ul><li>border-radius</li><li>box-shadow</li><li>border-image</li></ul><h3 id="1-1-CSS3-圆角"><a href="#1-1-CSS3-圆角" class="headerlink" title="1.1 CSS3 圆角"></a>1.1 CSS3 圆角</h3><p>可以给<strong>任何元素</strong>制作 “圆角”</p><p>每个半径的四个值的顺序是：左上角，右上角，右下角，左下角。</p><p>在div中添加圆角元素：</p><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123;<span class="hljs-attribute">border</span>:<span class="hljs-number">2px</span> solid;<span class="hljs-attribute">border-radius</span>:<span class="hljs-number">25px</span>;&#125;</code></pre></div><h3 id="1-2-CSS3-盒阴影"><a href="#1-2-CSS3-盒阴影" class="headerlink" title="1.2 CSS3 盒阴影"></a>1.2 CSS3 盒阴影</h3><p><code>box-shadow: h-shadow v-shadow blur spread color inset;</code></p><table><thead><tr><th>值</th><th>说明</th></tr></thead><tbody><tr><td>h-shadow</td><td>必需的。水平阴影的位置。允许负值</td></tr><tr><td>v-shadow</td><td>必需的。垂直阴影的位置。允许负值</td></tr><tr><td>blur</td><td>可选。模糊距离</td></tr><tr><td>spread</td><td>可选。阴影的大小</td></tr><tr><td>color</td><td>可选。阴影的颜色。在CSS颜色值寻找颜色值的完整列表</td></tr><tr><td>inset</td><td>可选。从外层的阴影（开始时）改变阴影内侧阴影</td></tr></tbody></table><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123;    <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">10px</span> <span class="hljs-number">10px</span> <span class="hljs-number">5px</span> <span class="hljs-number">#888888</span>;&#125;</code></pre></div><h3 id="1-3-CSS3-边界图片"><a href="#1-3-CSS3-边界图片" class="headerlink" title="1.3 CSS3 边界图片"></a>1.3 CSS3 边界图片</h3><p><code>border-image: source slice width outset repeat|initial|inherit;</code></p><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>border-image-source</td><td>用于指定要用于绘制边框的图像的位置</td></tr><tr><td>border-image-slice</td><td>图像边界向内偏移</td></tr><tr><td>border-image-width</td><td>图像边界的宽度</td></tr><tr><td>border-image-outset</td><td>用于指定在边框外部绘制 border-image-area 的量</td></tr><tr><td>border-image-repeat</td><td>用于设置图像边界是否应重复（repeat）、拉伸（stretch）或铺满（round）。</td></tr></tbody></table><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-id">#borderimg</span> &#123;    <span class="hljs-attribute">-webkit-border-image</span>: <span class="hljs-built_in">url</span>(border.png) <span class="hljs-number">30</span> round; <span class="hljs-comment">/* Safari 3.1-5 */</span>    <span class="hljs-attribute">-o-border-image</span>: <span class="hljs-built_in">url</span>(border.png) <span class="hljs-number">30</span> round; <span class="hljs-comment">/* Opera 11-12.1 */</span>    <span class="hljs-attribute">border-image</span>: <span class="hljs-built_in">url</span>(border.png) <span class="hljs-number">30</span> round;&#125;</code></pre></div><h2 id="2-背景（background）"><a href="#2-背景（background）" class="headerlink" title="2 背景（background）"></a>2 背景（background）</h2><ul><li>background-image</li><li>background-size</li><li>background-origin</li><li>background-clip</li></ul><h2 id="3-CSS3-渐变（Gradients）"><a href="#3-CSS3-渐变（Gradients）" class="headerlink" title="3 CSS3 渐变（Gradients）"></a>3 CSS3 渐变（Gradients）</h2><p>CSS3 定义了两种类型的渐变（gradients）：</p><p>线性渐变（Linear Gradients）- 向下/向上/向左/向右/对角方向<br>径向渐变（Radial Gradients）- 由它们的中心定义</p><h2 id="4-CSS3-文本效果"><a href="#4-CSS3-文本效果" class="headerlink" title="4 CSS3 文本效果"></a>4 CSS3 文本效果</h2><ul><li>text-shadow(文本阴影)</li><li>box-shadow(盒子阴影)</li><li>text-overflow(指定应向用户如何显示溢出内容)</li><li>word-wrap(自动换行属性允许您强制文本换行)</li><li>word-break(单词拆分换行,<code>keep-all</code>,<code>break-all</code>)</li></ul><h2 id="5-CSS3-字体"><a href="#5-CSS3-字体" class="headerlink" title="5 CSS3 字体"></a>5 CSS3 字体</h2><p>使用以前 CSS 的版本，不得不使用用户计算机上已经安装的字体。</p><p>使用 CSS3，网可以使用任何字体。</p><div class="hljs"><pre><code class="hljs css">&lt;<span class="hljs-selector-tag">style</span>&gt;<span class="hljs-keyword">@font-face</span>&#123;    <span class="hljs-attribute">font-family</span>: myFirstFont;    <span class="hljs-attribute">src</span>: <span class="hljs-built_in">url</span>(sansation_light.woff);&#125;<span class="hljs-selector-tag">div</span>&#123;    <span class="hljs-attribute">font-family</span>:myFirstFont;&#125;&lt;/style&gt;</code></pre></div><h2 id="6-CSS3-2D-转换"><a href="#6-CSS3-2D-转换" class="headerlink" title="6 CSS3 2D 转换"></a>6 CSS3 2D 转换</h2><p>移动(translate)、转动(rotate)、缩放(scale)、拉长或拉伸。</p><p>Internet Explorer 10, Firefox, 和 Opera支持transform 属性.</p><p>Chrome 和 Safari 要求前缀 -webkit- 版本.</p><p>注意： Internet Explorer 9 要求前缀 -ms- 版本.</p><h3 id="6-1-translate-方法"><a href="#6-1-translate-方法" class="headerlink" title="6.1 translate() 方法"></a>6.1 translate() 方法</h3><p>根据左(X轴)和顶部(Y轴)位置给定的参数，从当前元素位置移动。</p><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123;<span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(<span class="hljs-number">50px</span>,<span class="hljs-number">100px</span>);<span class="hljs-attribute">-ms-transform</span>: <span class="hljs-built_in">translate</span>(<span class="hljs-number">50px</span>,<span class="hljs-number">100px</span>); <span class="hljs-comment">/* IE 9 */</span><span class="hljs-attribute">-webkit-transform</span>: <span class="hljs-built_in">translate</span>(<span class="hljs-number">50px</span>,<span class="hljs-number">100px</span>); <span class="hljs-comment">/* Safari and Chrome */</span>&#125;</code></pre></div><h3 id="6-2-rotate-方法"><a href="#6-2-rotate-方法" class="headerlink" title="6.2 rotate() 方法"></a>6.2 rotate() 方法</h3><p>顺时针旋转元素</p><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123;<span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotate</span>(<span class="hljs-number">30deg</span>);<span class="hljs-attribute">-ms-transform</span>: <span class="hljs-built_in">rotate</span>(<span class="hljs-number">30deg</span>); <span class="hljs-comment">/* IE 9 */</span><span class="hljs-attribute">-webkit-transform</span>: <span class="hljs-built_in">rotate</span>(<span class="hljs-number">30deg</span>); <span class="hljs-comment">/* Safari and Chrome */</span>&#125;</code></pre></div><h3 id="6-3-scale-方法"><a href="#6-3-scale-方法" class="headerlink" title="6.3 scale() 方法"></a>6.3 scale() 方法</h3><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-tag">-ms-transform</span><span class="hljs-selector-pseudo">:scale(2</span>,3); <span class="hljs-comment">/* IE 9 */</span><span class="hljs-selector-tag">-webkit-transform</span>: <span class="hljs-selector-tag">scale</span>(2,3); <span class="hljs-comment">/* Safari */</span><span class="hljs-selector-tag">transform</span>: <span class="hljs-selector-tag">scale</span>(2,3); <span class="hljs-comment">/* 标准语法 */</span></code></pre></div><p><code>scale(2,3)</code></p><p>转变宽度为原来的大小的2倍，和其原始大小3倍的高度。</p><h3 id="6-4-skew-方法"><a href="#6-4-skew-方法" class="headerlink" title="6.4 skew() 方法"></a>6.4 skew() 方法</h3><p><code>transform:skew(&lt;angle&gt; [,&lt;angle&gt;]);</code></p><p>包含两个参数值，分别表示X轴和Y轴倾斜的角度，如果第二个参数为空，则默认为0，参数为负表示向相反方向倾斜。</p><p><a href="https://www.runoob.com/try/try.php?filename=trycss3_transform_skew" target="_blank" rel="noopener">https://www.runoob.com/try/try.php?filename=trycss3_transform_skew</a></p><h3 id="6-5-matrix-方法"><a href="#6-5-matrix-方法" class="headerlink" title="6.5 matrix() 方法"></a>6.5 matrix() 方法</h3><p>matrix 方法有六个参数，包含旋转，缩放，移动（平移）和倾斜功能。</p><h2 id="7-CSS3-3D-转换"><a href="#7-CSS3-3D-转换" class="headerlink" title="7 CSS3 3D 转换"></a>7 CSS3 3D 转换</h2><h3 id="7-1-rotateX-方法"><a href="#7-1-rotateX-方法" class="headerlink" title="7.1 rotateX() 方法"></a>7.1 rotateX() 方法</h3><p><code>rotateX()</code>方法，围绕其在一个给定度数X轴旋转的元素。</p><h3 id="7-2-rotateY-方法"><a href="#7-2-rotateY-方法" class="headerlink" title="7.2 rotateY() 方法"></a>7.2 rotateY() 方法</h3><p><code>rotateY()</code>方法，围绕其在一个给定度数Y轴旋转的元素。</p><h3 id="8-CSS3-过渡"><a href="#8-CSS3-过渡" class="headerlink" title="8 CSS3 过渡"></a>8 CSS3 过渡</h3><p>CSS3 过渡是元素从一种样式逐渐改变为另一种的效果。</p><p>要实现这一点，必须规定两项内容：</p><ul><li>指定要添加效果的CSS属性</li><li>指定效果的持续时间。</li></ul><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123;    <span class="hljs-attribute">transition</span>: width <span class="hljs-number">2s</span>, height <span class="hljs-number">2s</span>, transform <span class="hljs-number">2s</span>;    <span class="hljs-attribute">-webkit-transition</span>: width <span class="hljs-number">2s</span>, height <span class="hljs-number">2s</span>, -webkit-transform <span class="hljs-number">2s</span>;&#125;</code></pre></div><h2 id="9-CSS3-动画"><a href="#9-CSS3-动画" class="headerlink" title="9 CSS3 动画"></a>9 CSS3 动画</h2><h3 id="9-1-CSS3-keyframes-规则"><a href="#9-1-CSS3-keyframes-规则" class="headerlink" title="9.1 CSS3 @keyframes 规则"></a>9.1 CSS3 <code>@keyframes</code> 规则</h3><p><code>@keyframes</code> 规则内指定一个 CSS 样式和动画将逐步从目前的样式更改为新的样式。</p><div class="hljs"><pre><code class="hljs css"><span class="hljs-keyword">@keyframes</span> myfirst&#123;    <span class="hljs-selector-tag">from</span> &#123;<span class="hljs-attribute">background</span>: red;&#125;    <span class="hljs-selector-tag">to</span> &#123;<span class="hljs-attribute">background</span>: yellow;&#125;&#125;<span class="hljs-keyword">@-webkit-keyframes</span> myfirst /* Safari 与 Chrome */&#123;    <span class="hljs-selector-tag">from</span> &#123;<span class="hljs-attribute">background</span>: red;&#125;    <span class="hljs-selector-tag">to</span> &#123;<span class="hljs-attribute">background</span>: yellow;&#125;&#125;</code></pre></div><p>百分比来规定变化发生的时间，或用关键词 “from” 和 “to”，等同于 0% 和 100%。</p><div class="hljs"><pre><code class="hljs css"><span class="hljs-keyword">@keyframes</span> myfirst&#123;0%   &#123;<span class="hljs-attribute">background</span>: red;&#125;25%  &#123;<span class="hljs-attribute">background</span>: yellow;&#125;50%  &#123;<span class="hljs-attribute">background</span>: blue;&#125;100% &#123;<span class="hljs-attribute">background</span>: green;&#125;&#125;<span class="hljs-keyword">@-moz-keyframes</span> myfirst /* Firefox */&#123;0%   &#123;<span class="hljs-attribute">background</span>: red;&#125;25%  &#123;<span class="hljs-attribute">background</span>: yellow;&#125;50%  &#123;<span class="hljs-attribute">background</span>: blue;&#125;100% &#123;<span class="hljs-attribute">background</span>: green;&#125;&#125;<span class="hljs-keyword">@-webkit-keyframes</span> myfirst /* Safari 和 Chrome */&#123;0%   &#123;<span class="hljs-attribute">background</span>: red;&#125;25%  &#123;<span class="hljs-attribute">background</span>: yellow;&#125;50%  &#123;<span class="hljs-attribute">background</span>: blue;&#125;100% &#123;<span class="hljs-attribute">background</span>: green;&#125;&#125;<span class="hljs-keyword">@-o-keyframes</span> myfirst /* Opera */&#123;0%   &#123;<span class="hljs-attribute">background</span>: red;&#125;25%  &#123;<span class="hljs-attribute">background</span>: yellow;&#125;50%  &#123;<span class="hljs-attribute">background</span>: blue;&#125;100% &#123;<span class="hljs-attribute">background</span>: green;&#125;&#125;</code></pre></div><h3 id="9-2-捆绑-keyframes"><a href="#9-2-捆绑-keyframes" class="headerlink" title="9.2 捆绑@keyframes"></a>9.2 捆绑<code>@keyframes</code></h3><ul><li>规定动画的名称</li><li>规定动画的时长</li></ul><p>把 “myfirst” 动画捆绑到 div 元素，时长：5 秒：</p><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123;<span class="hljs-attribute">animation</span>: myfirst <span class="hljs-number">5s</span>;<span class="hljs-attribute">-moz-animation</span>: myfirst <span class="hljs-number">5s</span>;     <span class="hljs-comment">/* Firefox */</span><span class="hljs-attribute">-webkit-animation</span>: myfirst <span class="hljs-number">5s</span>;  <span class="hljs-comment">/* Safari 和 Chrome */</span><span class="hljs-attribute">-o-animation</span>: myfirst <span class="hljs-number">5s</span>;       <span class="hljs-comment">/* Opera */</span>&#125;</code></pre></div><h2 id="10-CSS3-多列"><a href="#10-CSS3-多列" class="headerlink" title="10 CSS3 多列"></a>10 CSS3 多列</h2><p>多列属性：</p><ul><li>column-count</li><li>column-gap</li><li>column-rule</li></ul><h3 id="10-1-创建多列"><a href="#10-1-创建多列" class="headerlink" title="10.1 创建多列"></a>10.1 创建多列</h3><p>文本分隔为三列</p><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123;<span class="hljs-attribute">-moz-column-count</span>:<span class="hljs-number">3</span>; <span class="hljs-comment">/* Firefox */</span><span class="hljs-attribute">-webkit-column-count</span>:<span class="hljs-number">3</span>; <span class="hljs-comment">/* Safari 和 Chrome */</span><span class="hljs-attribute">column-count</span>:<span class="hljs-number">3</span>;&#125;</code></pre></div><h3 id="10-2-规定列之间的间隔"><a href="#10-2-规定列之间的间隔" class="headerlink" title="10.2 规定列之间的间隔"></a>10.2 规定列之间的间隔</h3><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;    <span class="hljs-attribute">-webkit-column-gap</span>: <span class="hljs-number">40px</span>; <span class="hljs-comment">/* Chrome, Safari, Opera */</span>    <span class="hljs-attribute">-moz-column-gap</span>: <span class="hljs-number">40px</span>; <span class="hljs-comment">/* Firefox */</span>    <span class="hljs-attribute">column-gap</span>: <span class="hljs-number">40px</span>;&#125;</code></pre></div><h3 id="10-3-列规则"><a href="#10-3-列规则" class="headerlink" title="10.3 列规则"></a>10.3 列规则</h3><p><code>column-rule</code> 属性设置列之间的宽度、样式和颜色规则。</p><h2 id="11-CSS3-用户界面"><a href="#11-CSS3-用户界面" class="headerlink" title="11 CSS3 用户界面"></a>11 CSS3 用户界面</h2><ul><li>resize</li><li>box-sizing</li><li>outline-offset</li></ul><h3 id="11-1-调整尺寸"><a href="#11-1-调整尺寸" class="headerlink" title="11.1 调整尺寸"></a>11.1 调整尺寸</h3><p>resize 属性规定是否可由用户调整元素尺寸</p><h3 id="11-2-方框大小调整"><a href="#11-2-方框大小调整" class="headerlink" title="11.2 方框大小调整"></a>11.2 方框大小调整</h3><p>box-sizing 属性允许您以确切的方式定义适应某个区域的具体内容。</p><h3 id="11-3-外形修饰"><a href="#11-3-外形修饰" class="headerlink" title="11.3 外形修饰"></a>11.3 外形修饰</h3><p>outline-offset 属性对轮廓进行偏移，并在超出边框边缘的位置绘制轮廓。</p><h2 id="12-media-查询"><a href="#12-media-查询" class="headerlink" title="12 @media 查询"></a>12 <code>@media</code> 查询</h2><p><code>@media</code> 可以针对不同的屏幕尺寸设置不同的样式，特别是如果你需要设置设计响应式的页面，<code>@media</code> 是非常有用的。</p><h3 id="12-1-语法"><a href="#12-1-语法" class="headerlink" title="12.1 语法"></a>12.1 语法</h3><div class="hljs"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> mediatype <span class="hljs-keyword">and</span>|<span class="hljs-keyword">not</span>|<span class="hljs-keyword">only</span> (media feature) &#123;    <span class="hljs-selector-tag">CSS-Code</span>;&#125;</code></pre></div><p>你也可以针对不同的媒体使用不同 stylesheets :</p><p><code>&lt;link rel=&quot;stylesheet&quot; media=&quot;mediatype and|not|only (media feature)&quot; href=&quot;mystylesheet.css&quot;&gt;</code></p><h2 id="13-Viewport"><a href="#13-Viewport" class="headerlink" title="13 Viewport"></a>13 Viewport</h2><p><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</code></p><ul><li>width：控制 viewport 的大小，可以指定的一个值，如 600，或者特殊的值，如 device-width 为设备的宽度（单位为缩放为 100% 时的 CSS 的像素）。</li><li>height：和 width 相对应，指定高度。</li><li>initial-scale：初始缩放比例，也即是当页面第一次 load 的时候缩放比例。</li><li>maximum-scale：允许用户缩放到的最大比例。</li><li>minimum-scale：允许用户缩放到的最小比例。</li><li>user-scalable：用户是否可以手动缩放。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>css学习记录</title>
    <link href="/2020/07/14/notes/web/CSS/CSS/"/>
    <url>/2020/07/14/notes/web/CSS/CSS/</url>
    
    <content type="html"><![CDATA[<h2 id="1-多重样式优先级"><a href="#1-多重样式优先级" class="headerlink" title="1 多重样式优先级"></a>1 多重样式优先级</h2><p>（内联样式）Inline style &gt; （内部样式）Internal style sheet &gt;（外部样式）External style sheet &gt; 浏览器默认样式</p><h2 id="2-background-属性"><a href="#2-background-属性" class="headerlink" title="2 background 属性"></a>2 background 属性</h2><p><code>background:bg-color bg-image position/bg-size bg-repeat bg-origin bg-clip bg-attachment initial|inherit;</code></p><h2 id="3-Text-文本-格式"><a href="#3-Text-文本-格式" class="headerlink" title="3 Text(文本)格式"></a>3 Text(文本)格式</h2><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>color</td><td>设置文本颜色</td></tr><tr><td>direction</td><td>设置文本方向。</td></tr><tr><td>letter-spacing</td><td>设置字符间距</td></tr><tr><td>line-height</td><td>设置行高</td></tr><tr><td>text-align</td><td>对齐元素中的文本</td></tr><tr><td>text-decoration</td><td>向文本添加修饰</td></tr><tr><td>text-indent</td><td>缩进元素中文本的首行</td></tr><tr><td>text-shadow</td><td>设置文本阴影</td></tr><tr><td>text-transform</td><td>控制元素中的字母</td></tr><tr><td>unicode-bidi</td><td>设置或返回文本是否被重写</td></tr><tr><td>vertical-align</td><td>设置元素的垂直对齐</td></tr><tr><td>white-space</td><td>设置元素中空白的处理方式</td></tr><tr><td>word-spacing</td><td>设置字间距</td></tr></tbody></table><h2 id="4-Fonts-字体"><a href="#4-Fonts-字体" class="headerlink" title="4 Fonts(字体)"></a>4 Fonts(字体)</h2><p>CSS字体属性定义字体，加粗，大小，文字样式。</p><p>在计算机屏幕上，sans-serif字体被认为是比serif字体容易阅读</p><h3 id="4-1-字体样式"><a href="#4-1-字体样式" class="headerlink" title="4.1 字体样式"></a>4.1 字体样式</h3><ul><li>正常 - 正常显示文本</li><li>斜体 - 以斜体字显示的文字</li><li>倾斜的文字 - 文字向一边倾斜（和斜体非常类似，但不太支持）</li></ul><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.normal</span> &#123;<span class="hljs-attribute">font-style</span>:normal;&#125;<span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.italic</span> &#123;<span class="hljs-attribute">font-style</span>:italic;&#125;<span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.oblique</span> &#123;<span class="hljs-attribute">font-style</span>:oblique;&#125;</code></pre></div><h3 id="4-2-字体大小"><a href="#4-2-字体大小" class="headerlink" title="4.2 字体大小"></a>4.2 字体大小</h3><p>用em来设置字体大小</p><p>1em的默认大小是16px。可以通过下面这个公式将像素转换为em：px/16=em</p><p>不幸的是，仍然是IE浏览器的问题。调整文本的大小时，会比正常的尺寸更大或更小。</p><p>使用百分比和EM组合</p><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;<span class="hljs-attribute">font-size</span>:<span class="hljs-number">100%</span>;&#125;<span class="hljs-selector-tag">h1</span> &#123;<span class="hljs-attribute">font-size</span>:<span class="hljs-number">2.5em</span>;&#125;<span class="hljs-selector-tag">h2</span> &#123;<span class="hljs-attribute">font-size</span>:<span class="hljs-number">1.875em</span>;&#125;<span class="hljs-selector-tag">p</span> &#123;<span class="hljs-attribute">font-size</span>:<span class="hljs-number">0.875em</span>;&#125;</code></pre></div><p>在所有浏览器中，可以显示相同的文本大小，并允许所有浏览器缩放文本的大小。</p><h2 id="5-链接"><a href="#5-链接" class="headerlink" title="5 链接"></a>5 链接</h2><p>四个链接状态</p><ul><li>a:link - 正常，未访问过的链接</li><li>a:visited - 用户已访问过的链接</li><li>a:hover - 当用户鼠标放在链接上时</li><li>a:active - 链接被点击的那一刻</li></ul><h2 id="6-border"><a href="#6-border" class="headerlink" title="6 border"></a>6 border</h2><p>border:5px solid red;</p><h2 id="7-CSS-轮廓（outline）"><a href="#7-CSS-轮廓（outline）" class="headerlink" title="7 CSS 轮廓（outline）"></a>7 CSS 轮廓（outline）</h2><p>轮廓（outline）是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用。</p><p>轮廓（outline）属性指定元素轮廓的样式、颜色和宽度。</p><h2 id="8-尺寸-Dimension"><a href="#8-尺寸-Dimension" class="headerlink" title="8 尺寸 (Dimension)"></a>8 尺寸 (Dimension)</h2><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>height</td><td>设置元素的高度。</td></tr><tr><td>line-height</td><td>设置行高。</td></tr><tr><td>max-height</td><td>设置元素的最大高度。</td></tr><tr><td>max-width</td><td>设置元素的最大宽度。</td></tr><tr><td>min-height</td><td>设置元素的最小高度。</td></tr><tr><td>min-width</td><td>设置元素的最小宽度。</td></tr><tr><td>width</td><td>设置元素的宽度</td></tr></tbody></table><h2 id="9-Display-显示-与-Visibility（可见性）"><a href="#9-Display-显示-与-Visibility（可见性）" class="headerlink" title="9 Display(显示) 与 Visibility（可见性）"></a>9 Display(显示) 与 Visibility（可见性）</h2><h3 id="9-1-外边距合并"><a href="#9-1-外边距合并" class="headerlink" title="9.1 外边距合并"></a>9.1 外边距合并</h3><p>当两个垂直外边距相遇时，它们将形成一个外边距。</p><p>只有普通文档流中块壮元素的垂直外边距才会发生外边距合并。</p><p>行内块左右不会合并。</p><p>行内块与上下块状不会。</p><p>行内框、浮动框或绝对定位之间的外边距不会合并。</p><h2 id="10-Position-定位"><a href="#10-Position-定位" class="headerlink" title="10 Position(定位)"></a>10 Position(定位)</h2><p>position 属性指定了元素的定位类型。</p><p>position 属性的五个值：</p><ul><li>static</li><li>relative</li><li>fixed</li><li>absolute</li><li>sticky</li></ul><p>然后用top, bottom, left, right定位</p><h3 id="10-1-static-定位"><a href="#10-1-static-定位" class="headerlink" title="10.1 static 定位"></a>10.1 static 定位</h3><p>HTML 元素的<strong>默认值</strong>，即没有定位，遵循正常的文档流对象。</p><p>静态定位的元素不会受到 top, bottom, left, right影响。</p><h3 id="10-2-fixed-定位"><a href="#10-2-fixed-定位" class="headerlink" title="10.2 fixed 定位"></a>10.2 fixed 定位</h3><p>元素的位置相对于<strong>浏览器窗口</strong>是固定位置。</p><p>即使窗口是滚动的它也不会移动</p><p>与文档流无关，因此<strong>不占据空间</strong>。</p><h3 id="10-3-relative-定位"><a href="#10-3-relative-定位" class="headerlink" title="10.3 relative 定位"></a>10.3 relative 定位</h3><p>相对定位元素的定位是<strong>相对其正常位置</strong>。</p><p>但是<strong>原本所占的空间不会改变</strong>。</p><p>相对定位元素经常被用来作为绝对定位元素的容器块。</p><p>iOS里APP右上角的红色圈圈:</p><p>通常的做法是将APP图片所处的div设成relative，然后红色圈圈设成absolute，再设top/right即可。这样无论用户怎么改变APP图片的位置，红色圈圈永远固定在右上角</p><h3 id="10-4-absolute-定位"><a href="#10-4-absolute-定位" class="headerlink" title="10.4 absolute 定位"></a>10.4 absolute 定位</h3><p>绝对定位的元素的位置相对于最近的已定位(<code>relative</code>、<code>absolute</code>、<code>fixed</code>)父元素，如果元素没有已定位的父元素，那么它的位置相对于<code>&lt;html&gt;</code></p><p>与文档流无关，因此<strong>不占据空间</strong>。</p><p>绝对定位的元素忽略float属性</p><h4 id="10-4-1-定位点问题"><a href="#10-4-1-定位点问题" class="headerlink" title="10.4.1 定位点问题"></a>10.4.1 定位点问题</h4><p>父级元素<code>con</code>为<code>relative</code>，子级元素<code>child</code>为<code>absolute</code>时:</p><p><code>child</code>的<code>top:0;left:0px;</code>为:</p><ul><li><code>child</code>的<code>margin</code>的左上角</li><li><code>con</code>的<code>content</code>的(0,0)</li></ul><h3 id="10-5-sticky-定位"><a href="#10-5-sticky-定位" class="headerlink" title="10.5 sticky 定位"></a>10.5 sticky 定位</h3><p>元素定位表现为在跨越特定阈值前为相对定位(relative)，之后为固定定位(fixed)。</p><h3 id="10-6-脱离文档流"><a href="#10-6-脱离文档流" class="headerlink" title="10.6 脱离文档流"></a>10.6 脱离文档流</h3><ol><li>float</li><li>absolute</li><li>fixed</li></ol><h2 id="11-CSS-布局-Overflow"><a href="#11-CSS-布局-Overflow" class="headerlink" title="11 CSS 布局 - Overflow"></a>11 CSS 布局 - Overflow</h2><p>用于控制内容溢出元素框时显示的方式。</p><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>visible</td><td>默认值。内容不会被修剪，会呈现在元素框之外。</td></tr><tr><td>hidden</td><td>内容会被修剪，并且其余内容是不可见的。</td></tr><tr><td>scroll</td><td>内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。</td></tr><tr><td>auto</td><td>如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。</td></tr><tr><td>inherit</td><td>规定应该从父元素继承 overflow 属性的值。</td></tr></tbody></table><h2 id="12-Float-浮动"><a href="#12-Float-浮动" class="headerlink" title="12 Float(浮动)"></a>12 Float(浮动)</h2><p>浮动可以理解为让某个div元素脱离标准流，漂浮在标准流之上，和标准流不是一个层次。</p><p>CSS 的 Float（浮动），会使元素向左或向右移动，其周围的元素也会重新排列。</p><p>一个浮动元素会尽量向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。</p><p>浮动元素之后的元素将围绕它。</p><p>浮动元素之前的元素将不会受到影响。</p><p>例如：如果图像是右浮动，下面的文本流将环绕在它左边</p><p><strong>绝对定位</strong>的元素忽略float属性</p><p><code>float:[left,right,none,inherit]</code></p><h3 id="12-1-清除浮动-使用-clear"><a href="#12-1-清除浮动-使用-clear" class="headerlink" title="12.1 清除浮动 - 使用 clear"></a>12.1 清除浮动 - 使用 clear</h3><p>元素浮动之后，周围的元素会重新排列，为了避免这种情况，使用 clear 属性。</p><p>clear 属性指定元素两侧不能出现浮动元素。</p><p>通俗表示：该元素在两侧浮动元素中独占一行</p><p><code>clear:[left,right,both,none,inherit]</code></p><h2 id="13-CSS-布局-水平-amp-垂直对齐"><a href="#13-CSS-布局-水平-amp-垂直对齐" class="headerlink" title="13 CSS 布局 - 水平 &amp; 垂直对齐"></a>13 CSS 布局 - 水平 &amp; 垂直对齐</h2><h3 id="13-1-居中对齐"><a href="#13-1-居中对齐" class="headerlink" title="13.1 居中对齐"></a>13.1 居中对齐</h3><h4 id="13-1-1-元素居中对齐"><a href="#13-1-1-元素居中对齐" class="headerlink" title="13.1.1 元素居中对齐"></a>13.1.1 元素居中对齐</h4><p>元素通过<strong>指定宽度</strong>，并将两边的空外边距平均分配</p><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.center</span> &#123;    <span class="hljs-attribute">margin</span>: auto;    <span class="hljs-attribute">width</span>: <span class="hljs-number">50%</span>;    <span class="hljs-attribute">border</span>: <span class="hljs-number">3px</span> solid green;    <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;&#125;</code></pre></div><h4 id="13-1-2-文本居中对齐"><a href="#13-1-2-文本居中对齐" class="headerlink" title="13.1.2 文本居中对齐"></a>13.1.2 文本居中对齐</h4><p>文本在元素内居中对齐，可以使用 <code>text-align: center;</code></p><h4 id="13-1-3-图片居中对齐"><a href="#13-1-3-图片居中对齐" class="headerlink" title="13.1.3 图片居中对齐"></a>13.1.3 图片居中对齐</h4><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-tag">img</span> &#123;    <span class="hljs-attribute">display</span>: block; <span class="hljs-comment">/*默认inline-block*/</span>    <span class="hljs-attribute">margin</span>: auto;    <span class="hljs-attribute">width</span>: <span class="hljs-number">40%</span>;&#125;</code></pre></div><h3 id="13-2-左右对齐"><a href="#13-2-左右对齐" class="headerlink" title="13.2 左右对齐"></a>13.2 左右对齐</h3><h4 id="13-2-1-使用定位方式"><a href="#13-2-1-使用定位方式" class="headerlink" title="13.2.1 使用定位方式"></a>13.2.1 使用定位方式</h4><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;    <span class="hljs-attribute">position</span>: relative;    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;&#125;<span class="hljs-selector-class">.right</span> &#123;    <span class="hljs-attribute">position</span>: absolute;    <span class="hljs-attribute">right</span>: <span class="hljs-number">0px</span>;    <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#b0e0e6</span>;&#125;</code></pre></div><h4 id="13-2-2-使用-float-方式"><a href="#13-2-2-使用-float-方式" class="headerlink" title="13.2.2 使用 float 方式"></a>13.2.2 使用 float 方式</h4><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.right</span> &#123;    <span class="hljs-attribute">float</span>: right;    <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;    <span class="hljs-attribute">border</span>: <span class="hljs-number">3px</span> solid <span class="hljs-number">#73AD21</span>;    <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;&#125;</code></pre></div><h3 id="13-3-垂直居中对齐"><a href="#13-3-垂直居中对齐" class="headerlink" title="13.3 垂直居中对齐"></a>13.3 垂直居中对齐</h3><h4 id="13-3-1-使用-padding"><a href="#13-3-1-使用-padding" class="headerlink" title="13.3.1 使用 padding"></a>13.3.1 使用 padding</h4><p>实现：上下padding相同，容器不设高度。</p><p>缺点：多行会导致容器变大</p><h4 id="13-3-2-使用-line-height"><a href="#13-3-2-使用-line-height" class="headerlink" title="13.3.2 使用 line-height"></a>13.3.2 使用 line-height</h4><p>设置以百分比计的行高</p><h4 id="13-3-3-使用-position-和-transform"><a href="#13-3-3-使用-position-和-transform" class="headerlink" title="13.3.3 使用 position 和 transform"></a>13.3.3 使用 position 和 transform</h4><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.center</span> &#123;    <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;    <span class="hljs-attribute">position</span>: relative;    <span class="hljs-attribute">border</span>: <span class="hljs-number">3px</span> solid green;&#125;<span class="hljs-selector-class">.center</span> <span class="hljs-selector-tag">p</span> &#123;    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;    <span class="hljs-attribute">position</span>: absolute;    <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;<span class="hljs-comment">/*起始位置到中间*/</span>    <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<span class="hljs-comment">/*起始位置到中间*/</span>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span>, -<span class="hljs-number">50%</span>);<span class="hljs-comment">/*相对自己左移一半，上移一半*/</span>&#125;</code></pre></div><h2 id="14-组合选择符"><a href="#14-组合选择符" class="headerlink" title="14 组合选择符"></a>14 组合选择符</h2><p>后代选择器<code>div p</code></p><p>子元素选择器<code>div&gt;p</code></p><p>相邻兄弟选择器<code>div+p</code>,<strong>只</strong>选择<strong>紧接的下一个</strong>元素，且二者有相同父元素。</p><p>普通兄弟选择器<code>div~p</code>,选取指定元素<strong>之后的所有相邻兄弟</strong>元素。</p><h2 id="15-伪类-Pseudo-classes"><a href="#15-伪类-Pseudo-classes" class="headerlink" title="15 伪类(Pseudo-classes)"></a>15 伪类(Pseudo-classes)</h2><p>CSS伪类是用来添加一些选择器的特殊效果。</p><p>伪类选择元素基于的是当前元素处于的状态,动态变化</p><h3 id="15-1-链接-anchor-伪类"><a href="#15-1-链接-anchor-伪类" class="headerlink" title="15.1 链接(anchor)伪类"></a>15.1 链接(anchor)伪类</h3><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:link</span> &#123;<span class="hljs-attribute">color</span>:<span class="hljs-number">#FF0000</span>;&#125; <span class="hljs-comment">/* 未访问的链接 */</span><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:visited</span> &#123;<span class="hljs-attribute">color</span>:<span class="hljs-number">#00FF00</span>;&#125; <span class="hljs-comment">/* 已访问的链接 */</span><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;<span class="hljs-attribute">color</span>:<span class="hljs-number">#FF00FF</span>;&#125; <span class="hljs-comment">/* 鼠标划过链接 */</span><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:active</span> &#123;<span class="hljs-attribute">color</span>:<span class="hljs-number">#0000FF</span>;&#125; <span class="hljs-comment">/* 已选中的链接 */</span></code></pre></div><p>注意： 在CSS定义中，a:hover 必须被置于 a:link 和 a:visited 之后，才是有效的。</p><p>注意： 在 CSS 定义中，a:active 必须被置于 a:hover 之后，才是有效的。</p><p>注意：伪类的名称不区分大小写。</p><h3 id="15-2-first-child-伪类"><a href="#15-2-first-child-伪类" class="headerlink" title="15.2 :first-child 伪类"></a>15.2 :first-child 伪类</h3><p>选择父元素的第一个子元素</p><p>匹配第一个 <code>&lt;p&gt;</code> 元素</p><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">:first-child</span>&#123;    <span class="hljs-attribute">color</span>:blue;&#125;</code></pre></div><p>匹配所有<code>&lt;p&gt;</code> 元素中的第一个 <code>&lt;i&gt;</code> 元素</p><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> &gt; <span class="hljs-selector-tag">i</span><span class="hljs-selector-pseudo">:first-child</span>&#123;    <span class="hljs-attribute">color</span>:blue;&#125;</code></pre></div><h3 id="15-3-其他"><a href="#15-3-其他" class="headerlink" title="15.3 其他"></a>15.3 其他</h3><p><code>div:first-child</code></p><blockquote><p>属于任意元素的第一个div元素</p></blockquote><p><code>div:last-child</code></p><blockquote><p>属于任意元素的倒数第一个div元素</p></blockquote><p><code>div:nth-child(n)</code></p><blockquote><p>属于任意元素的第n个div元素,没有第0个</p></blockquote><p><code>div:nth-last-child(n)</code></p><blockquote><p>属于任意元素的倒数第n个div元素</p></blockquote><h2 id="16-伪元素-pseudo-element"><a href="#16-伪元素-pseudo-element" class="headerlink" title="16 伪元素(pseudo-element)"></a>16 伪元素(pseudo-element)</h2><p>CSS伪元素是用来添加一些选择器的特殊效果。</p><p>伪元素是<strong>对元素中的特定内容</strong>进行操作，它所操作的层次比伪类更深了一层</p><h3 id="16-1-first-line-伪元素"><a href="#16-1-first-line-伪元素" class="headerlink" title="16.1 :first-line 伪元素"></a>16.1 <code>:first-line</code> 伪元素</h3><p>用于向文本的首行设置特殊样式。</p><h3 id="16-2-first-letter-伪元素"><a href="#16-2-first-letter-伪元素" class="headerlink" title="16.2 :first-letter 伪元素"></a>16.2 <code>:first-letter</code> 伪元素</h3><p>用于向文本的首字母设置特殊样式</p><h3 id="16-3-before-伪元素"><a href="#16-3-before-伪元素" class="headerlink" title="16.3 :before 伪元素"></a>16.3 <code>:before</code> 伪元素</h3><p>可以在元素的内容前面插入新内容</p><h3 id="16-4-after-伪元素"><a href="#16-4-after-伪元素" class="headerlink" title="16.4  :after 伪元素"></a>16.4  <code>:after</code> 伪元素</h3><p>可以在元素的内容之后插入新内容。</p><h2 id="17-导航栏"><a href="#17-导航栏" class="headerlink" title="17 导航栏"></a>17 导航栏</h2><h3 id="17-1-导航栏-链接列表"><a href="#17-1-导航栏-链接列表" class="headerlink" title="17.1 导航栏=链接列表"></a>17.1 导航栏=链接列表</h3><p>导航条基本上是一个链接列表，所以使用 <code>&lt;ul&gt;</code> 和 <code>&lt;li&gt;</code>元素非常有意义：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"#home"</span>&gt;</span>主页<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"#news"</span>&gt;</span>新闻<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"#contact"</span>&gt;</span>联系<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"#about"</span>&gt;</span>关于<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></code></pre></div><h3 id="17-2-首先"><a href="#17-2-首先" class="headerlink" title="17.2 首先"></a>17.2 首先</h3><p>删除<code>margin</code>,<code>padding</code>和设置<code>list-style-type: none;</code></p><h3 id="17-3-垂直导航栏"><a href="#17-3-垂直导航栏" class="headerlink" title="17.3 垂直导航栏"></a>17.3 垂直导航栏</h3><p>在 17.2 的基础上：</p><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span>&#123;    <span class="hljs-attribute">display</span>:block;    <span class="hljs-attribute">width</span>:<span class="hljs-number">60px</span>;&#125;</code></pre></div><p>显示块元素的链接，<strong>让整体变为可点击链接区域</strong>（不只是文本）</p><p>继续优化：</p><div class="hljs"><pre><code class="hljs css"><span class="hljs-comment">/*以下为添加的内容*/</span><span class="hljs-selector-tag">ul</span> &#123;    <span class="hljs-comment">/* list-style-type: none; */</span>    <span class="hljs-comment">/* margin: 0; */</span>    <span class="hljs-comment">/* padding: 0; */</span>    <span class="hljs-comment">/* width: 200px; */</span>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#f1f1f1</span>;&#125;<span class="hljs-selector-tag">li</span> <span class="hljs-selector-tag">a</span> &#123;    <span class="hljs-comment">/* display: block; */</span>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#000</span>;    <span class="hljs-attribute">padding</span>: <span class="hljs-number">8px</span> <span class="hljs-number">16px</span>;    <span class="hljs-attribute">text-decoration</span>: none;&#125;<span class="hljs-selector-tag">li</span> <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#555</span>;    <span class="hljs-attribute">color</span>: white;&#125;<span class="hljs-selector-class">.active</span> &#123;    <span class="hljs-comment">/*当前激活的导航条*/</span>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#4CAF50</span>;    <span class="hljs-attribute">color</span>: white;&#125;</code></pre></div><p>全屏的固定导航条：</p><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-tag">ul</span> &#123;    <span class="hljs-attribute">list-style-type</span>: none;    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;    <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;    <span class="hljs-attribute">width</span>: <span class="hljs-number">25%</span>;    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#f1f1f1</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>; <span class="hljs-comment">/* 全屏高度 */</span>    <span class="hljs-attribute">position</span>: fixed; <span class="hljs-comment">/*不跟随滚动条移动*/</span>    <span class="hljs-attribute">overflow</span>: auto; <span class="hljs-comment">/* 如果导航栏选项多，允许滚动 */</span>&#125;</code></pre></div><h3 id="17-4-水平导航栏"><a href="#17-4-水平导航栏" class="headerlink" title="17.4 水平导航栏"></a>17.4 水平导航栏</h3><p>有两种方法创建横向导航栏。使用内联(inline)或浮动(float)的列表项。</p><p>这两种方法都很好，但如果你想链接到具有相同的大小，你必须使用浮动的方法。</p><h4 id="17-4-1-内联列表项"><a href="#17-4-1-内联列表项" class="headerlink" title="17.4.1 内联列表项"></a>17.4.1 内联列表项</h4><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-tag">li</span>&#123;    <span class="hljs-attribute">display</span>:inline;&#125;</code></pre></div><h4 id="17-4-2-浮动列表项"><a href="#17-4-2-浮动列表项" class="headerlink" title="17.4.2 浮动列表项"></a>17.4.2 浮动列表项</h4><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-tag">li</span>&#123;    <span class="hljs-attribute">float</span>:left;&#125;<span class="hljs-selector-tag">a</span>&#123;    <span class="hljs-attribute">display</span>:block;    <span class="hljs-attribute">width</span>:<span class="hljs-number">60px</span>;&#125;</code></pre></div><h4 id="17-4-3-样式"><a href="#17-4-3-样式" class="headerlink" title="17.4.3 样式"></a>17.4.3 样式</h4><p>基本同上</p><h2 id="18-下拉菜单"><a href="#18-下拉菜单" class="headerlink" title="18 下拉菜单"></a>18 下拉菜单</h2><ol><li>菜单整体<code>position: relative;display: inline-block;</code></li><li><code>dropdown-content</code>设置<code>display: none;</code></li><li>hover时变成block，<code>.dropdown:hover .dropdown-content {display: block;}</code></li></ol><p>实例解析</p><p><strong>HTML 部分</strong>：</p><p>我们可以使用<strong>任何的 HTML 元素来打开下拉菜单</strong>，如：<code>&lt;span&gt;</code>, 或  <code>&lt;button&gt;</code> 元素。</p><p>使用容器元素 (如： <code>&lt;div&gt;</code>) 来创建下拉菜单的内容，并放在任何你想放的位置上。</p><p>使用 <code>&lt;div&gt;</code> 元素来包裹这些元素，并使用 CSS 来设置下拉内容的样式。</p><p><strong>CSS 部分</strong>：</p><p><code>.dropdown</code> 类使用 <code>position:relative</code>, 这将设置下拉菜单的内容放置在下拉按钮 (使用 position:absolute) 的右下角位置。</p><p><code>.dropdown-content</code> 类中是实际的下拉菜单。默认是隐藏的，在鼠标移动到指定元素后会显示。 注意 <code>min-width</code> 的值设置为 <code>160px</code>。你可以随意修改它。 注意: 如果你想设置下拉内容与下拉按钮的宽度一致，可设置 <code>width</code> 为 100% ( <code>overflow:auto</code> 设置可以在小尺寸屏幕上滚动)。</p><p>我们使用 <code>box-shadow</code> 属性让下拉菜单看起来像一个”卡片”。</p><p><code>:hover</code> 选择器用于在用户将鼠标移动到下拉按钮上时显示下拉菜单</p><h2 id="19-提示工具-Tooltip"><a href="#19-提示工具-Tooltip" class="headerlink" title="19 提示工具(Tooltip)"></a>19 提示工具(Tooltip)</h2><p>hover时的提示气球</p><p>核心：</p><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.tooltip</span> <span class="hljs-selector-class">.tooltiptext</span> &#123;<span class="hljs-attribute">visibility</span>: hidden;<span class="hljs-attribute">position</span>: absolute;<span class="hljs-attribute">z-index</span>: <span class="hljs-number">1</span>;&#125;<span class="hljs-selector-class">.tooltip</span><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-selector-class">.tooltiptext</span> &#123;    <span class="hljs-attribute">visibility</span>: visible;&#125;</code></pre></div><h2 id="20-媒体类型-media"><a href="#20-媒体类型-media" class="headerlink" title="20 媒体类型@media"></a>20 媒体类型<code>@media</code></h2><h2 id="21-CSS-属性-选择器"><a href="#21-CSS-属性-选择器" class="headerlink" title="21 CSS 属性 选择器"></a>21 CSS 属性 选择器</h2><div class="hljs"><pre><code class="hljs css"><span class="hljs-comment">/*把包含标题（title）的所有元素变为蓝色*/</span><span class="hljs-selector-attr">[title]</span>&#123;    <span class="hljs-attribute">color</span>:blue;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs css"><span class="hljs-comment">/*改变了标题title='runoob'元素的边框样式*/</span><span class="hljs-selector-attr">[title=runoob]</span>&#123;    <span class="hljs-attribute">border</span>:<span class="hljs-number">5px</span> solid green;&#125;</code></pre></div><h3 id="21-1-属性和值的选择器-多值"><a href="#21-1-属性和值的选择器-多值" class="headerlink" title="21.1 属性和值的选择器 - 多值"></a>21.1 属性和值的选择器 - 多值</h3><div class="hljs"><pre><code class="hljs css"><span class="hljs-comment">/*title中包含hello的*/</span><span class="hljs-selector-attr">[title~=hello]</span> &#123; <span class="hljs-attribute">color</span>:blue; &#125;<span class="hljs-comment">/*选择 lang 属性以 en 为开头的所有元素*/</span><span class="hljs-selector-attr">[lang|=en]</span></code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS 渲染原理以及优化策略</title>
    <link href="/2020/07/14/notes/web/CSS/CSS%20%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/"/>
    <url>/2020/07/14/notes/web/CSS/CSS%20%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s?__biz=MzI4NDYxNTM0OQ==&amp;mid=2247484761&amp;idx=1&amp;sn=6238b8343d9040e2c8d2274adccd3f66&amp;chksm=ebf9f283dc8e7b9580293380f77d6458af960eccfea7709bd9f188bc3e20646c3fc0c03760e5&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;sharer_sharetime=1586604482004&amp;sharer_shareid=c6e16d86591fc6d7eac5c342d513ce8e#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzI4NDYxNTM0OQ==&amp;mid=2247484761&amp;idx=1&amp;sn=6238b8343d9040e2c8d2274adccd3f66&amp;chksm=ebf9f283dc8e7b9580293380f77d6458af960eccfea7709bd9f188bc3e20646c3fc0c03760e5&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;sharer_sharetime=1586604482004&amp;sharer_shareid=c6e16d86591fc6d7eac5c342d513ce8e#rd</a></p><ol><li>HTML Parser 生成的 DOM 树；</li><li>CSS Parser 生成的 Style Rules（CSSOM 树）；</li><li>在这之后，DOM 树与 Style Rules 会生成一个新的对象，也就是我们常说的 Render Tree 渲染树，结合 Layout 绘制在屏幕上，从而展现出来。</li></ol><h2 id="1-CSS-特性"><a href="#1-CSS-特性" class="headerlink" title="1 CSS 特性"></a>1 CSS 特性</h2><h3 id="1-1-优先级"><a href="#1-1-优先级" class="headerlink" title="1.1 优先级"></a>1.1 优先级</h3><table><thead><tr><th>选择器</th><th>权重</th></tr></thead><tbody><tr><td>!important</td><td>1/0(无穷大)</td></tr><tr><td>内联样式</td><td>1000</td></tr><tr><td>ID</td><td>100</td></tr><tr><td>伪类&gt;类&gt;属性</td><td>10</td></tr><tr><td>元素/伪元素</td><td>1</td></tr><tr><td>通配符/子选择器 &gt; 继承 &gt; 浏览器默认属性/相邻选择器</td><td>0</td></tr></tbody></table><h3 id="1-2-继承性"><a href="#1-2-继承性" class="headerlink" title="1.2 继承性"></a>1.2 继承性</h3><ul><li>继承得到的样式的优先级是最低的，即使带有<code>!important</code></li><li>在存在多个继承样式时，层级关系距离当前元素最近的父级元素的继承样式，具有相对最高的优先级。</li></ul><p>哪些属性是可以继承?</p><ul><li>font-family、font-size、font-weight 等 f 开头的 CSS 样式。</li><li>text-align、text-indent 等 t 开头的样式。</li><li>color</li><li>等等</li></ul><h3 id="1-3-层叠性"><a href="#1-3-层叠性" class="headerlink" title="1.3 层叠性"></a>1.3 层叠性</h3><p>…</p><h2 id="2-CSS-语法解析过程"><a href="#2-CSS-语法解析过程" class="headerlink" title="2 CSS 语法解析过程"></a>2 CSS 语法解析过程</h2><p>将 CSS 文件解析成 StyleSheet 对象，且每个对象都包含 CSS 规则。CSS 规则对象则包含选择器和声明对象，以及其他与 CSS 语法对应的对象。</p><p><code>document.styleSheets</code></p><h2 id="3-CSS-选择器执行顺序"><a href="#3-CSS-选择器执行顺序" class="headerlink" title="3 CSS 选择器执行顺序"></a>3 CSS 选择器执行顺序</h2><p>渲染引擎解析 CSS 选择器时是从右往左解析,因为父元素唯一，子元素不一定唯一</p><h2 id="4-高效的-ComputedStyle"><a href="#4-高效的-ComputedStyle" class="headerlink" title="4 高效的 ComputedStyle"></a>4 高效的 ComputedStyle</h2><p>如果两个或多个 Element 的 ComputedStyle 不通过计算可以确认他们相等，那么这些 ComputedStyle 相等的 Elements 只会计算一次样式，其余的仅仅共享该 ComputedStyle。</p><p>如何高效共享 Computed Style ？</p><ol><li>TagName 和 Class 属性必须一样。</li><li>不能有 Style 属性。哪怕 Style 属性相等，他们也不共享。</li><li>不能使用 Sibling selector，譬如: first-child、 :last-selector、 + selector。</li><li>mappedAttribute 必须相等。</li></ol><h2 id="5-CSS-书写顺序对性能有影响吗？"><a href="#5-CSS-书写顺序对性能有影响吗？" class="headerlink" title="5 CSS 书写顺序对性能有影响吗？"></a>5 CSS 书写顺序对性能有影响吗？</h2><p>浏览器并不是一获取到 CSS 样式就立马开始解析，而是根据 CSS 样式的书写顺序将之按照 DOM 树的结构分布渲染样式，然后开始遍历每个树结点的 CSS 样式进行解析，此时的 CSS 样式的遍历顺序完全是按照之前的书写顺序。</p><p>例子：</p><div class="hljs"><pre><code class="hljs css"><span class="hljs-comment">/* 当浏览器解析到 position 的时候突然发现该元素是绝对定位元素需要脱离文档流，而之前却是按照普通元素进行解析的，所以不得不重新渲染。 */</span><span class="hljs-selector-tag">width</span>: 150<span class="hljs-selector-tag">px</span>;<span class="hljs-selector-tag">height</span>: 150<span class="hljs-selector-tag">px</span>;<span class="hljs-selector-tag">font-size</span>: 24<span class="hljs-selector-tag">px</span>;<span class="hljs-selector-tag">position</span>: <span class="hljs-selector-tag">absolute</span>;</code></pre></div><div class="hljs"><pre><code class="hljs css"><span class="hljs-comment">/* 调整 */</span><span class="hljs-selector-tag">position</span>: <span class="hljs-selector-tag">absolute</span>;<span class="hljs-selector-tag">width</span>: 150<span class="hljs-selector-tag">px</span>;<span class="hljs-selector-tag">height</span>: 150<span class="hljs-selector-tag">px</span>;<span class="hljs-selector-tag">font-size</span>: 24<span class="hljs-selector-tag">px</span>;</code></pre></div><h3 id="5-1-在实际开发过程中，我们如何能保证自己的书写顺序是最优呢？"><a href="#5-1-在实际开发过程中，我们如何能保证自己的书写顺序是最优呢？" class="headerlink" title="5.1 在实际开发过程中，我们如何能保证自己的书写顺序是最优呢？"></a>5.1 在实际开发过程中，我们如何能保证自己的书写顺序是最优呢？</h3><p>顺序大致如下：</p><ol><li>定位属性(position  display  float  left  top  right  bottom   overflow  clear   z-index)</li><li>自身属性(width  height  padding  border  margin   background)</li><li>文字样式</li><li>文本属性</li><li>CSS3 中新增属性</li></ol><p>当然，我们需要知道这个规则就够了，剩下的可以交给一些插件去做，譬如 CSSLint</p><h2 id="6-优化策略"><a href="#6-优化策略" class="headerlink" title="6 优化策略"></a>6 优化策略</h2><ol><li>使用 id selector 非常的高效</li><li>避免深层次的css选择器</li><li>不要使用 attribute selector</li><li>将浏览器前缀置于前面，将标准样式属性置于最后</li><li>遵守 CSSLint 规则</li><li>减少 CSS 文档体积<ol><li>移除空的 CSS 规则（Remove empty rules）。</li><li>值为 0 不需要单位。</li><li>使用缩写。</li><li>属性值为浮动小数 0.xx，可以省略小数点之前的 0。</li><li>不给 h1-h6 元素定义过多的样式。</li></ol></li><li>CSS Will Change<ol><li><code>WillChange</code> 属性，允许作者提前告知浏览器的默认样式，使用一个专用的属性来通知浏览器留意接下来的变化，从而优化和分配内存。</li></ol></li><li>不要使用 <code>@import</code><ol><li>使用 <code>@import</code> 引入 CSS 会进行懒加载，影响浏览器的并行下载。</li></ol></li><li>避免过分回流/重排（Reflow）</li><li>高效利用 computedStyle</li><li>减少昂贵属性<ol><li>box-shadow。</li><li>border-radius。</li><li>filter。</li><li>:nth-child。</li></ol></li><li>依赖继承(如果某些属性可以继承，那么自然没有必要再写一遍。)</li><li>遵守 CSS 顺序规则</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>优化</tag>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS Modules</title>
    <link href="/2020/07/14/notes/web/CSS/CSS%20Modules/"/>
    <url>/2020/07/14/notes/web/CSS/CSS%20Modules/</url>
    
    <content type="html"><![CDATA[<p><a href="https://segmentfault.com/a/1190000014722978" target="_blank" rel="noopener">https://segmentfault.com/a/1190000014722978</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BFC和IFC</title>
    <link href="/2020/07/14/notes/web/CSS/BFC%E5%92%8CIFC/"/>
    <url>/2020/07/14/notes/web/CSS/BFC%E5%92%8CIFC/</url>
    
    <content type="html"><![CDATA[<h2 id="BFC块格式化上下文（Block-Formatting-Context，BFC）"><a href="#BFC块格式化上下文（Block-Formatting-Context，BFC）" class="headerlink" title="BFC块格式化上下文（Block Formatting Context，BFC）"></a>BFC块格式化上下文（Block Formatting Context，BFC）</h2><ul><li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然；</li><li>计算BFC的高度时，考虑BFC所包含的所有元素，连浮动元素也参与计算；</li></ul><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><ul><li>根元素(<code>&lt;html&gt;</code>)</li><li>浮动元素（元素的 float 不是 none）</li><li>绝对定位元素（元素的 position 为 absolute 或 fixed）</li><li>行内块元素（元素的 display 为 inline-block）</li><li>表格单元格（元素的 display 为 table-cell）</li><li>表格标题（元素的 display 为 table-caption）</li><li>匿名表格单元格元素（元素的 display 为 table、inline-table）</li><li>display 值为 flow-root 的元素（兼容性不好）</li><li>弹性元素（display 为 flex 或 inline-flex 元素的直接子元素）</li><li>元素（display 为 grid 或 inline-grid 元素的直接子元素）</li><li>overflow 值不为 visible 的块元素</li></ul><p>主要：</p><ul><li>overflow属性不为visible</li><li>float（不为 none 即可）<ul><li>left</li><li>right</li></ul></li><li>position<ul><li>absolute</li><li>fixed</li><li>sticky</li></ul></li><li>display<ul><li>inline-block</li><li>flex、inline-flex</li><li>grid、inline-grid</li><li>table、table-cell、table-caption</li><li>flow-root</li></ul></li></ul><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul><li>自适应多栏布局</li><li>防止外边距折叠</li><li>清除浮动</li><li>阻止行内元素环绕浮动元素</li></ul><h2 id="IFC-Inline-Formatting-Contexts-直译为”内联格式化上下文”"><a href="#IFC-Inline-Formatting-Contexts-直译为”内联格式化上下文”" class="headerlink" title="IFC(Inline Formatting Contexts) 直译为”内联格式化上下文”"></a>IFC(Inline Formatting Contexts) 直译为”内联格式化上下文”</h2><p>IFC的line box（线框）高度由其包含行内元素中最高的实际高度计算而来（不受到竖直方向的padding/margin影响）</p>]]></content>
    
    
    
    <tags>
      
      <tag>css</tag>
      
      <tag>bfc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一些面试题</title>
    <link href="/2020/07/14/notes/web/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2020/07/14/notes/web/%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="1-将数组扁平化并去除其中重复数据，最终得到一个升序且不重复的数组"><a href="#1-将数组扁平化并去除其中重复数据，最终得到一个升序且不重复的数组" class="headerlink" title="1 将数组扁平化并去除其中重复数据，最终得到一个升序且不重复的数组"></a>1 将数组扁平化并去除其中重复数据，最终得到一个升序且不重复的数组</h2><p><code>arr.toString().split(&quot;,&quot;)</code></p><p><code>arr.flat(Infinity)</code></p><p><code>[].concat.apply([],arr)</code></p><p><code>[].concat(...a)</code></p><h3 id="1-1-去重"><a href="#1-1-去重" class="headerlink" title="1.1 去重"></a>1.1 去重</h3><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">array_unique</span> (<span class="hljs-params">arr</span>) </span>&#123;  <span class="hljs-keyword">let</span> len = arr.length  <span class="hljs-keyword">if</span> (!len) &#123;    <span class="hljs-keyword">return</span> []  &#125;  <span class="hljs-keyword">let</span> tmp = []  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;    <span class="hljs-keyword">if</span> (tmp.findIndex(<span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> <span class="hljs-built_in">JSON</span>.stringify(v) === <span class="hljs-built_in">JSON</span>.stringify(arr[i])) === <span class="hljs-number">-1</span>) &#123;      tmp.push(arr[i])    &#125;  &#125;  <span class="hljs-keyword">return</span> tmp&#125;</code></pre></div><h2 id="2-重排，重绘"><a href="#2-重排，重绘" class="headerlink" title="2 重排，重绘"></a>2 重排，重绘</h2><p>执行下面代码会发生什么?</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">document</span>.body.bgColor=<span class="hljs-string">"black"</span><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">1000000000</span>;i++)&#123;    i+<span class="hljs-number">1</span>&#125;<span class="hljs-built_in">document</span>.body.bgColor=<span class="hljs-string">"red"</span></code></pre></div><p>答案：(不会变黑)卡一会，再变红</p><h2 id="3-当键入网址后，到网页显示，其间发生了什么"><a href="#3-当键入网址后，到网页显示，其间发生了什么" class="headerlink" title="3 当键入网址后，到网页显示，其间发生了什么"></a>3 当键入网址后，到网页显示，其间发生了什么</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&amp;mid=2247487853&amp;idx=1&amp;sn=482b8466277c412f5a3c9b249bb7515c&amp;chksm=fa0e7eeccd79f7fa45d90b6ff409a8fee442d5ccb7c1cf774fc541405c03ad75c8b652f2acd1&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;sharer_sharetime=1585113462735&amp;sharer_shareid=7af7c97c59bcd51392140a2bf05dcfd5#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&amp;mid=2247487853&amp;idx=1&amp;sn=482b8466277c412f5a3c9b249bb7515c&amp;chksm=fa0e7eeccd79f7fa45d90b6ff409a8fee442d5ccb7c1cf774fc541405c03ad75c8b652f2acd1&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;sharer_sharetime=1585113462735&amp;sharer_shareid=7af7c97c59bcd51392140a2bf05dcfd5#rd</a></p><ol><li>浏览器解析 URL</li><li>浏览器确定了 Web 服务器和文件名，根据这些信息来生成 HTTP 请求</li><li>DNS 服务器，查询服务器域名对于的 IP 地址<ol><li>根域是在最顶层，它的下一层就是 com 等顶级域，再下面是 xxx.com</li><li>根域的 DNS 服务器信息保存在互联网中所有的 DNS 服务器中。这样一来，任何 DNS 服务器就都可以找到并访问根域 DNS 服务器了。</li><li>客户端只要能够找到任意一台 DNS 服务器，就可以通过它找到根域 DNS 服务器，然后再一路顺藤摸瓜找到位于下层的某台目标 DNS 服务器。</li></ol></li><li>通过 DNS 获取到 IP 后，就可以把 HTTP 的传输工作交给操作系统中的协议栈。<ol><li>HTTP 是基于 TCP 协议传输的,三次握手,TCP 报文生成</li><li>TCP 模块在各阶段操作时，都需要委托 <strong>IP 模块</strong>将数据封装成网络包发送给通信对象。</li><li>生成了 IP 头部之后，接下来网络包还需要在 IP 头部的前面加上 MAC 头部用于两点传输。</li><li>…</li></ol></li><li>通过交换机，交换机工作在 MAC 层</li><li>路由器，ip层，并在此被转发到下一个路由器或目标设备</li><li>服务器代理，负载均衡</li><li>到达服务器，逐步删除头部，获取信息</li><li>通过协议栈返回客户端</li><li>最后，向服务器发起了 TCP 四次挥手，至此双方的连接就断开了。</li><li>解析页面<ol><li>解析HTML，构建DOM树</li><li>解析CSS，生成CSS规则树</li><li>合并DOM树和CSS规则，生成render树</li><li>布局render树（Layout/reflow），负责各元素尺寸、位置的计算</li><li>绘制render树（paint），绘制页面像素信息</li><li>浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上</li></ol></li><li>在解析html时，会遇到一些资源连接<ol><li>遇到上述的外链时，会单独开启一个下载线程去下载资源</li><li>css资源，下载异步，不会阻塞DOM树，会阻塞渲染</li><li>JS脚本资源，阻塞浏览器的解析，加上defer或async属性，这样脚本就变成异步</li><li>img图片类资源，直接就是异步下载，不会阻塞解析，下载完毕后直接用图片替换原有src的地方</li></ol></li><li>跨域</li><li>http缓存</li></ol><h2 id="4-考察this"><a href="#4-考察this" class="headerlink" title="4 考察this"></a>4 考察this</h2><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">A</span>(<span class="hljs-params"></span>) </span>&#123;    alert(<span class="hljs-number">1</span>)&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Fn</span>(<span class="hljs-params"></span>) </span>&#123;    A = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        alert(<span class="hljs-number">2</span>)    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;&#125;Fn.A = AFn.prototype = &#123;    A: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;        alert(<span class="hljs-number">3</span>)    &#125;&#125;A()Fn.A()Fn().A()<span class="hljs-keyword">new</span> Fn.A()<span class="hljs-keyword">new</span> Fn().A()<span class="hljs-keyword">new</span> <span class="hljs-keyword">new</span> Fn().A()<span class="hljs-comment">// 结果：</span><span class="hljs-comment">// "1"</span><span class="hljs-comment">// "1"</span><span class="hljs-comment">// "2"</span><span class="hljs-comment">// "1"</span><span class="hljs-comment">// "3"</span><span class="hljs-comment">// TypeError:箭头函数不能被new,追加为什么</span></code></pre></div><h2 id="5-考察this"><a href="#5-考察this" class="headerlink" title="5 考察this"></a>5 考察this</h2><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> x = <span class="hljs-number">2</span>;<span class="hljs-keyword">var</span> y = &#123;    x: <span class="hljs-number">3</span>,    z: (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) </span>&#123;        <span class="hljs-keyword">this</span>.x *= x;        x += <span class="hljs-number">2</span>;        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) </span>&#123;            <span class="hljs-keyword">this</span>.x *= n;            x += <span class="hljs-number">3</span>;            <span class="hljs-built_in">console</span>.log(x);        &#125;    &#125;)(x)&#125;;<span class="hljs-keyword">var</span> m = y.z;m(<span class="hljs-number">4</span>);y.z(<span class="hljs-number">5</span>);<span class="hljs-built_in">console</span>.log(x, y.x)<span class="hljs-comment">// 7</span><span class="hljs-comment">// 10</span><span class="hljs-comment">// 16 15</span></code></pre></div><h2 id="6-10"><a href="#6-10" class="headerlink" title="6 ++[[]][+[]]+[+[]]==10?"></a>6 ++[[]][+[]]+[+[]]==10?</h2><p><a href="./js/隐式转换.md">隐式转换</a></p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 1</span>(++[[]][+[]])+([+[]])<span class="hljs-comment">// 2</span>(++[[]][+[]]) + [<span class="hljs-number">0</span>]<span class="hljs-comment">// 3</span>(++[[]][<span class="hljs-number">0</span>]) + [<span class="hljs-number">0</span>]<span class="hljs-comment">// 3.1</span><span class="hljs-comment">// ++([[]][0])在浏览器不报错，而++[]报错</span><span class="hljs-comment">// 4</span><span class="hljs-comment">// 4.1</span><span class="hljs-keyword">var</span> a = [[]][<span class="hljs-number">0</span>];    <span class="hljs-comment">// []</span>++a;                <span class="hljs-comment">// [] + 1</span><span class="hljs-comment">// 4.2</span>([] + <span class="hljs-number">1</span>) + [<span class="hljs-number">0</span>]<span class="hljs-comment">// 5</span><span class="hljs-string">"1"</span> + [<span class="hljs-number">0</span>]<span class="hljs-comment">// 6</span><span class="hljs-string">"10"</span></code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一些性能优化方法</title>
    <link href="/2020/07/14/notes/web/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <url>/2020/07/14/notes/web/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.im/post/5e7723636fb9a07cc321675d" target="_blank" rel="noopener">https://juejin.im/post/5e7723636fb9a07cc321675d</a></p><p>大致可以划分为几类：度量标准、编码优化、静态资源优化、交付优化、构建优化、性能监控。</p><h2 id="1-度量标准与设定目标"><a href="#1-度量标准与设定目标" class="headerlink" title="1. 度量标准与设定目标"></a>1. 度量标准与设定目标</h2><p>在进行性能优化之前，我们需要为应用选择一个正确的度量标准（性能指标）以及设定一个合理的优化目标。</p><h2 id="2-编码优化"><a href="#2-编码优化" class="headerlink" title="2. 编码优化"></a>2. 编码优化</h2><p>涉及到应用的运行时性能</p><h3 id="2-1-数据读取速度"><a href="#2-1-数据读取速度" class="headerlink" title="2.1 数据读取速度"></a>2.1 数据读取速度</h3><ul><li><strong>字面量与局部变量</strong>的访问速度最快，数组元素和对象成员相对较慢</li><li>变量从局部作用域到全局作用域的搜索过程越长速度越慢</li><li>对象<strong>嵌套的越深</strong>，读取速度就<strong>越慢</strong></li><li>对象在原型链中存在的位置越深，找到它的速度就越慢</li></ul><h3 id="2-2-DOM"><a href="#2-2-DOM" class="headerlink" title="2.2 DOM"></a>2.2 DOM</h3><p>DOM操作的代价非常昂贵</p><ul><li>在JS中对DOM进行访问的代价非常高。请<strong>尽可能减少访问DOM的次数</strong>（建议缓存DOM属性和元素、把DOM集合的长度缓存到变量中并在迭代中使用。读变量比读DOM的速度要快很多。）</li><li>重排与重绘的代价非常昂贵。如果操作需要进行多次重排与重绘，<strong>建议先让元素脱离文档流，处理完毕后再让元素回归文档流</strong>，这样浏览器只会进行两次重排与重绘（脱离时和回归时）。</li><li>善于使用<strong>事件委托</strong></li></ul><h3 id="2-3-流程控制"><a href="#2-3-流程控制" class="headerlink" title="2.3 流程控制"></a>2.3 流程控制</h3><ul><li><strong>避免使用<code>for...in</code></strong>（它能枚举到原型，所以很慢）</li><li>在JS中倒序循环会略微提升性能</li><li>减少迭代的次数</li><li><strong>基于循环的迭代比基于函数的迭代快</strong>8倍</li><li><strong>用Map</strong>表代替大量的if-else和switch会提升性能</li></ul><h2 id="3-静态资源优化"><a href="#3-静态资源优化" class="headerlink" title="3. 静态资源优化"></a>3. 静态资源优化</h2><h3 id="3-1-使用Brotli或Zopfli进行纯文本压缩"><a href="#3-1-使用Brotli或Zopfli进行纯文本压缩" class="headerlink" title="3.1 使用Brotli或Zopfli进行纯文本压缩"></a>3.1 使用Brotli或Zopfli进行纯文本压缩</h3><h3 id="3-2-图片优化"><a href="#3-2-图片优化" class="headerlink" title="3.2 图片优化"></a>3.2 图片优化</h3><p>尽可能通过<code>srcset</code>，<code>sizes</code>和<code>&lt;picture&gt;</code>元素使用响应式图片。还可以通过<code>&lt;picture&gt;</code>元素使用WebP格式的图像。</p><p><a href="https://github.com/berwin/Blog/issues/28" target="_blank" rel="noopener">图像优化原理</a></p><h2 id="4-交付优化"><a href="#4-交付优化" class="headerlink" title="4. 交付优化"></a>4. 交付优化</h2><p>交付优化指的是对页面加载资源以及用户与网页之间的交付过程进行优化。</p><h3 id="4-1-异步无阻塞加载JS"><a href="#4-1-异步无阻塞加载JS" class="headerlink" title="4.1 异步无阻塞加载JS"></a>4.1 异步无阻塞加载JS</h3><p>将Script标签放到页面的最底部。但是更好的做法是异步无阻塞加载JS。</p><p>有多种无阻塞加载JS的方法：defer、async、动态创建script标签、使用XHR异步请求JS代码并注入到页面。</p><p>但更推荐的做法是使用defer或async。如果使用defer或async请将Script标签放到head标签中，以便让浏览器更早地发现资源并在后台线程中解析并开始加载JS。</p><h3 id="4-2-使用Intersection-Observer实现懒加载"><a href="#4-2-使用Intersection-Observer实现懒加载" class="headerlink" title="4.2 使用Intersection Observer实现懒加载"></a>4.2 使用<code>Intersection Observer</code>实现懒加载</h3><p>懒加载是一个比较常用的性能优化手段，下面列出了一些常用的做法：</p><p>可以通过<code>Intersection Observer</code>延迟加载图片、视频、广告脚本、或任何其他资源。<br>可以先加载低质量或模糊的图片，当图片加载完毕后再使用完整版图片替换它。</p><h3 id="4-3-优先加载关键的CSS"><a href="#4-3-优先加载关键的CSS" class="headerlink" title="4.3 优先加载关键的CSS"></a>4.3 优先加载关键的CSS</h3><p>CSS资源的加载对浏览器渲染的影响很大，默认情况下浏览器只有在完成<code>&lt;head&gt;</code>标签中CSS的加载与解析之后才会渲染页面。如果CSS文件过大，用户就需要等待很长的时间才能看到渲染结果。针对这种情况可以将首屏渲染必须用到的CSS提取出来内嵌到<code>&lt;head&gt;</code>中，然后再将剩余部分的CSS用异步的方式加载。</p><h3 id="4-4-资源提示（Resource-Hints）"><a href="#4-4-资源提示（Resource-Hints）" class="headerlink" title="4.4 资源提示（Resource Hints）"></a>4.4 资源提示（Resource Hints）</h3><p>帮助浏览器决定应该连接到哪些源，以及应该获取与预处理哪些资源来提升页面性能。</p><h3 id="4-5-Preload"><a href="#4-5-Preload" class="headerlink" title="4.5 Preload"></a>4.5 Preload</h3><p>通过一个现有元素（例如：img，script，link）声明资源会将获取与执行耦合在一起。然而应用可能只是想要先获取资源，当满足某些条件时再执行资源。</p><p>Preload提供了预获取资源的能力，可以将获取资源的行为从资源执行中分离出来。因此，Preload可以构建自定义的资源加载与执行。</p><p>例如，应用可以使用Preload进行CSS资源的预加载、并且同时具备：高优先级、不阻塞渲染等特性。然后应用程序在合适的时间使用CSS资源：</p><h3 id="4-6-快速响应的用户界面"><a href="#4-6-快速响应的用户界面" class="headerlink" title="4.6 快速响应的用户界面"></a>4.6 快速响应的用户界面</h3><p>解决方案是可以将一个大任务拆分成多个小任务分布在不同的Macrotask中执行（通俗的说是将大的JS任务拆分成多个小任务异步执行）。或者使用WebWorkers，它可以在UI线程外执行JS代码运算，不会阻塞UI线程，所以不会影响用户体验。</p><h2 id="5-构建优化"><a href="#5-构建优化" class="headerlink" title="5. 构建优化"></a>5. 构建优化</h2><h3 id="5-1-使用预编译"><a href="#5-1-使用预编译" class="headerlink" title="5.1 使用预编译"></a>5.1 使用预编译</h3><h3 id="5-2-使用-Tree-shaking、Scope-hoisting、Code-splitting"><a href="#5-2-使用-Tree-shaking、Scope-hoisting、Code-splitting" class="headerlink" title="5.2 使用 Tree-shaking、Scope hoisting、Code-splitting"></a>5.2 使用 Tree-shaking、Scope hoisting、Code-splitting</h3><p>Tree-shaking是一种在构建过程中清除无用代码的技术。使用Tree-shaking可以减少构建后文件的体积。<br>目前Webpack与Rollup都支持Scope Hoisting。它们可以检查import链，并尽可能的将散乱的模块放到一个函数中，前提是不能造成代码冗余。所以只有被引用了一次的模块才会被合并。使用Scope Hoisting可以让代码体积更小并且可以降低代码在运行时的内存开销，同时它的运行速度更快。前面2.1节介绍了变量从局部作用域到全局作用域的搜索过程越长执行速度越慢，Scope Hoisting可以减少搜索时间。<br>code-splitting是Webpack中最引人注目的特性之一。此特性能够把代码分离到不同的bundle中，然后可以按需加载或并行加载这些文件。code-splitting可以用于获取更小的bundle，以及控制资源加载优先级，如果使用合理，会极大影响加载时间。</p><h3 id="5-3-服务端渲染（SSR）"><a href="#5-3-服务端渲染（SSR）" class="headerlink" title="5.3 服务端渲染（SSR）"></a>5.3 服务端渲染（SSR）</h3><p>服务端渲染（Server Side Render，简称SSR）的意义在于弥补主要内容在前端渲染的成本，减少白屏时间，提升首次有效绘制的速度。可以使用服务端渲染来获得更快的首次有效绘制。</p><h3 id="5-4-使用import函数动态导入模块"><a href="#5-4-使用import函数动态导入模块" class="headerlink" title="5.4 使用import函数动态导入模块"></a>5.4 使用import函数动态导入模块</h3><p>使用import函数可以在运行时动态地加载ES2015模块，从而实现按需加载的需求。</p><h3 id="5-5-使用HTTP缓存头"><a href="#5-5-使用HTTP缓存头" class="headerlink" title="5.5 使用HTTP缓存头"></a>5.5 使用HTTP缓存头</h3><p>正确设置<code>expires</code>，<code>cache-control</code>和其他HTTP缓存头。</p><p>推荐使用<code>Cache-control</code>: <code>immutable</code>避免重新验证</p><h2 id="6-其他"><a href="#6-其他" class="headerlink" title="6. 其他"></a>6. 其他</h2><ul><li>HTTP2</li><li>使用最高级的CDN（付费的比免费的强的多）</li><li>优化字体</li><li>其他垂直领域的性能优化</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>编码优化(局部变量,对象嵌套深度，DOM操作，Map)</li><li>静态资源优化(压缩)</li><li>异步加载JS防阻塞, 懒加载</li><li>Preload(在合适的时间使用CSS资源)</li><li>使用import函数动态导入模块</li><li>使用HTTP缓存头</li><li>使用CDN</li><li>服务端渲染减少白屏时间</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python的一些技巧</title>
    <link href="/2020/07/14/notes/python/%E6%8A%80%E5%B7%A7/"/>
    <url>/2020/07/14/notes/python/%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><div class="hljs"><pre><code class="hljs py"><span class="hljs-meta">@staticmethod</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">A</span><span class="hljs-params">()</span>:</span>    <span class="hljs-keyword">pass</span><span class="hljs-comment"># 相当于</span>A=staticmethod(A)</code></pre></div><h3 id="staticmethod"><a href="#staticmethod" class="headerlink" title="@staticmethod"></a>@staticmethod</h3><p>staticmethod 一般用于类内，返回函数的静态方法。该方法不强制要求传递参数</p><div class="hljs"><pre><code class="hljs py"><span class="hljs-meta">@staticmethod</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__exec</span><span class="hljs-params">(func)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapper</span><span class="hljs-params">(self, *args, **kwargs)</span>:</span>        sql = func(*args, **kwargs)    <span class="hljs-keyword">return</span> wrapper<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">insert</span><span class="hljs-params">(self, account, passwd)</span>:</span><span class="hljs-meta">    @self.__exec    # !!!!!!</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">insert_</span><span class="hljs-params">(account, passwd)</span>:</span>        sql = <span class="hljs-string">"xxx"</span>        <span class="hljs-keyword">return</span> sql    insert_(self, account, passwd)  <span class="hljs-comment"># wrapper needs 'self'</span></code></pre></div><p>@classmethod 装饰器和 staticmethod 装饰器修饰的函数，都可以不用实例化访问，<br>成员函数只能是实例化对象可以访问，类本身是无法访问的！</p><div class="hljs"><pre><code class="hljs py"><span class="hljs-comment"># !!! 在类内只能用self.f的形式，直接调用f触发错误</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span><span class="hljs-params">(object)</span>:</span><span class="hljs-meta">    @staticmethod</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-params">()</span>:</span>        print(<span class="hljs-string">'runoob'</span>);C.f();          <span class="hljs-comment"># 静态方法无需实例化</span>cobj = C()cobj.f()        <span class="hljs-comment"># 也可以实例化后调用</span></code></pre></div><p>##</p><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><div class="hljs"><pre><code class="hljs py"><span class="hljs-meta">&gt;&gt;&gt; </span>l = [ ]<span class="hljs-meta">&gt;&gt;&gt; </span>x=<span class="hljs-number">0</span><span class="hljs-meta">&gt;&gt;&gt; </span>l.append(<span class="hljs-number">1</span> <span class="hljs-keyword">if</span> x&gt;=<span class="hljs-number">1</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>l[<span class="hljs-number">0</span>]</code></pre></div><div class="hljs"><pre><code class="hljs py"><span class="hljs-meta">&gt;&gt;&gt; </span>l = [ ]<span class="hljs-meta">&gt;&gt;&gt; </span>x=<span class="hljs-number">1</span><span class="hljs-meta">&gt;&gt;&gt; </span>l.append(<span class="hljs-number">1</span> <span class="hljs-keyword">if</span> x&gt;=<span class="hljs-number">1</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>l[<span class="hljs-number">1</span>]</code></pre></div><h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><div class="hljs"><pre><code class="hljs py">mutex=threading.Lock() <span class="hljs-comment">#创建一个锁</span><span class="hljs-keyword">with</span> mutex:   <span class="hljs-comment">#with Lock的作用相当于自动获取和释放锁(资源)</span>    <span class="hljs-keyword">pass</span></code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python2和 3兼容</title>
    <link href="/2020/07/14/notes/python/python2_3%E5%85%BC%E5%AE%B9/"/>
    <url>/2020/07/14/notes/python/python2_3%E5%85%BC%E5%AE%B9/</url>
    
    <content type="html"><![CDATA[<div class="hljs"><pre><code class="hljs py"><span class="hljs-comment"># coding=utf-8</span><span class="hljs-keyword">from</span> __future__ <span class="hljs-keyword">import</span> absolute_import<span class="hljs-keyword">from</span> __future__ <span class="hljs-keyword">import</span> division     <span class="hljs-comment"># division(精确除法)</span><span class="hljs-keyword">from</span> __future__ <span class="hljs-keyword">import</span> print_function   <span class="hljs-comment"># print()</span></code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python的pandas模块</title>
    <link href="/2020/07/14/notes/python/pandas/"/>
    <url>/2020/07/14/notes/python/pandas/</url>
    
    <content type="html"><![CDATA[<h2 id="iloc"><a href="#iloc" class="headerlink" title="iloc"></a>iloc</h2><div class="hljs"><pre><code class="hljs py">df[<span class="hljs-string">"col"</span>].iloc[<span class="hljs-number">0</span>]=<span class="hljs-number">122133</span><span class="hljs-comment"># df变化</span>df.iloc[<span class="hljs-number">0</span>,<span class="hljs-number">6</span>]=<span class="hljs-number">122133</span><span class="hljs-comment"># df变化</span>df.iloc[<span class="hljs-number">0</span>][<span class="hljs-string">"col"</span>]=<span class="hljs-number">122133</span><span class="hljs-comment"># df不变化</span></code></pre></div><h2 id="过滤not-in"><a href="#过滤not-in" class="headerlink" title="过滤not in"></a>过滤not in</h2><p><a href="https://stackoverflow.com/questions/27965295/dropping-rows-from-dataframe-based-on-a-not-in-condition" target="_blank" rel="noopener">https://stackoverflow.com/questions/27965295/dropping-rows-from-dataframe-based-on-a-not-in-condition</a></p><p>You can use pandas.Dataframe.isin.</p><p>pandas.Dateframe.isin will return boolean values depending on whether each element is inside the list a or not. You then invert this with the ~ to convert True to False and vice versa.</p><div class="hljs"><pre><code class="hljs py"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pda = [<span class="hljs-string">'2015-01-01'</span> , <span class="hljs-string">'2015-02-01'</span>]df = pd.DataFrame(data=&#123;<span class="hljs-string">'date'</span>:[<span class="hljs-string">'2015-01-01'</span> , <span class="hljs-string">'2015-02-01'</span>, <span class="hljs-string">'2015-03-01'</span> , <span class="hljs-string">'2015-04-01'</span>, <span class="hljs-string">'2015-05-01'</span> , <span class="hljs-string">'2015-06-01'</span>]&#125;)print(df)<span class="hljs-comment">#         date</span><span class="hljs-comment">#0  2015-01-01</span><span class="hljs-comment">#1  2015-02-01</span><span class="hljs-comment">#2  2015-03-01</span><span class="hljs-comment">#3  2015-04-01</span><span class="hljs-comment">#4  2015-05-01</span><span class="hljs-comment">#5  2015-06-01</span>df = df[~df[<span class="hljs-string">'date'</span>].isin(a)]print(df)<span class="hljs-comment">#         date</span><span class="hljs-comment">#2  2015-03-01</span><span class="hljs-comment">#3  2015-04-01</span><span class="hljs-comment">#4  2015-05-01</span><span class="hljs-comment">#5  2015-06-01</span></code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>模块</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python的logging模块</title>
    <link href="/2020/07/14/notes/python/logging%E6%A8%A1%E5%9D%97(%E8%AE%B0%E5%BD%95%E6%97%A5%E5%BF%97)/"/>
    <url>/2020/07/14/notes/python/logging%E6%A8%A1%E5%9D%97(%E8%AE%B0%E5%BD%95%E6%97%A5%E5%BF%97)/</url>
    
    <content type="html"><![CDATA[<p>python的logging模块提供了标准的日志接口，可以通过它存储各种格式的日志，日志级别等级:critical &gt; error &gt; warning &gt; info &gt; debug</p><p><img src="http://pic.aizf.ink/md/py/1.png" alt="avatar"></p><p>默认情况下只显示了大于等于WARNING级别的日志。</p><div class="hljs"><pre><code class="hljs py"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> logging<span class="hljs-meta">&gt;&gt;&gt; </span>logging.debug(<span class="hljs-string">'test debug'</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>logging.info(<span class="hljs-string">'test info'</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>logging.warning(<span class="hljs-string">'test warning'</span>)WARNING:root:test warning<span class="hljs-meta">&gt;&gt;&gt; </span>logging.error(<span class="hljs-string">'test error'</span>)ERROR:root:test error<span class="hljs-meta">&gt;&gt;&gt; </span>logging.critical(<span class="hljs-string">'test critical'</span>)CRITICAL:root:test critical</code></pre></div><p>logger</p><p><strong>Logger.setLevel(lel):指定最低的日志级别，低于lel的级别将被忽略。debug是最低的内置级别，critical为最高</strong></p><p>Logger.addFilter(filt)、Logger.removeFilter(filt):添加或删除指定的filter</p><p>Logger.addHandler(hdlr)、Logger.removeHandler(hdlr)：增加或删除指定的handler</p><p>Logger.debug()、Logger.info()、Logger.warning()、Logger.error()、Logger.critical()：可以设置的日志级别</p><p>在logging.basicConfig()函数中可通过具体参数来更改logging模块默认行为，可用参数有<br>filename：用指定的文件名创建FiledHandler（后边会具体讲解handler的概念），这样日志会被存储在指定的文件中。<br>filemode：文件打开方式，在指定了filename时使用这个参数，默认值为“a”还可指定为“w”。<br>format：指定handler使用的日志显示格式。<br>datefmt：指定日期时间格式。<br>level：设置rootlogger（后边会讲解具体概念）的日志级别<br>stream：用指定的stream创建StreamHandler。可以指定输出到sys.stderr,sys.stdout或者文件，默认为sys.stderr。若同时列出了filename和stream两个参数，则stream参数会被忽略。</p><p>format参数中可能用到的格式化串：<br>%(name)s Logger的名字<br>%(levelno)s 数字形式的日志级别<br>%(levelname)s 文本形式的日志级别<br>%(pathname)s 调用日志输出函数的模块的完整路径名，可能没有<br>%(filename)s 调用日志输出函数的模块的文件名<br>%(module)s 调用日志输出函数的模块名<br>%(funcName)s 调用日志输出函数的函数名<br>%(lineno)d 调用日志输出函数的语句所在的代码行<br>%(created)f 当前时间，用UNIX标准的表示时间的浮 点数表示<br>%(relativeCreated)d 输出日志信息时的，自Logger创建以 来的毫秒数<br>%(asctime)s 字符串形式的当前时间。默认格式是 “2003-07-08 16:49:45,896”。逗号后面的是毫秒<br>%(thread)d 线程ID。可能没有<br>%(threadName)s 线程名。可能没有<br>%(process)d 进程ID。可能没有<br>%(message)s用户输出的消息</p><p>若要对logging进行更多灵活的控制，必须了解Logger，Handler，Formatter，Filter的概念：<br>logger提供了应用程序可以直接使用的接口；</p><p>handler将(logger创建的)日志记录发送到合适的目的输出；</p><p>filter提供了细度设备来决定输出哪条日志记录；</p><p>formatter决定日志记录的最终输出格式。</p>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>模块</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python的Collections模块</title>
    <link href="/2020/07/14/notes/python/Collections%E6%A8%A1%E5%9D%97(%E5%90%84%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)/"/>
    <url>/2020/07/14/notes/python/Collections%E6%A8%A1%E5%9D%97(%E5%90%84%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)/</url>
    
    <content type="html"><![CDATA[<div class="hljs"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> collections</code></pre></div><ul><li>Counter 类</li><li>OrderedDict 类</li><li>defaultdict 类</li><li>namedtuple 类</li></ul><h2 id="1、计数器（counter）"><a href="#1、计数器（counter）" class="headerlink" title="1、计数器（counter）"></a>1、计数器（counter）</h2><p>counter是对字典的方法，用来追踪值的出现次数；具备字典的所有功能和自己的功能。</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>c = Counter(<span class="hljs-string">'abcdeabcdabcaba'</span>)  <span class="hljs-comment"># count elements from a string</span><span class="hljs-meta">&gt;&gt;&gt; </span>c.most_common(<span class="hljs-number">3</span>)                <span class="hljs-comment"># three most common elements</span>[(<span class="hljs-string">'a'</span>, <span class="hljs-number">5</span>), (<span class="hljs-string">'b'</span>, <span class="hljs-number">4</span>), (<span class="hljs-string">'c'</span>, <span class="hljs-number">3</span>)]<span class="hljs-meta">&gt;&gt;&gt; </span>sorted(c)                       <span class="hljs-comment"># list all unique elements</span>[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>, <span class="hljs-string">'e'</span>]<span class="hljs-meta">&gt;&gt;&gt; </span>c[<span class="hljs-string">'a'</span>]                          <span class="hljs-comment"># count of letter 'a'</span>    <span class="hljs-number">5</span><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">del</span> c[<span class="hljs-string">'b'</span>]                      <span class="hljs-comment"># remove all 'b'</span><span class="hljs-meta">&gt;&gt;&gt; </span>c[<span class="hljs-string">'b'</span>]                          <span class="hljs-comment"># now there are zero 'b'</span><span class="hljs-number">0</span>......</code></pre></div><h2 id="2、有序字典-OrderedDict"><a href="#2、有序字典-OrderedDict" class="headerlink" title="2、有序字典(OrderedDict)"></a>2、有序字典(OrderedDict)</h2><p>OrderedDict是对字典的补充，它可以记住字典元素添加的顺序。</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>dic1 = OrderedDict(&#123;<span class="hljs-string">'k1'</span>:<span class="hljs-string">'v1'</span>,<span class="hljs-string">'k2'</span>:<span class="hljs-string">'v2'</span>,<span class="hljs-string">'k4'</span>:<span class="hljs-string">'v4'</span>,<span class="hljs-string">'k3'</span>:<span class="hljs-string">'v3'</span>&#125;)<span class="hljs-meta">&gt;&gt;&gt; </span>dic1    <span class="hljs-comment">#创建有序列的字典</span>OrderedDict([(<span class="hljs-string">'k4'</span>, <span class="hljs-string">'v4'</span>), (<span class="hljs-string">'k1'</span>, <span class="hljs-string">'v1'</span>), (<span class="hljs-string">'k2'</span>, <span class="hljs-string">'v2'</span>), (<span class="hljs-string">'k3'</span>, <span class="hljs-string">'v3'</span>)])<span class="hljs-meta">&gt;&gt;&gt; </span>dic1.popitem()    <span class="hljs-comment">#默认提取最后要给key</span>(<span class="hljs-string">'k3'</span>, <span class="hljs-string">'v3'</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>dic1OrderedDict([(<span class="hljs-string">'k4'</span>, <span class="hljs-string">'v4'</span>), (<span class="hljs-string">'k1'</span>, <span class="hljs-string">'v1'</span>), (<span class="hljs-string">'k2'</span>, <span class="hljs-string">'v2'</span>)])<span class="hljs-meta">&gt;&gt;&gt; </span>dic1.move_to_end(<span class="hljs-string">'k4'</span>)   <span class="hljs-comment">#将指定key移到最后</span><span class="hljs-meta">&gt;&gt;&gt; </span>dic1OrderedDict([(<span class="hljs-string">'k1'</span>, <span class="hljs-string">'v1'</span>), (<span class="hljs-string">'k2'</span>, <span class="hljs-string">'v2'</span>), (<span class="hljs-string">'k4'</span>, <span class="hljs-string">'v4'</span>)])</code></pre></div><h2 id="3、默认字典-defaultdict"><a href="#3、默认字典-defaultdict" class="headerlink" title="3、默认字典(defaultdict)"></a>3、默认字典(defaultdict)</h2><p>defaultdict是对字典的类型补充，它默认给字典的值设置了一个类型</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>dict1 = defaultdict(list)   <span class="hljs-comment">#创建默认字典</span><span class="hljs-meta">&gt;&gt;&gt; </span>dict1defaultdict(&lt;class 'list'&gt;, &#123;&#125;)<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">20</span>):  <span class="hljs-comment">#实例</span><span class="hljs-meta">... </span>  <span class="hljs-keyword">if</span> i%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>:<span class="hljs-meta">... </span>    dict1[<span class="hljs-string">'k1'</span>].append(i)<span class="hljs-meta">... </span>  <span class="hljs-keyword">else</span>:<span class="hljs-meta">... </span>    dict1[<span class="hljs-string">'k2'</span>].append(i)<span class="hljs-meta">... </span><span class="hljs-meta">&gt;&gt;&gt; </span>dict1defaultdict(&lt;class 'list'&gt;, &#123;<span class="hljs-string">'k1'</span>: [<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>, <span class="hljs-number">12</span>, <span class="hljs-number">14</span>, <span class="hljs-number">16</span>, <span class="hljs-number">18</span>],  <span class="hljs-string">'k2'</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>, <span class="hljs-number">15</span>, <span class="hljs-number">17</span>, <span class="hljs-number">19</span>]&#125;)</code></pre></div><h2 id="4、可命名元组-namedtuple"><a href="#4、可命名元组-namedtuple" class="headerlink" title="4、可命名元组(namedtuple)"></a>4、可命名元组(namedtuple)</h2><p>根据namedtuple可以创建一个包含tuple所有功能以及其他功能的类型</p><div class="hljs"><pre><code class="hljs py"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> namedtuple<span class="hljs-meta">&gt;&gt;&gt; </span>tup1 = namedtuple(<span class="hljs-string">'tup1'</span>,[<span class="hljs-string">'x'</span>,<span class="hljs-string">'y'</span>,<span class="hljs-string">'z'</span>,<span class="hljs-string">'u'</span>])  <span class="hljs-comment">#创建可命名元组</span><span class="hljs-meta">&gt;&gt;&gt; </span>obj = tup1(<span class="hljs-number">111</span>,<span class="hljs-number">22</span>,<span class="hljs-number">333</span>,<span class="hljs-number">4444</span>)  <span class="hljs-comment">#创建对象</span><span class="hljs-meta">&gt;&gt;&gt; </span>print(obj.x)   <span class="hljs-comment">#输出对象序列的值</span><span class="hljs-number">111</span><span class="hljs-meta">&gt;&gt;&gt; </span>print(obj.y)<span class="hljs-number">22</span><span class="hljs-meta">&gt;&gt;&gt; </span>print(obj.z)<span class="hljs-number">333</span><span class="hljs-meta">&gt;&gt;&gt; </span>print(obj.u)<span class="hljs-number">4444</span></code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>模块</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>argparse模块(命令行工具)</title>
    <link href="/2020/07/14/notes/python/argparse%E6%A8%A1%E5%9D%97(%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7)/"/>
    <url>/2020/07/14/notes/python/argparse%E6%A8%A1%E5%9D%97(%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7)/</url>
    
    <content type="html"><![CDATA[<h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1 定义"></a>1 定义</h2><p>argparse是python<strong>标准库</strong>里面用来<strong>处理命令行参数</strong>的库</p><h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><p>命令行参数分为位置参数和选项参数：</p><ul><li><strong>位置参数</strong>就是程序根据该参数出现的位置来确定的,如：ls root/    ,其中root/是位置参数</li><li><strong>选项参数</strong>是应用程序已经提前定义好的参数，不是随意指定的,如：ls -l , -l 就是ls命令里的一个选项参数</li></ul><h2 id="3-使用步骤"><a href="#3-使用步骤" class="headerlink" title="3 使用步骤"></a>3 使用步骤</h2><div class="hljs"><pre><code class="hljs py">(<span class="hljs-number">1</span>)<span class="hljs-keyword">import</span> argparse    首先导入模块(<span class="hljs-number">2</span>)parser = argparse.ArgumentParser()    创建一个解析对象(<span class="hljs-number">3</span>)parser.add_argument()    向该对象中添加你要关注的命令行参数和选项(<span class="hljs-number">4</span>)parser.parse_args()    进行解析</code></pre></div><h2 id="4-ArgumentParser"><a href="#4-ArgumentParser" class="headerlink" title="4 ArgumentParser"></a>4 ArgumentParser</h2><p>argparse.ArgumentParser()方法参数须知：一般我们只选择用description</p><div class="hljs"><pre><code class="hljs py">prog=<span class="hljs-literal">None</span>     - 程序名description=<span class="hljs-literal">None</span>,    - help时显示的开始文字epilog=<span class="hljs-literal">None</span>,     - help时显示的结尾文字parents=[],        -若与其他参数的一些内容一样，可以继承formatter_class=argparse.HelpFormatter,     - 自定义帮助信息的格式prefix_chars=<span class="hljs-string">'-'</span>,    - 命令的前缀，默认是‘-’fromfile_prefix_chars=<span class="hljs-literal">None</span>,     - 命令行参数从文件中读取argument_default=<span class="hljs-literal">None</span>,    - 设置一个全局的选项缺省值，一般每个选项单独设置conflict_handler=<span class="hljs-string">'error'</span>,     - 定义两个add_argument中添加的选项名字发生冲突时怎么处理，默认处理是抛出异常add_help=<span class="hljs-literal">True</span>    - 是否增加-h/--help选项，默认是<span class="hljs-literal">True</span>)</code></pre></div><h2 id="5-add-argument-方法参数须知"><a href="#5-add-argument-方法参数须知" class="headerlink" title="5 add_argument()方法参数须知"></a>5 add_argument()方法参数须知</h2><div class="hljs"><pre><code class="hljs py">name <span class="hljs-keyword">or</span> flags...    - 必选，指定参数的形式，一般写两个，一个短参数，一个长参数</code></pre></div><div class="hljs"><pre><code class="hljs py"><span class="hljs-keyword">import</span> argparseparser = argparse.ArgumentParser()parser.add_argument(<span class="hljs-string">'echo'</span>) <span class="hljs-comment"># add_argument()指定程序可以接受的命令行选项</span>args = parser.parse_args() <span class="hljs-comment"># parse_args()从指定的选项中返回一些数据</span>print(args)print(args.echo)</code></pre></div><hr><p>action 表示值赋予键的方式，这里用到的是bool类型，action意思是当读取的参数中出现指定参数的时候的行为</p><p>help 可以写帮助信息</p><p>required    - 必需参数，通常-f这样的选项是可选的，但是如果required=True那么就是必须的了</p><p>type   - 指定参数类型</p><p>choices    - 设置参数的范围，如果choice中的类型不是字符串，要指定type,<br>表示该参数能接受的值只能来自某几个值候选值中，除此之外会报错，用choice参数即可</p><p>nargs    - 指定这个参数后面的value有多少个，默认为1</p><p>args还可以’*’用来表示如果有该位置参数输入的话，之后所有的输入都将作为该位置参数的值；‘+’表示读取至少1个该位置参数。’?’表示该位置参数要么没有，要么就只要一个。(PS：跟正则表达式的符号用途一致。)</p><div class="hljs"><pre><code class="hljs py">parser = argparse.ArgumentParser(description = <span class="hljs-string">'this is a description'</span>)parser.add_argument(<span class="hljs-string">'--ver'</span>, <span class="hljs-string">'-v'</span>, action = <span class="hljs-string">'store_true'</span>, help = <span class="hljs-string">'hahaha'</span>)<span class="hljs-comment"># 将变量以标签-值的字典形式存入args字典</span>args = parser.parse_args()<span class="hljs-keyword">if</span> args.ver:    print(<span class="hljs-string">"Ture"</span>)<span class="hljs-keyword">else</span>:    print(<span class="hljs-string">"False"</span>)</code></pre></div><div class="hljs"><pre><code class="hljs py"><span class="hljs-comment"># required标签就是说--ver参数是必需的，并且类型为int，输入其它类型会报错</span>parser.add_argument(<span class="hljs-string">'--ver'</span>, <span class="hljs-string">'-v'</span>, required = <span class="hljs-literal">True</span>, type = int)</code></pre></div><div class="hljs"><pre><code class="hljs py"><span class="hljs-comment"># choices</span>parser.add_argument(<span class="hljs-string">'file'</span>, choices = [<span class="hljs-string">'test1'</span>, <span class="hljs-string">'test2'</span>])args = parser.parse_args()print(<span class="hljs-string">'read in %s'</span>%(args.file))</code></pre></div><div class="hljs"><pre><code class="hljs py"><span class="hljs-comment"># nargs</span><span class="hljs-comment"># 表示脚本可以读入两个整数赋予num键(此时的值为2个整数的数组)</span>parser.add_argument(<span class="hljs-string">'filename'</span>, nargs = <span class="hljs-number">2</span>, type = int)args = parser.parse_args()print(<span class="hljs-string">'read in %s'</span>%(args.filename))</code></pre></div><div class="hljs"><pre><code class="hljs py">parser.add_argument(<span class="hljs-string">'filename'</span>, nargs = <span class="hljs-string">'+'</span>, type = int)args = parser.parse_args()print(<span class="hljs-string">'read in %s'</span>%(args.filename))parser.add_argument(<span class="hljs-string">'-file'</span>, choices = [<span class="hljs-string">'test1'</span>, <span class="hljs-string">'test2'</span>], dest = <span class="hljs-string">'world'</span>)args = parser.parse_args()print(<span class="hljs-string">'read in %s'</span>%(args.world))</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>模块</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nginx基本指令</title>
    <link href="/2020/07/14/notes/nginx/%E5%91%BD%E4%BB%A4/"/>
    <url>/2020/07/14/notes/nginx/%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<ul><li>验证配置是否正确: <code>nginx -t *.conf</code></li><li>查看Nginx的版本号：<code>nginx -V</code></li><li>启动Nginx：<code>nginx</code></li><li>快速停止或关闭Nginx：<code>nginx -s stop</code></li><li>正常停止或关闭Nginx：<code>nginx -s quit</code></li><li>配置文件修改重装载命令：<code>nginx -s reload</code></li><li>指定配置文件：<code>nginx -c *.conf</code></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>nginx</tag>
      
      <tag>命令行</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux各种解压缩</title>
    <link href="/2020/07/14/notes/linux/%E8%A7%A3%E5%8E%8B%E7%BC%A9/"/>
    <url>/2020/07/14/notes/linux/%E8%A7%A3%E5%8E%8B%E7%BC%A9/</url>
    
    <content type="html"><![CDATA[<h2 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h2><p>压缩一个目录：</p><p><code>zip -r aaa.zip bbb</code></p><p>解压一个zip文档：</p><p><code>unzip aaa.zip</code></p><p>zip分卷</p><div class="hljs"><pre><code class="hljs sh">cat linux.zip* &gt; linux.zip <span class="hljs-comment">#合并为一个zip包</span>unzip linux.zip <span class="hljs-comment">#解压zip包</span></code></pre></div><h2 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h2><p>好处是它只消耗非常少的CPU以及时间去打包文件，仅仅只是一个打包工具，并不负责压缩。</p><p>打包一个目录：</p><p><code>tar -cvf aaa.tar bbb</code></p><p>如何解包：</p><p><code>tar -xvf aaa.tar -C bbb</code></p><h2 id="tar-gz"><a href="#tar-gz" class="headerlink" title="tar.gz"></a>tar.gz</h2><p>压缩:</p><p><code>tar -zcvf aaa.tar.gz bbb</code></p><p>解压缩：</p><p><code>tar -zxvf aaa.tar.gz -C bbb</code></p><h2 id="tar-bz2"><a href="#tar-bz2" class="headerlink" title="tar.bz2"></a>tar.bz2</h2><p>这种压缩格式是以上提到的所有方式中压缩率最好的</p><p>压缩：</p><p><code>tar -jcvf aaa.tar.bz2 bbb</code></p><p>解压缩：</p><p><code>tar -jxvf aaa.tar.bz2 -C bbb</code></p>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>命令行</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux一些指令</title>
    <link href="/2020/07/14/notes/linux/%E4%B8%80%E8%88%AC%E6%8C%87%E4%BB%A4/"/>
    <url>/2020/07/14/notes/linux/%E4%B8%80%E8%88%AC%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="一些变量"><a href="#一些变量" class="headerlink" title="一些变量"></a>一些变量</h2><p>$(realpath bert)</p><p>返回当前bert的绝对路经</p><hr><p>$USER</p><p>返回当前用户名</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><h3 id="软连接ln"><a href="#软连接ln" class="headerlink" title="软连接ln"></a>软连接<code>ln</code></h3><p>创建软链接</p><div class="hljs"><pre><code class="hljs bash">ln –s  /var/www/<span class="hljs-built_in">test</span>  <span class="hljs-built_in">test</span><span class="hljs-comment"># 当前路径创建test 引向/var/www/test 文件夹</span></code></pre></div><p>删除软链接</p><p><code>rm –rf 软链接名称(请注意不要在后面加”/”!!!)</code></p><p>修改软链接</p><p><code>ln –snf  [新的源文件或目录]  [目标文件或目录]</code></p><p>常用的参数：</p><p><code>-b</code> 删除，覆盖以前建立的链接</p><p><code>-d</code> 允许超级用户制作目录的硬链接</p><p><code>-f</code> 强制执行</p><p><code>-i</code> 交互模式，文件存在则提示用户是否覆盖</p><p><code>-n</code> 把符号链接视为一般目录</p><p><code>-s</code> 软链接(符号链接)</p><p><code>-v</code> 显示详细的处理过程</p><p>(当前路径创建test 引向/var/www/test 文件夹 )</p><h2 id="前后台切换"><a href="#前后台切换" class="headerlink" title="前后台切换"></a>前后台切换</h2><h3 id="1-amp"><a href="#1-amp" class="headerlink" title="1 &amp;"></a>1 &amp;</h3><p>加在一个命令的最后，可以把这个命令放到后台执行</p><h3 id="2-ctrl-z"><a href="#2-ctrl-z" class="headerlink" title="2 ctrl + z"></a>2 ctrl + z</h3><p>可以将一个正在前台执行的命令放到后台，并且处于暂停状态。</p><h3 id="3-jobs-l"><a href="#3-jobs-l" class="headerlink" title="3 jobs -l"></a>3 jobs -l</h3><p>查看当前有多少在后台运行的命令</p><h3 id="4-fg-bg"><a href="#4-fg-bg" class="headerlink" title="4 fg bg"></a>4 fg bg</h3><p><code>fg</code></p><p>将后台中的命令调至前台继续运行。可以用fg %jobnumber（是命令编号，不是进程号）将选中的命令调出。</p><p><code>bg</code></p><p>将一个在后台暂停的命令，变成在后台继续执行。可以用bg %jobnumber将选中的命令调出。</p><h3 id="5-kill"><a href="#5-kill" class="headerlink" title="5 kill"></a>5 kill</h3><p><code>kill %num</code></p><p><code>kill pid</code></p><h3 id="6-nohup"><a href="#6-nohup" class="headerlink" title="6 nohup"></a>6 nohup</h3><p>该命令可以在你退出帐户/关闭终端之后继续运行相应的进程。</p>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>命令行</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git工作区，暂存区和版本库</title>
    <link href="/2020/07/14/notes/git/%E5%B7%A5%E4%BD%9C%E5%8C%BA%E5%92%8C%E6%9A%82%E5%AD%98%E5%8C%BA/"/>
    <url>/2020/07/14/notes/git/%E5%B7%A5%E4%BD%9C%E5%8C%BA%E5%92%8C%E6%9A%82%E5%AD%98%E5%8C%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="工作区（Working-Directory）"><a href="#工作区（Working-Directory）" class="headerlink" title="工作区（Working Directory）"></a>工作区（Working Directory）</h2><p>看到的目录</p><h2 id="版本库（Repository）"><a href="#版本库（Repository）" class="headerlink" title="版本库（Repository）"></a>版本库（Repository）</h2><p>隐藏目录.git，这个不算工作区，而是Git的版本库。</p><p>版本库包括<strong>暂存区</strong>（stage或者index），分支，指针<code>HEAD</code></p><p>文件往Git版本库里添加,分两步:</p><ol><li><code>git add</code>把文件添加进去，实际上就是把文件修改添加到暂存区</li><li><code>git commit</code>提交更改，实际上就是把暂存区的所有内容提交到当前分支</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git分支管理</title>
    <link href="/2020/07/14/notes/git/%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/"/>
    <url>/2020/07/14/notes/git/%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="1-创建合并分支"><a href="#1-创建合并分支" class="headerlink" title="1 创建合并分支"></a>1 创建合并分支</h2><p><code>HEAD</code>指向的就是当前分支</p><p><code>git branch dev</code></p><blockquote><p>创建</p></blockquote><p><code>git checkout dev</code></p><blockquote><p>切换</p></blockquote><p><code>git checkout -b dev</code></p><blockquote><p>加上<code>-b</code>参数表示创建并切换</p></blockquote><p><code>git branch</code></p><blockquote><p>查看所有分支</p></blockquote><p><code>git merge dev</code></p><blockquote><p>把dev分支的工作成果合并到master分支上</p></blockquote><p><code>git branch -d dev</code></p><blockquote><p>删除dev分支</p></blockquote><p><code>git checkout</code>同一个命令，有两种作用，确实令人迷惑</p><p>最新版本的Git提供了新的<code>git switch</code>命令来切换分支：</p><p><code>git switch -c dev</code></p><blockquote><p>创建并切换到新的dev分支</p></blockquote><p><code>git switch master</code></p><blockquote><p>直接切换到已有的master分支</p></blockquote><h2 id="2-解决冲突"><a href="#2-解决冲突" class="headerlink" title="2 解决冲突"></a>2 解决冲突</h2><p>当Git无法自动合并分支(merge)时，就必须首先解决冲突。解决冲突后，再提交，合并完成。</p><p>Git用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容</p><div class="hljs"><pre><code class="hljs txt">Git is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADCreating a new branch is quick &amp; simple.&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Creating a new branch is quick AND simple.&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1</code></pre></div><p>用带参数的git log也可以看到分支的合并情况：</p><p><code>git log --graph --pretty=oneline --abbrev-commit</code></p><p>最后，删除feature1分支</p><h2 id="3-分支管理策略"><a href="#3-分支管理策略" class="headerlink" title="3 分支管理策略"></a>3 分支管理策略</h2><p><code>git merge --no-ff -m &quot;merge with no-ff&quot; dev</code></p><p><code>--no-ff</code>参数，表示禁用Fast forward</p><p>合并分支时，如果可能，Git会用Fast forward模式</p><p>如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit</p><h3 id="3-1-分支策略"><a href="#3-1-分支策略" class="headerlink" title="3.1 分支策略"></a>3.1 分支策略</h3><p>在实际开发中，我们应该按照几个基本原则进行分支管理：</p><p><code>master</code>分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</p><p>干活都在<code>dev</code>分支上，到某个时候，比如1.0版本发布时，再把<code>dev</code>分支合并到<code>master</code>上，在<code>master</code>分支发布1.0版本；</p><p>每个人都有自己的分支，时不时地往dev分支上合并就可以了。</p><h3 id="4-Bug分支"><a href="#4-Bug分支" class="headerlink" title="4 Bug分支"></a>4 Bug分支</h3><p>当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支<code>issue-101</code>来修复它，但是，等等，当前正在<code>dev</code>上进行的工作还没有提交</p><p>工作只进行到一半，还没法提交，怎么办？</p><p><code>stash</code>功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作</p><p>修复bug:</p><ol><li>首先确定要在哪个分支上修复bug，假定需要在<code>master</code>分支上修复，就从<code>master</code>创建临时分支</li><li>修复bug，然后提交</li><li>完成后，切换到<code>master</code>分支，并完成合并，最后删除<code>issue-101</code>分支</li><li>回到<code>dev</code>分支</li><li>用<code>git stash list</code>命令查看stash状态</li><li>恢复stash</li></ol><p>恢复stash有两种：</p><ol><li>用<code>git stash apply</code>恢复，但是恢复后，stash内容并不删除，你需要用<code>git stash drop</code>来删除；</li><li>用<code>git stash pop</code>，恢复的同时把stash内容也删了</li></ol><p><code>git stash apply stash@{0}</code></p><blockquote><p>指定stash</p></blockquote><p>继续在<code>dev</code>上修复bug:</p><p>只复制<code>4c805e2 fix bug 101</code>这个提交所做的修改，并不是把整个<code>master</code>分支<code>merge</code>过来。</p><div class="hljs"><pre><code class="hljs bash">$ git branch* dev  master$ git cherry-pick 4c805e2[master 1d4b803] fix bug 101 1 file changed, 1 insertion(+), 1 deletion(-)</code></pre></div><p><strong>注意:</strong>Git自动给<code>dev</code>分支做了一次提交，提交的<code>commit</code><strong>不同于</strong><code>master</code></p><p>也可以直接在<code>dev</code>分支上修复bug，然后在<code>master</code>分支上“重放”，仍然需要<code>git stash</code></p><h2 id="5-Feature分支"><a href="#5-Feature分支" class="headerlink" title="5 Feature分支"></a>5 Feature分支</h2><p>每添加一个新功能，最好新建一个<code>feature</code>分支，在上面开发，完成后，合并，最后，删除该<code>feature</code>分支。</p><p>当丢弃一个没有被合并过的分支，<code>git branch -d feature-x</code>会<strong>失败</strong>，因为还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用大写的<code>-D</code>参数。</p><h2 id="5-多人协作"><a href="#5-多人协作" class="headerlink" title="5 多人协作"></a>5 多人协作</h2><p>远程仓库的默认名称是<code>origin</code></p><p><code>git remote</code></p><blockquote><p>查看远程库的信息</p></blockquote><p><code>git remote -v</code></p><blockquote><p>显示更详细的信息</p></blockquote><h3 id="5-1-推送"><a href="#5-1-推送" class="headerlink" title="5.1 推送"></a>5.1 推送</h3><p>推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：</p><p><code>git push origin master|dev</code></p><p>并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？</p><ul><li><code>master</code>分支是主分支，因此要时刻与远程同步；</li><li><code>dev</code>分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</li><li><code>bug</code>分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</li><li><code>feature</code>分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</li></ul><h3 id="5-2-抓取分支"><a href="#5-2-抓取分支" class="headerlink" title="5.2 抓取分支"></a>5.2 抓取分支</h3><p>默认情况下，<code>git clone</code>只有<code>master</code>分支</p><p>要在<code>dev</code>分支上开发，就必须创建远程<code>origin</code>的<code>dev</code>分支到本地：</p><p><code>git checkout -b dev origin/dev</code></p><p><code>push</code>到<code>origin</code>：</p><p><code>git push origin dev</code></p><p>推送冲突时，先用<code>git pull</code>把最新的提交从<code>origin/dev</code>抓下来，然后，在本地合并，解决冲突，再推送.</p><p><strong>直接</strong><code>git pull</code>会<strong>失败</strong>，原因是没有指定本地<code>dev</code>分支与远程<code>origin/dev</code>分支的链接，根据提示，设置<code>dev</code>和<code>origin/dev</code>的链接：</p><div class="hljs"><pre><code class="hljs bash">$ git branch --<span class="hljs-built_in">set</span>-upstream-to=origin/dev devBranch <span class="hljs-string">'dev'</span> <span class="hljs-built_in">set</span> up to track remote branch <span class="hljs-string">'dev'</span> from <span class="hljs-string">'origin'</span>.</code></pre></div><p>再<code>pull</code>：</p><p><code>git pull</code></p><h3 id="5-3-多人协作的工作模式"><a href="#5-3-多人协作的工作模式" class="headerlink" title="5.3 多人协作的工作模式"></a>5.3 多人协作的工作模式</h3><p>因此，多人协作的工作模式通常是这样：</p><p>首先，可以试图用<code>git push origin &lt;branch-name&gt;</code>推送自己的修改；</p><p>如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；</p><p>如果合并有冲突，则解决冲突，并在本地提交；</p><p>没有冲突或者解决掉冲突后，再用<code>git push origin &lt;branch-name&gt;</code>推送就能成功！</p><p>如果<code>git pull</code>提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;</code>。</p><h2 id="6-Rebase-变基-误"><a href="#6-Rebase-变基-误" class="headerlink" title="6 Rebase 变基(误)"></a>6 Rebase 变基(误)</h2><p>多人在同一个分支上协作时，很容易出现冲突。</p><p>每次合并再push后，分支变成了这样：</p><div class="hljs"><pre><code class="hljs bash">$ git <span class="hljs-built_in">log</span> --graph --pretty=oneline --abbrev-commit* d1be385 (HEAD -&gt; master, origin/master) init hello*   e5e69f1 Merge branch <span class="hljs-string">'dev'</span>|\  | *   57c53ab (origin/dev, dev) fix env conflict| |\  | | * 7a5e5dd add env| * | 7bd91f1 add new env| |/  * |   12a631b merged bug fix 101|\ \  | * | 4c805e2 fix bug 101|/ /  * |   e1e9c68 merge with no-ff|\ \  | |/  | * f52c633 add merge|/  *   cf810e4 conflict fixed</code></pre></div><p>commit后，push失败，pull，合并冲突，此时<strong>提交历史分叉</strong>， <code>git rebase</code>，变成直线</p><p><code>git rebase</code>原理实现：</p><p>修改不再基于本地<code>commit</code>，而是基于<code>origin</code>的<code>commit</code>(<code>pull</code>下来的<code>commit</code>)</p><p>缺点是本地的分叉提交已经被修改过了</p>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git基本使用</title>
    <link href="/2020/07/14/notes/git/usage/"/>
    <url>/2020/07/14/notes/git/usage/</url>
    
    <content type="html"><![CDATA[<h2 id="1-name-email"><a href="#1-name-email" class="headerlink" title="1 name email"></a>1 name email</h2><div class="hljs"><pre><code class="hljs bash">git config --global user.name <span class="hljs-string">"Your Name"</span>git config --global user.email <span class="hljs-string">"email@example.com"</span></code></pre></div><h2 id="2-general"><a href="#2-general" class="headerlink" title="2 general"></a>2 general</h2><p><code>git init [dir]</code></p><p><code>git add &lt;. | file | dir&gt;</code></p><p><code>git commit -m xxx</code></p><p><code>git rebase -i HEAD~[number_of_commits]</code></p><blockquote><p>之后将<code>pick</code>改为<code>s, squash</code>可将此<code>commit</code>合并</p></blockquote><p>需要找出来到底哪个规则写错了，可以用<code>git check-ignore</code>命令检查：</p><div class="hljs"><pre><code class="hljs bash">$ git check-ignore -v App.class.gitignore:3:*.class App.class</code></pre></div><p>Git会告诉我们，.gitignore的第3行规则忽略了该文件，于是我们就可以知道应该修订哪个规则。</p><h2 id="3-version-control"><a href="#3-version-control" class="headerlink" title="3 version control"></a>3 version control</h2><h3 id="3-1-修改"><a href="#3-1-修改" class="headerlink" title="3.1 修改"></a>3.1 修改</h3><p><code>git status</code></p><blockquote><p><strong>工作区</strong>的状态</p></blockquote><p><code>git diff &lt;commit&gt; -- &lt;file&gt;</code></p><blockquote><p>显示的格式正是Unix通用的diff格式,能看看具体修改了什么内容</p></blockquote><p><code>git log --[graph | pretty=oneline]</code></p><blockquote><p>历史记录</p></blockquote><p><code>git reset</code></p><blockquote><p>变更版本</p></blockquote><p>例如：回退到上一个版本</p><p><code>git reset --hard HEAD^</code></p><p>回到指定版本</p><div class="hljs"><pre><code class="hljs bash">$ git reset --hard &lt;commit&gt;HEAD is now at 83b0afe append GPL<span class="hljs-comment"># 版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。</span></code></pre></div><p>在Git中，用HEAD表示当前版本，上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个^比较容易数不过来，所以写成<code>HEAD~100</code>。</p><p><code>git reflog</code></p><blockquote><p>记录历史命令</p></blockquote><p><code>git checkout -- &lt;file&gt;</code></p><blockquote><p>discard changes in working directory,回到最近一次<code>git commit</code>或<code>git add</code>时的状态</p></blockquote><p><code>git reset HEAD &lt;file&gt;</code></p><blockquote><p>可以把暂存区的修改撤销掉（unstage），重新放回工作区</p></blockquote><p>最新版本的git已经使用<code>git restore</code> 代替了原来的<code>reset</code>和<code>checkout</code>命令了</p><p><code>git restore &lt;file&gt;</code></p><blockquote><p>to discard changes in working directory</p></blockquote><p><code>git restore --staged readme</code></p><blockquote><p>to unstage</p></blockquote><h3 id="3-2-删除"><a href="#3-2-删除" class="headerlink" title="3.2 删除"></a>3.2 删除</h3><p>删除文件，工作区和版本库就不一致了，<code>git status</code>命令会立刻告诉你哪些文件被删除了：</p><div class="hljs"><pre><code class="hljs bash">$ git statusOn branch masterChanges not staged <span class="hljs-keyword">for</span> commit:  (use <span class="hljs-string">"git add/rm &lt;file&gt;..."</span> to update what will be committed)  (use <span class="hljs-string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="hljs-keyword">in</span> working directory)    deleted:    test.txtno changes added to commit (use <span class="hljs-string">"git add"</span> and/or <span class="hljs-string">"git commit -a"</span>)</code></pre></div><h4 id="确定删除"><a href="#确定删除" class="headerlink" title="确定删除"></a>确定删除</h4><p><code>git rm &lt;file&gt;</code></p><p><code>git commit -m xxx</code></p><h4 id="恢复删除"><a href="#恢复删除" class="headerlink" title="恢复删除"></a>恢复删除</h4><p><code>git checkout -- &lt;file&gt;</code></p>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git tag</title>
    <link href="/2020/07/14/notes/git/tag/"/>
    <url>/2020/07/14/notes/git/tag/</url>
    
    <content type="html"><![CDATA[<p><code>git tag &lt;name&gt;</code></p><blockquote><p>打标签</p></blockquote><blockquote><p>例如： <code>git tag v1.0</code></p></blockquote><p><code>git tag</code></p><blockquote><p>查看所有标签，注意，标签不是按时间顺序列出，而是<strong>按字母排序</strong>的。</p></blockquote><p><code>git show &lt;tagname&gt;</code></p><blockquote><p>查看标签信息</p></blockquote><blockquote><p>如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上<strong>都可以</strong>看到这个标签。</p></blockquote><p><code>git tag &lt;name&gt; &lt;commit&gt;</code></p><blockquote><p>指定<code>commit</code>打标签</p></blockquote><p><code>git tag -a v0.1 -m &quot;version 0.1 released&quot; 1094adb</code></p><blockquote><p>创建带有说明的标签，用<code>-a</code>指定标签名，<code>-m</code>指定说明文字</p></blockquote><p><code>git tag -d &lt;name&gt;</code></p><blockquote><p>删除tag</p></blockquote><p><code>git push origin &lt;tagname&gt;</code></p><blockquote><p>推送某个标签到远程,因为创建的标签都只存储在本地，不会自动推送到远程</p></blockquote><p><code>git push origin --tags</code></p><blockquote><p>一次性推送全部</p></blockquote><p><code>git push origin :refs/tags/&lt;tagname&gt;</code></p><blockquote><p>可以删除一个远程标签</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>notes/python/flask/简明</title>
    <link href="/2020/07/14/notes/python/flask/%E7%AE%80%E6%98%8E/"/>
    <url>/2020/07/14/notes/python/flask/%E7%AE%80%E6%98%8E/</url>
    
    <content type="html"><![CDATA[<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><div class="hljs"><pre><code class="hljs ini"><span class="hljs-attr">app</span> = Flask(__name__)</code></pre></div><h2 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h2><p>app.run(‘127.0.0.1’, 5001)</p><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p><a href="http://127.0.0.1:5000/pi" target="_blank" rel="noopener">http://127.0.0.1:5000/pi</a></p><div class="hljs"><pre><code class="hljs aspectj"><span class="hljs-meta">@app</span>.route(<span class="hljs-string">"/pi"</span>)</code></pre></div><p><a href="http://localhost:5000/pi/10000000" target="_blank" rel="noopener">http://localhost:5000/pi/10000000</a></p><div class="hljs"><pre><code class="hljs ruby">@route(<span class="hljs-string">"/pi/&lt;int:n&gt;"</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pi</span><span class="hljs-params">(n)</span></span><span class="hljs-symbol">:</span>    pass</code></pre></div><h2 id="接受参数"><a href="#接受参数" class="headerlink" title="接受参数"></a>接受参数</h2><p><a href="http://127.0.0.1:5000/pi?nn=111" target="_blank" rel="noopener">http://127.0.0.1:5000/pi?nn=111</a></p><div class="hljs"><pre><code class="hljs pgsql"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask, requestn = <span class="hljs-type">int</span>(request.args.<span class="hljs-keyword">get</span>(<span class="hljs-string">'nn'</span>, <span class="hljs-string">'100'</span>))</code></pre></div><h2 id="缓存计算结果"><a href="#缓存计算结果" class="headerlink" title="缓存计算结果"></a>缓存计算结果</h2><p>再次刷新页面，我们可以观察到cached字段变成了true，说明结果确实已经缓存了</p><p>为什么缓存类PiCache<strong>需要使用RLock</strong>呢？这是因为考虑到多线程环境下Python的字典读写不是完全线程安全的，需要使用锁来保护一下数据结构。</p><h2 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h2><p>上面的缓存仅仅是内存缓存，进程重启后，缓存结果消失</p><p>所以这里要引入分布式缓存<strong>Redis</strong>来共享计算缓存，避免跨进程重复计算，避免重启重新计算。</p><div class="hljs"><pre><code class="hljs sql">import mathimport redisfrom flask import Flask, requestfrom flask.json import jsonifyapp = Flask(__name__)class PiCache(object):    def __init__(self, client):        self.client = client    def <span class="hljs-keyword">set</span>(<span class="hljs-keyword">self</span>, n, <span class="hljs-keyword">result</span>):        self.client.hset(<span class="hljs-string">"pis"</span>, <span class="hljs-keyword">str</span>(n), <span class="hljs-keyword">str</span>(<span class="hljs-keyword">result</span>))    <span class="hljs-keyword">def</span> <span class="hljs-keyword">get</span>(<span class="hljs-keyword">self</span>, n):        <span class="hljs-keyword">result</span> = self.client.hget(<span class="hljs-string">"pis"</span>, <span class="hljs-keyword">str</span>(n))        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">result</span>:            <span class="hljs-keyword">return</span>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">float</span>(<span class="hljs-keyword">result</span>)<span class="hljs-keyword">client</span> = redis.StrictRedis()<span class="hljs-keyword">cache</span> = PiCache(<span class="hljs-keyword">client</span>)@app.route(<span class="hljs-string">"/pi"</span>)<span class="hljs-keyword">def</span> <span class="hljs-keyword">pi</span>():    n = <span class="hljs-built_in">int</span>(request.args.get(<span class="hljs-string">'n'</span>, <span class="hljs-string">'100'</span>))    <span class="hljs-keyword">result</span> = cache.get(n)    <span class="hljs-keyword">if</span> <span class="hljs-keyword">result</span>:        <span class="hljs-keyword">return</span> jsonify(&#123;<span class="hljs-string">"cached"</span>: <span class="hljs-literal">True</span>, <span class="hljs-string">"result"</span>: <span class="hljs-keyword">result</span>&#125;)    s = <span class="hljs-number">0.0</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-keyword">range</span>(<span class="hljs-number">1</span>, n):        s += <span class="hljs-number">1.0</span>/i/i    <span class="hljs-keyword">result</span> = math.sqrt(<span class="hljs-number">6</span>*s)    cache.set(n, <span class="hljs-keyword">result</span>)    <span class="hljs-keyword">return</span> jsonify(&#123;<span class="hljs-string">"cached"</span>: <span class="hljs-literal">False</span>, <span class="hljs-string">"result"</span>: <span class="hljs-keyword">result</span>&#125;)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:    app.run(<span class="hljs-string">'127.0.0.1'</span>, <span class="hljs-number">5000</span>)</code></pre></div><h2 id="MethodView"><a href="#MethodView" class="headerlink" title="MethodView"></a>MethodView</h2><p>flask默认的MethodView挺好用，但是也<strong>不够好用</strong>，它无法在一个类里提供多个不同URL名称的API服务。所以接下来我们引入flask的扩展flask-classy来解决这个问题。</p><h2 id="flask-classy"><a href="#flask-classy" class="headerlink" title="flask-classy"></a>flask-classy</h2><div class="hljs"><pre><code class="hljs ruby">import mathimport redisfrom flask import Flaskfrom flask.json import jsonifyfrom flask_classy import FlaskView, route  <span class="hljs-comment"># 扩展</span>app = Flask(__name_<span class="hljs-number">_</span>)<span class="hljs-comment"># pi的cache和fib的cache要分开</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PiCache</span>(<span class="hljs-title">object</span>):</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, client)</span></span><span class="hljs-symbol">:</span>        <span class="hljs-keyword">self</span>.client = client    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set_fib</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, n, result)</span></span><span class="hljs-symbol">:</span>        <span class="hljs-keyword">self</span>.client.hset(<span class="hljs-string">"fibs"</span>, str(n), str(result))    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_fib</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, n)</span></span><span class="hljs-symbol">:</span>        result = <span class="hljs-keyword">self</span>.client.hget(<span class="hljs-string">"fibs"</span>, str(n))        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-symbol">result:</span>            <span class="hljs-keyword">return</span>        <span class="hljs-keyword">return</span> int(result)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set_pi</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, n, result)</span></span><span class="hljs-symbol">:</span>        <span class="hljs-keyword">self</span>.client.hset(<span class="hljs-string">"pis"</span>, str(n), str(result))    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_pi</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, n)</span></span><span class="hljs-symbol">:</span>        result = <span class="hljs-keyword">self</span>.client.hget(<span class="hljs-string">"pis"</span>, str(n))        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-symbol">result:</span>            <span class="hljs-keyword">return</span>        <span class="hljs-keyword">return</span> float(result)client = redis.StrictRedis()cache = PiCache(client)<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MathAPI</span>(<span class="hljs-title">FlaskView</span>):</span>    @route(<span class="hljs-string">"/pi/&lt;int:n&gt;"</span>)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pi</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, n)</span></span><span class="hljs-symbol">:</span>        result = cache.get_pi(n)        <span class="hljs-keyword">if</span> <span class="hljs-symbol">result:</span>            <span class="hljs-keyword">return</span> jsonify(&#123;<span class="hljs-string">"cached"</span>: True, <span class="hljs-string">"result"</span>: result&#125;)        s = <span class="hljs-number">0</span>.<span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, n)<span class="hljs-symbol">:</span>            s += <span class="hljs-number">1.0</span>/i/i        result = math.sqrt(<span class="hljs-number">6</span>*s)        cache.set_pi(n, result)        <span class="hljs-keyword">return</span> jsonify(&#123;<span class="hljs-string">"cached"</span>: False, <span class="hljs-string">"result"</span>: result&#125;)    @route(<span class="hljs-string">"/fib/&lt;int:n&gt;"</span>)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, n)</span></span><span class="hljs-symbol">:</span>        result, cached = <span class="hljs-keyword">self</span>.get_fib(n)        <span class="hljs-keyword">return</span> jsonify(&#123;<span class="hljs-string">"cached"</span>: cached, <span class="hljs-string">"result"</span>: result&#125;)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_fib</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, n)</span></span>: <span class="hljs-comment"># 递归，n不能过大，否则会堆栈过深溢出stackoverflow</span>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span><span class="hljs-symbol">:</span>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, True        <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span><span class="hljs-symbol">:</span>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>, True        result = cache.get_fib(n)        <span class="hljs-keyword">if</span> <span class="hljs-symbol">result:</span>            <span class="hljs-keyword">return</span> result, True        result = <span class="hljs-keyword">self</span>.get_fib(n-<span class="hljs-number">1</span>)[<span class="hljs-number">0</span>] + <span class="hljs-keyword">self</span>.get_fib(n-<span class="hljs-number">2</span>)[<span class="hljs-number">0</span>]        cache.set_fib(n, result)        <span class="hljs-keyword">return</span> result, FalseMathAPI.register(app, route_base=<span class="hljs-string">'/'</span>)  <span class="hljs-comment"># 注册到app</span><span class="hljs-keyword">if</span> __name_<span class="hljs-number">_</span> == <span class="hljs-string">'__main__'</span><span class="hljs-symbol">:</span>    app.run(<span class="hljs-string">'127.0.0.1'</span>, <span class="hljs-number">5000</span>)</code></pre></div>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>notes/python/flask/基本</title>
    <link href="/2020/07/14/notes/python/flask/%E5%9F%BA%E6%9C%AC/"/>
    <url>/2020/07/14/notes/python/flask/%E5%9F%BA%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flaskapp = Flask(__name__) <span class="hljs-meta">@app.route('/')</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello_world</span><span class="hljs-params">()</span>:</span>    <span class="hljs-keyword">return</span> <span class="hljs-string">'Hello World!'</span> <span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:    app.run()</code></pre></div><h2 id="1-实例化Flask对象时，可选的参数"><a href="#1-实例化Flask对象时，可选的参数" class="headerlink" title="1.实例化Flask对象时，可选的参数"></a>1.实例化Flask对象时，可选的参数</h2><p>app = Flask(<strong>name</strong>)    # 这是实例化一个Flask对象，最基本的写法</p><p># 但是Flask中还有其他参数，以下是可填的参数，及其默认值</p><p>def <strong>init</strong>(self, import_name, static_path=None,<br>static_url_path=None,<br>                 static_folder=’static’, template_folder=’templates’,<br>                 instance_path=None, instance_relative_config=False,<br>                 root_path=None):</p><p>template_folder：模板所在文件夹的名字</p><p>root_path：可以不用填，会自动找到，当前执行文件，所在目录地址</p><p>在return render_template时会将上面两个进行拼接，找到对应的模板地址</p><p>static_folder：静态文件所在文件的名字，默认是static，可以不用填</p><p>static_url_path：静态文件的地址前缀，写成什么，访问静态文件时，就要在前面加上这个</p><h2 id="绑定路由关系的两种方式"><a href="#绑定路由关系的两种方式" class="headerlink" title="绑定路由关系的两种方式"></a>绑定路由关系的两种方式</h2><p>#方式一</p><div class="hljs"><pre><code class="hljs ruby">@app.route(<span class="hljs-string">'/index.html'</span>,methods=[<span class="hljs-string">'GET'</span>,<span class="hljs-string">'POST'</span>],endpoint=<span class="hljs-string">'index'</span>)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">index</span><span class="hljs-params">()</span></span><span class="hljs-symbol">:</span>        <span class="hljs-keyword">return</span> <span class="hljs-string">'Index'</span></code></pre></div><p>#方式二</p><div class="hljs"><pre><code class="hljs reasonml">def index<span class="hljs-literal">()</span>:    return <span class="hljs-string">"Index"</span>self.add<span class="hljs-constructor">_url_rule(<span class="hljs-params">rule</span>='<span class="hljs-operator">/</span><span class="hljs-params">index</span>.<span class="hljs-params">html</span>', <span class="hljs-params">endpoint</span>=<span class="hljs-string">"index"</span>, <span class="hljs-params">view_func</span>=<span class="hljs-params">index</span>, <span class="hljs-params">methods</span>=[<span class="hljs-string">"GET"</span>,<span class="hljs-string">"POST"</span>])</span>    #endpoint是别名<span class="hljs-keyword">or</span>app.add<span class="hljs-constructor">_url_rule(<span class="hljs-params">rule</span>='<span class="hljs-operator">/</span><span class="hljs-params">index</span>.<span class="hljs-params">html</span>', <span class="hljs-params">endpoint</span>=<span class="hljs-string">"index"</span>, <span class="hljs-params">view_func</span>=<span class="hljs-params">index</span>, <span class="hljs-params">methods</span>=[<span class="hljs-string">"GET"</span>,<span class="hljs-string">"POST"</span>])</span>app.view_functions<span class="hljs-literal">['<span class="hljs-identifier">index</span>']</span> = index</code></pre></div><h2 id="2-Flask中装饰器应用"><a href="#2-Flask中装饰器应用" class="headerlink" title="2.Flask中装饰器应用"></a>2.Flask中装饰器应用</h2><h1 id="四、路由系统"><a href="#四、路由系统" class="headerlink" title="四、路由系统"></a>四、路由系统</h1><h2 id="1-可传入参数："><a href="#1-可传入参数：" class="headerlink" title="1.可传入参数："></a>1.可传入参数：</h2><div class="hljs"><pre><code class="hljs less"><span class="hljs-variable">@app</span>.route(<span class="hljs-string">'/user/&lt;username&gt;'</span>)   #常用的   不加参数的时候默认是字符串形式的<span class="hljs-variable">@app</span>.route(<span class="hljs-string">'/post/&lt;int:post_id&gt;'</span>)  #常用的   #指定int，说明是整型的<span class="hljs-variable">@app</span>.route(<span class="hljs-string">'/post/&lt;float:post_id&gt;'</span>)<span class="hljs-variable">@app</span>.route(<span class="hljs-string">'/post/&lt;path:path&gt;'</span>)<span class="hljs-variable">@app</span>.route(<span class="hljs-string">'/login'</span>, methods=[<span class="hljs-string">'GET'</span>, <span class="hljs-string">'POST'</span>])</code></pre></div><div class="hljs"><pre><code class="hljs ebnf"><span class="hljs-attribute">DEFAULT_CONVERTERS</span> = &#123;    <span class="hljs-string">'default'</span>:          UnicodeConverter,    <span class="hljs-string">'string'</span>:           UnicodeConverter,    <span class="hljs-string">'any'</span>:              AnyConverter,    <span class="hljs-string">'path'</span>:             PathConverter,    <span class="hljs-string">'int'</span>:              IntegerConverter,    <span class="hljs-string">'float'</span>:            FloatConverter,    <span class="hljs-string">'uuid'</span>:             UUIDConverter,&#125;</code></pre></div><h2 id="2-反向生成URL：-url-for"><a href="#2-反向生成URL：-url-for" class="headerlink" title="2.反向生成URL： url_for"></a>2.反向生成URL： url_for</h2><div class="hljs"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">endpoint</span><span class="hljs-params">(<span class="hljs-string">"name"</span>)</span></span>   #别名，相当于django中的name</code></pre></div><div class="hljs"><pre><code class="hljs ruby">from flask import Flask, url_for@app.route(<span class="hljs-string">'/index'</span>,endpoint=<span class="hljs-string">"xxx"</span>)  <span class="hljs-comment">#endpoint是别名</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">index</span><span class="hljs-params">()</span></span><span class="hljs-symbol">:</span>    v = url_for(<span class="hljs-string">"xxx"</span>)    print(v)    <span class="hljs-keyword">return</span> <span class="hljs-string">"index"</span>@app.route(<span class="hljs-string">'/zzz/&lt;int:nid&gt;'</span>,endpoint=<span class="hljs-string">"aaa"</span>)  <span class="hljs-comment">#endpoint是别名</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">zzz</span><span class="hljs-params">(nid)</span></span><span class="hljs-symbol">:</span>    v = url_for(<span class="hljs-string">"aaa"</span>,nid=nid)    print(v)    <span class="hljs-keyword">return</span> <span class="hljs-string">"index2"</span></code></pre></div>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>启动容器</title>
    <link href="/2020/07/14/notes/docker/%E8%BF%90%E8%A1%8C%E4%B8%80%E4%B8%AA%E5%AE%B9%E5%99%A8/"/>
    <url>/2020/07/14/notes/docker/%E8%BF%90%E8%A1%8C%E4%B8%80%E4%B8%AA%E5%AE%B9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="运行一个容器"><a href="#运行一个容器" class="headerlink" title="运行一个容器"></a>运行一个容器</h2><p><code>docker run</code></p><p>通过docker的两个参数 -i -t，让docker运行的容器实现”对话”的能力</p><p><code>-t:在新容器内指定一个伪终端或终端。</code></p><p><code>-i:允许你对容器内的标准输入 (STDIN) 进行交互。</code></p><h2 id="启动容器（后台模式）"><a href="#启动容器（后台模式）" class="headerlink" title="启动容器（后台模式）"></a>启动容器（后台模式）</h2><p>创建一个以进程方式运行的容器</p><p><code>docker run -d</code></p><hr><p>容器ID，对每个容器来说都是唯一的，我们可以通过容器ID来查看对应的容器发生了什么   </p><p>确认容器有在运行，可以通过docker ps来查看</p><hr><p>docker logs <em>CONTAINER ID(容器ID)</em><br>查看容器内的标准输出</p><hr><p>停止容器<br>docker stop <em>ID</em> or <em>name</em></p><hr><p>-d:让容器在后台运行。</p><p>-P:端口映射</p><hr><p>查看容器端口的映射情况<br>docker port bf08b7f2cd89</p><hr><p>查看容器内部的标准输出</p><p><code>docker logs -f bf08b7f2cd89</code></p><p>-f:让docker logs像使用tail -f一样来输出容器内部的标准输出。</p><hr><p>使用 docker top 来查看容器内部运行的进程</p><p>docker top <em>ID or name</em></p><hr><p>查看 Docker 的底层信息</p><p>docker inspect</p>]]></content>
    
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>构建镜像</title>
    <link href="/2020/07/14/notes/docker/%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F/"/>
    <url>/2020/07/14/notes/docker/%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><p><code>docker build -t &lt;imagesTag&gt; -f &lt;Dockerfile&gt; .</code></p><p><code>docker build -t deepfakes-gpu -f Dockerfile2.gpu .</code></p><p>我们使用命令 docker build ， 从零开始来创建一个新的镜像。为此，我们需要创建一个 Dockerfile 文件，其中包含一组指令来告诉 Docker 如何构建我们的镜像。<br>每一个指令都会在镜像上创建一个新的层，每一个指令的前缀都必须是大写的。</p><p>第一条<strong>FROM，指定使用哪个镜像源</strong></p><p><strong>RUN 指令告诉docker 在镜像内执行命令，安装了什么</strong>。。。</p><p>然后，我们使用 Dockerfile 文件，通过 <strong>docker build</strong> 命令来构建一个镜像。</p><h2 id="设置镜像标签"><a href="#设置镜像标签" class="headerlink" title="设置镜像标签"></a>设置镜像标签</h2><p>使用 docker tag 命令，为镜像添加一个新的标签。</p>]]></content>
    
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>dockerfile</tag>
      
      <tag>build</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker 命令</title>
    <link href="/2020/07/14/notes/docker/docker%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5/"/>
    <url>/2020/07/14/notes/docker/docker%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="容器生命周期管理"><a href="#容器生命周期管理" class="headerlink" title="容器生命周期管理"></a>容器生命周期管理</h2><ul><li>run 创建一个新的容器并运行一个命令</li><li>rm 删除不需要的容器</li><li>stop 停止</li><li>start 启动</li><li>restart 重启</li><li>docker images 列出本地主机上的镜像</li><li>kill 杀掉一个运行中的容器</li><li>pause 暂停容器中所有的进程。</li><li>unpause 恢复容器中所有的进程</li><li>create 创建一个新的容器但不启动它</li><li>exec 在运行的容器中执行命令</li></ul><h2 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h2><ul><li>ps        列出容器</li><li>logs  获取容器的日志</li><li>top 查看容器中运行的进程信息，支持 ps 命令参数。</li><li>port 列出指定的容器的端口映射，或者查找将PRIVATE_PORT NAT到面向公众的端口。</li><li>attach 连接到正在运行中的容器。</li><li>events  从服务器获取实时事件</li><li>inspect   获取容器/镜像的元数据</li><li>wait      阻塞运行直到容器停止，然后打印出它的退出代码。</li><li>export    将文件系统作为一个tar归档文件导出到STDOUT。</li></ul><h2 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="[OPTIONS]"></a>[OPTIONS]</h2><ul><li>-P :是容器内部端口<strong>随机</strong>映射到主机的端口。</li><li>-p : 是容器内部端口<strong>绑定</strong>到指定的主机端口。</li></ul><h2 id="本地镜像管理"><a href="#本地镜像管理" class="headerlink" title="本地镜像管理"></a>本地镜像管理</h2><ul><li>images  列出本地镜像。</li><li>rmi  删除本地一个或多少镜像。</li><li>tag  标记本地镜像，将其归入某一仓库。</li><li>build 命令用于使用 Dockerfile 创建镜像。</li><li>save 将指定镜像保存成 tar 归档文件</li><li>import  从归档文件中创建镜像。</li><li>load  导入使用 docker save 命令导出的镜像。</li><li>history  查看指定镜像的创建历史。</li></ul><h2 id="容器rootfs命令"><a href="#容器rootfs命令" class="headerlink" title="容器rootfs命令"></a>容器rootfs命令</h2><ul><li>commit 从容器创建一个新的镜像</li><li>cp 用于容器与主机之间的数据拷贝</li><li>diff 检查容器里文件结构的更改</li></ul><h2 id="镜像仓库"><a href="#镜像仓库" class="headerlink" title="镜像仓库"></a>镜像仓库</h2><ul><li>search : 从Docker Hub查找镜像</li><li>login : 登陆到一个Docker镜像仓库</li><li>logout : 登出一个Docker镜像仓库</li><li>pull : 从镜像仓库中拉取或者更新指定镜像</li><li>push : 将本地的镜像上传到镜像仓库,要先登陆到镜像仓库</li></ul><h2 id="info-version"><a href="#info-version" class="headerlink" title="info|version"></a>info|version</h2><ul><li>info : 显示 Docker 系统信息，包括镜像和容器数</li><li>version :显示 Docker 版本信息</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>cheatsheet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dockerTools的坑</title>
    <link href="/2020/07/14/notes/docker/dockerTools%E7%9A%84%E5%9D%91/"/>
    <url>/2020/07/14/notes/docker/dockerTools%E7%9A%84%E5%9D%91/</url>
    
    <content type="html"><![CDATA[<h2 id="目录挂载-v"><a href="#目录挂载-v" class="headerlink" title="目录挂载(-v)"></a>目录挂载(<code>-v</code>)</h2><p>window中，docker会将<code>c:...</code>中的<code>:</code>误读，应根据共享文件夹，写成<code>/c/</code></p><h2 id="端口映射-p"><a href="#端口映射-p" class="headerlink" title="端口映射(-p)"></a>端口映射(<code>-p</code>)</h2><p>端口会映射到打开<code>Docker Quickstart Terminal</code>时显示的IP地址，即<strong>docker虚拟机的IP</strong>，而不是<code>localhost</code></p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>启动</p><div class="hljs"><pre><code class="hljs bat">docker run  --name localserver --rm -v /c/Users/air/Documents/GitHub/vback_sys:/usr/share/nginx/html:ro -p <span class="hljs-number">80</span>:<span class="hljs-number">80</span> -d nginx:stable-alpine</code></pre></div><p>浏览器输入</p><p><code>http://192.168.99.100/:80</code></p>]]></content>
    
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>坑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker 容器连接</title>
    <link href="/2020/07/14/notes/docker/Docker%20%E5%AE%B9%E5%99%A8%E8%BF%9E%E6%8E%A5/"/>
    <url>/2020/07/14/notes/docker/Docker%20%E5%AE%B9%E5%99%A8%E8%BF%9E%E6%8E%A5/</url>
    
    <content type="html"><![CDATA[<p>前面我们实现了通过<strong>网络端口</strong>来访问运行在 docker <strong>容器内的服务</strong>。下面我们来实现<strong>通过端口</strong>连接到<strong>一个 docker 容器</strong></p><h2 id="网络端口映射"><a href="#网络端口映射" class="headerlink" title="网络端口映射"></a>网络端口映射</h2><p>-p</p><p>-P</p><h2 id="Docker容器连接"><a href="#Docker容器连接" class="headerlink" title="Docker容器连接"></a>Docker容器连接</h2><p>端口映射并不是唯一把 docker 连接到另一个容器的方法。</p><p>docker 有一个<strong>连接系统</strong>允许将<strong>多个容器连接在一起</strong>，共享连接信息。</p><p>docker 连接会创建一个<strong>父子关系</strong>，其中父容器可以看到子容器的信息。</p><h3 id="容器命名"><a href="#容器命名" class="headerlink" title="容器命名"></a>容器命名</h3><p>当我们创建一个容器的时候，docker 会自动对它进行命名。另外，我们也可以使用 –name 标识来命名容器</p>]]></content>
    
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>容器连接</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用镜像及用法</title>
    <link href="/2020/07/14/notes/docker/%E5%B8%B8%E7%94%A8%E9%95%9C%E5%83%8F%E5%8F%8A%E7%94%A8%E6%B3%95/"/>
    <url>/2020/07/14/notes/docker/%E5%B8%B8%E7%94%A8%E9%95%9C%E5%83%8F%E5%8F%8A%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="停止并删除"><a href="#停止并删除" class="headerlink" title="停止并删除"></a>停止并删除</h2><p><code>docker rm $(docker stop mysql)</code></p><h2 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h2><p><code>docker run --name index -p 443:80 -v $(realpath ~/index):/usr/share/nginx/html:ro -d nginx:stable-alpine</code></p><h2 id="tensorflow"><a href="#tensorflow" class="headerlink" title="tensorflow"></a>tensorflow</h2><h3 id="bash"><a href="#bash" class="headerlink" title="bash"></a>bash</h3><div class="hljs"><pre><code class="hljs bash"><span class="hljs-comment"># cpu</span>docker run -it --rm -v $(realpath bert):/srv -p 8888:8888 tensorflow/tensorflow:1.13.1-py3-jupyter bash<span class="hljs-comment"># gpu</span>docker run --runtime=nvidia -it --rm -v $(realpath bert):/notebooks -p 8888:8888 tensorflow/tensorflow:1.13.1-gpu-py3-jupyter bash</code></pre></div><h3 id="直接运行python"><a href="#直接运行python" class="headerlink" title="直接运行python"></a>直接运行python</h3><div class="hljs"><pre><code class="hljs bash"><span class="hljs-comment"># cpu</span>docker run --rm tensorflow/tensorflow:1.13.1-py3-jupyter \       python -c <span class="hljs-string">"import tensorflow as tf; tf.enable_eager_execution(); print(tf.reduce_sum(tf.random_normal([1000, 1000])))"</span><span class="hljs-comment"># gpu</span>docker run --runtime=nvidia --rm tensorflow/tensorflow:1.13.1-py3-jupyter \       python -c <span class="hljs-string">"import tensorflow as tf; tf.enable_eager_execution(); print(tf.reduce_sum(tf.random_normal([1000, 1000])))"</span></code></pre></div><h2 id="gpu相关"><a href="#gpu相关" class="headerlink" title="gpu相关"></a>gpu相关</h2><p>查看驱动及cuda</p><p><code>nvidia-smi</code></p><p>检查 GPU 是否可用</p><p><code>lspci | grep -i nvidia</code></p><h2 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h2><p><code>docker run --name mysql -p 3306:3306 -v $(realpath ~/etc/mysql/datadir):/var/lib/mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:5.7</code></p><h3 id="Where-to-Store-Data"><a href="#Where-to-Store-Data" class="headerlink" title="Where to Store Data"></a>Where to Store Data</h3><p><code>-v $(realpath ~/etc/mysql/datadir):/var/lib/mysql</code></p><h3 id="Using-a-custom-MySQL-configuration-file"><a href="#Using-a-custom-MySQL-configuration-file" class="headerlink" title="Using a custom MySQL configuration file"></a>Using a custom MySQL configuration file</h3><p><code>docker run --name mysql -v $(realpath ~/etc/mysql/conf.d):/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:5.7</code></p><h3 id="Creating-database-dumps"><a href="#Creating-database-dumps" class="headerlink" title="Creating database dumps"></a>Creating database dumps</h3><p><code>docker exec some-mysql sh -c &#39;exec mysqldump --all-databases -uroot -p&quot;$MYSQL_ROOT_PASSWORD&quot;&#39; &gt; /some/path/on/your/host/all-databases.sql</code></p><h3 id="Restoring-data-from-dump-files"><a href="#Restoring-data-from-dump-files" class="headerlink" title="Restoring data from dump files"></a>Restoring data from dump files</h3><p><code>docker exec -i some-mysql sh -c &#39;exec mysql -uroot -p&quot;$MYSQL_ROOT_PASSWORD&quot;&#39; &lt; /some/path/on/your/host/all-databases.sql</code></p><h2 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h2><p><code>docker run --name ss-redis -d redis:alpine redis-server --appendonly yes</code></p><p><code>-p 6379:6379 \</code></p><div class="hljs"><pre><code class="hljs bash">docker run -d --name ss-redis \    -v ~/etc/redis/redis.conf:/usr/<span class="hljs-built_in">local</span>/etc/redis/redis.conf \    --network=host \    redis:alpine \    redis-server /usr/<span class="hljs-built_in">local</span>/etc/redis/redis.conf</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>nginx</tag>
      
      <tag>mysql</tag>
      
      <tag>redis</tag>
      
      <tag>tensorflow</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gulp任务(task)惰性获取数据</title>
    <link href="/2019/11/07/notes/web/gulp/%E4%BB%BB%E5%8A%A1%E6%83%B0%E6%80%A7%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE/"/>
    <url>/2019/11/07/notes/web/gulp/%E4%BB%BB%E5%8A%A1%E6%83%B0%E6%80%A7%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE/</url>
    
    <content type="html"><![CDATA[<p>项目中有多个深度不同目录存在未压缩的文件，要压缩这些代码目前想到的方式是以下步骤：</p><ol><li>通过<code>dfs</code>遍历所有文件夹</li><li>遍历过程中根据需要打包的文件创建对应的压缩任务，并将任务存入数组(<code>jsTasks</code>)</li><li><code>dfs</code>执行完成后，执行数组中的内容</li></ol><h2 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h2><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> js = parallel(...jsTasks);</code></pre></div><p>按照这种写法，<code>jsTasks</code>会在<code>dfs</code>执行前被立即被读取,因此<code>jsTasks</code>返回的数组的长度为<code>0</code></p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>将<code>parallel(...jsTasks)</code>在函数中执行，将<code>cb</code>传入作为结束标志。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">js</span>(<span class="hljs-params">cb</span>) </span>&#123;    <span class="hljs-comment">// 这些是防止jsTasks.length真的为0</span>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"jsTasks: "</span>, jsTasks.length);    <span class="hljs-keyword">if</span> (jsTasks.length === <span class="hljs-number">0</span>) &#123; cb(); <span class="hljs-keyword">return</span>; &#125;;    <span class="hljs-comment">// 在js中执行parallel</span>    parallel(...jsTasks)(cb);&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>gulp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gulp简介</title>
    <link href="/2019/11/06/notes/web/gulp/%E7%AE%80%E4%BB%8B/"/>
    <url>/2019/11/06/notes/web/gulp/%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<p>Gulp是基于流的前端构建工具，在代码写好之后，通过gulp进行编译压缩。</p><p>Webpack 是前端资源模块化 管理和打包工具。从入口开始，递归找出所有依赖。</p><h2 id="Gulpfile"><a href="#Gulpfile" class="headerlink" title="Gulpfile"></a>Gulpfile</h2><p>gulpfile 是项目目录下名为 gulpfile.js （或者首字母大写 Gulpfile.js）的文件，在运行 gulp 命令时会被自动加载</p><h2 id="创建任务"><a href="#创建任务" class="headerlink" title="创建任务"></a>创建任务</h2><h3 id="导出任务"><a href="#导出任务" class="headerlink" title="导出任务"></a>导出任务</h3><p>任务（tasks）有 public（公开） 或 private（私有） 两种。</p><ul><li>公开任务（Public tasks） 从 gulpfile 中被导出（export），可以通过 gulp 命令直接调用。</li><li>私有任务（Private tasks） 被设计为在内部使用，通常作为 <code>series()</code> 或 <code>parallel()</code> 组合的组成部分。</li></ul><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> &#123; series &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">'gulp'</span>);<span class="hljs-comment">// 私有任务</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clean</span>(<span class="hljs-params">cb</span>) </span>&#123;    <span class="hljs-comment">// body omitted</span>    cb();&#125;<span class="hljs-comment">// 函数被导出（export）了，因此是一个公开任务，并且可以被 `gulp` 命令直接调用。</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">build</span>(<span class="hljs-params">cb</span>) </span>&#123;    <span class="hljs-comment">// body omitted</span>    cb();&#125;exports.build = build;exports.default = series(clean, build);</code></pre></div><h3 id="组合任务"><a href="#组合任务" class="headerlink" title="组合任务"></a>组合任务</h3><p>Gulp 提供了两个强大的组合方法： <code>series()</code> 和 <code>parallel()</code>来组合任务,并且可以相互嵌套。</p><ul><li><code>series()</code>：<ul><li>任务（task）按顺序执行</li><li>组合多个任务时，任何一个任务的错误将导致整个任务组合结束</li></ul></li><li><code>parallel()</code>：<ul><li>以最大并发来运行的任务</li><li>组合多个任务时，一个任务的错误将结束整个任务组合的结束，但是其他并行的任务可能会执行完，也可能没有执行完。</li></ul></li></ul><h2 id="gulp-异步任务（task）规范"><a href="#gulp-异步任务（task）规范" class="headerlink" title="gulp 异步任务（task）规范"></a>gulp 异步任务（task）规范</h2><p>gulp 不再支持同步任务，但是可以通过以下方式当作异步任务。</p><h3 id="有返回值"><a href="#有返回值" class="headerlink" title="有返回值"></a>有返回值</h3><p>当从任务（task）中返回 <code>stream</code>、<code>promise</code>、<code>event emitter</code>、<code>child process</code> 或 <code>observable</code> 时，成功或错误值将通知 gulp 是否继续执行或结束。如果任务（task）出错，gulp 将立即结束执行并显示该错误。</p><h3 id="无返回值"><a href="#无返回值" class="headerlink" title="无返回值"></a>无返回值</h3><h4 id="使用-callback"><a href="#使用-callback" class="headerlink" title="使用 callback"></a>使用 callback</h4><p>callback 将作为唯一一个名为 <code>cb()</code> 的参数，作为任务结束的标志。可以通过<code>cb()</code>传递错误</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callbackTask</span>(<span class="hljs-params">cb</span>) </span>&#123;    <span class="hljs-comment">// `cb()` should be called by some async work</span>    cb();&#125;exports.default = callbackTask;</code></pre></div><h4 id="使用-async-await"><a href="#使用-async-await" class="headerlink" title="使用 async/await"></a>使用 async/await</h4><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncAwaitTask</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">const</span> &#123; version &#125; = fs.readFileSync(<span class="hljs-string">'package.json'</span>);    <span class="hljs-built_in">console</span>.log(version);    <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'some result'</span>);&#125;exports.default = asyncAwaitTask;</code></pre></div><h2 id="处理文件"><a href="#处理文件" class="headerlink" title="处理文件"></a>处理文件</h2><p>gulp基于流处理文件，一个通常的形式如下：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">task1</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> src(<span class="hljs-string">'src/*.js'</span>)        .pipe(babel())        .pipe(dest(<span class="hljs-string">'output/'</span>));&#125;</code></pre></div><ol><li>通过<code>src()</code>从文件系统中<strong>读取文件</strong>然后生成一个 Node 流（stream）</li><li>通过pipe()，以插件作为参数，处理流</li><li><code>dest()</code> 接受一个输出目录作为参数，并且它还会产生一个 Node 流，通常作为终止流，将文件内容及文件属性<strong>写入到指定的目录</strong>中。</li></ol>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
      <category>gulp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>gulp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gulp的一些常用插件</title>
    <link href="/2019/11/06/notes/web/gulp/%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/"/>
    <url>/2019/11/06/notes/web/gulp/%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="del"><a href="#del" class="headerlink" title="del"></a><code>del</code></h2><p>用来删除指定文件夹或文件</p><h2 id="gulp-clean-css"><a href="#gulp-clean-css" class="headerlink" title="gulp-clean-css"></a><code>gulp-clean-css</code></h2><p>压缩css</p><h2 id="gulp-uglify"><a href="#gulp-uglify" class="headerlink" title="gulp-uglify"></a><code>gulp-uglify</code></h2><p>压缩js，只支持ES5</p><h2 id="gulp-uglify-es"><a href="#gulp-uglify-es" class="headerlink" title="gulp-uglify-es"></a><code>gulp-uglify-es</code></h2><p>压缩js，支持ES6</p><h2 id="gulp-htmlmin"><a href="#gulp-htmlmin" class="headerlink" title="gulp-htmlmin"></a><code>gulp-htmlmin</code></h2><p>压缩html</p><h2 id="gulp-gzip"><a href="#gulp-gzip" class="headerlink" title="gulp-gzip"></a><code>gulp-gzip</code></h2><p>生成<code>.gzip</code>文件</p><h2 id="rollup"><a href="#rollup" class="headerlink" title="rollup"></a><code>rollup</code></h2><p><a href="https://www.rollupjs.com/" target="_blank" rel="noopener">https://www.rollupjs.com/</a></p><h2 id="gulp-babel"><a href="#gulp-babel" class="headerlink" title="gulp-babel"></a><code>gulp-babel</code></h2><p>Babel的Gulp插件</p>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>gulp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PWA(渐进式网络应用程序)</title>
    <link href="/2019/11/04/notes/web/webpack/PWA(%E6%B8%90%E8%BF%9B%E5%BC%8F%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F)/"/>
    <url>/2019/11/04/notes/web/webpack/PWA(%E6%B8%90%E8%BF%9B%E5%BC%8F%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F)/</url>
    
    <content type="html"><![CDATA[<p>渐进式网络应用程序(Progressive Web Application - PWA)，是一种可以提供类似于原生应用程序(native app)体验的网络应用程序(web app)。PWA 可以用来做很多事。其中最重要的是，<strong>在离线(offline)时应用程序能够继续运行功能</strong>。这是通过使用名为 Service Workers 的网络技术来实现的。</p><h2 id="添加-workbox-webpack-plugin-插件"><a href="#添加-workbox-webpack-plugin-插件" class="headerlink" title="添加 workbox-webpack-plugin 插件"></a>添加 <code>workbox-webpack-plugin</code> 插件</h2><p>使用Google项目的Workbox来实现此目的，该项目提供的工具可帮助我们更轻松地配置 web app 的离线支持。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// webpack.config.js</span><span class="hljs-keyword">const</span> WorkboxPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'workbox-webpack-plugin'</span>);plugins: [    <span class="hljs-keyword">new</span> WorkboxPlugin.GenerateSW(&#123;        <span class="hljs-comment">// 这些选项帮助 ServiceWorkers 快速启用</span>        <span class="hljs-comment">// 不允许遗留任何“旧的” ServiceWorkers</span>        clientsClaim: <span class="hljs-literal">true</span>,        skipWaiting: <span class="hljs-literal">true</span>    &#125;)],</code></pre></div><p><code>npm run build</code>后多出两个文件：</p><ul><li><code>service-worker.js</code>是 Service Worker 文件</li><li><code>workbox-abaa1409.js</code>是 <code>service-worker.js</code> 引用的文件</li></ul><h2 id="注册Service-Worker"><a href="#注册Service-Worker" class="headerlink" title="注册Service Worker"></a>注册<code>Service Worker</code></h2><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// index.js</span><span class="hljs-keyword">if</span> (<span class="hljs-string">'serviceWorker'</span> <span class="hljs-keyword">in</span> navigator) &#123;  <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'load'</span>, () =&gt; &#123;    navigator.serviceWorker.register(<span class="hljs-string">'/service-worker.js'</span>).then(<span class="hljs-function"><span class="hljs-params">registration</span> =&gt;</span> &#123;      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'SW registered: '</span>, registration);    &#125;).catch(<span class="hljs-function"><span class="hljs-params">registrationError</span> =&gt;</span> &#123;      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'SW registration failed: '</span>, registrationError);    &#125;);  &#125;);&#125;</code></pre></div><p>之后停止服务器并刷新页面。如果浏览器能够支持 <code>Service Worker</code>，你应该可以看到你的应用程序还在正常运行。</p>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>优化</tag>
      
      <tag>webpack</tag>
      
      <tag>pwa</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack的一些插件简介</title>
    <link href="/2019/11/04/notes/web/webpack/%E4%B8%80%E4%BA%9B%E6%8F%92%E4%BB%B6%E7%AE%80%E4%BB%8B/"/>
    <url>/2019/11/04/notes/web/webpack/%E4%B8%80%E4%BA%9B%E6%8F%92%E4%BB%B6%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="HotModuleReplacementPlugin"><a href="#HotModuleReplacementPlugin" class="headerlink" title="HotModuleReplacementPlugin"></a><code>HotModuleReplacementPlugin</code></h2><p>模块热替换插件，适用于开发环境。</p><h2 id="CleanWebpackPlugin"><a href="#CleanWebpackPlugin" class="headerlink" title="CleanWebpackPlugin"></a><code>CleanWebpackPlugin</code></h2><p>用于每次<code>npm run build</code>时清理<code>dist</code>文件夹</p><h2 id="CompressionWebpackPlugin"><a href="#CompressionWebpackPlugin" class="headerlink" title="CompressionWebpackPlugin"></a><code>CompressionWebpackPlugin</code></h2><p><code>npm run build</code>同时生成压缩版的文件，一般为<code>gzip</code>格式</p><h2 id="HtmlWebpackPlugin"><a href="#HtmlWebpackPlugin" class="headerlink" title="HtmlWebpackPlugin"></a><code>HtmlWebpackPlugin</code></h2><p>生成一个 HTML5 文件， 其中包括使用 script 标签的 body 中的所有 webpack 包。</p><p>可以通过多个<code>HtmlWebpackPlugin</code>实例生成多个<code>html</code>文件</p><div class="hljs"><pre><code class="hljs js">entry: &#123;        index: <span class="hljs-string">'./src/index.js'</span>,        about: <span class="hljs-string">'./src/about.js'</span>&#125;,plugins: [    <span class="hljs-keyword">new</span> HtmlWebpackPlugin(&#123;        title: <span class="hljs-string">'index'</span>,        filename: <span class="hljs-string">'index.html'</span>,        chunks: [<span class="hljs-string">'index'</span>]    &#125;),    <span class="hljs-keyword">new</span> HtmlWebpackPlugin(&#123;        title: <span class="hljs-string">'about'</span>,        filename: <span class="hljs-string">'about.html'</span>,        chunks: [<span class="hljs-string">'about'</span>]    &#125;)]</code></pre></div><h2 id="ProvidePlugin"><a href="#ProvidePlugin" class="headerlink" title="ProvidePlugin"></a><code>ProvidePlugin</code></h2><ul><li>自动加载全局变量的模块</li><li>引入polyfill</li><li>综合以上两种方式，可以单独使用模块中的变量替代原有的变量(polyfill + 按需引入)</li></ul><p>对于<code>ProvidePlugin</code>引入的内容会被打包</p><h2 id="DefinePlugin"><a href="#DefinePlugin" class="headerlink" title="DefinePlugin"></a><code>DefinePlugin</code></h2><p>允许创建一个在编译时可以配置的全局常量。这可能会对开发模式和发布模式的构建允许不同的行为非常有用。通常使用该插件来判别代码运行的环境变量</p><h2 id="SplitChunksPlugin"><a href="#SplitChunksPlugin" class="headerlink" title="SplitChunksPlugin"></a><code>SplitChunksPlugin</code></h2><p>抽取重复依赖模块</p><h2 id="WorkboxPlugin"><a href="#WorkboxPlugin" class="headerlink" title="WorkboxPlugin"></a><code>WorkboxPlugin</code></h2><p>配置PWA</p>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack shimming</title>
    <link href="/2019/11/03/notes/web/webpack/shimming/"/>
    <url>/2019/11/03/notes/web/webpack/shimming/</url>
    
    <content type="html"><![CDATA[<p>有两种应用场景：</p><ul><li>设置全局变量</li><li>polyfill 浏览器功能</li></ul><h2 id="shimming-全局变量"><a href="#shimming-全局变量" class="headerlink" title="shimming 全局变量"></a>shimming 全局变量</h2><p>添加<code>ProvidePlugin</code></p><div class="hljs"><pre><code class="hljs js">plugins: [    <span class="hljs-keyword">new</span> webpack.ProvidePlugin(&#123;        _: <span class="hljs-string">'lodash'</span>    &#125;)]</code></pre></div><h3 id="暴露某个模块中单个值"><a href="#暴露某个模块中单个值" class="headerlink" title="暴露某个模块中单个值"></a>暴露某个模块中单个值</h3><div class="hljs"><pre><code class="hljs js">plugins: [    <span class="hljs-keyword">new</span> webpack.ProvidePlugin(&#123;        <span class="hljs-comment">// _: 'lodash',</span>        join: [<span class="hljs-string">'lodash'</span>, <span class="hljs-string">'join'</span>]    &#125;)]</code></pre></div><h3 id="通过使用-imports-loader-覆写-this"><a href="#通过使用-imports-loader-覆写-this" class="headerlink" title="通过使用 imports-loader 覆写 this"></a>通过使用 <code>imports-loader</code> 覆写 <code>this</code></h3><p>当模块运行在 CommonJS 环境下， <code>this</code> 指向的是 <code>module.exports</code>。</p><h3 id="使用-exports-loader，将一个全局变量作为一个普通的模块来导出"><a href="#使用-exports-loader，将一个全局变量作为一个普通的模块来导出" class="headerlink" title="使用 exports-loader，将一个全局变量作为一个普通的模块来导出"></a>使用 <code>exports-loader</code>，将一个全局变量作为一个普通的模块来导出</h3><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// globals.js</span><span class="hljs-keyword">var</span> file = <span class="hljs-string">'blah.txt'</span>;<span class="hljs-keyword">var</span> helpers = &#123;    test: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'test something'</span>); &#125;,    parse: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'parse something'</span>); &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// webpack.config.js</span>&#123;    test: <span class="hljs-built_in">require</span>.resolve(<span class="hljs-string">'globals.js'</span>),    use: <span class="hljs-string">'exports-loader?file,parse=helpers.parse'</span>&#125;</code></pre></div><p>之后可以从 <code>entry</code> 入口文件中(即 <code>src/index.js</code>)，我们能 <code>import { file, parse } from &#39;./globals.js&#39;;</code> ，然后一切将顺利进行。</p><h2 id="加载-polyfills"><a href="#加载-polyfills" class="headerlink" title="加载 polyfills"></a>加载 polyfills</h2>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack代码分离</title>
    <link href="/2019/11/03/notes/web/webpack/%E4%BB%A3%E7%A0%81%E5%88%86%E7%A6%BB/"/>
    <url>/2019/11/03/notes/web/webpack/%E4%BB%A3%E7%A0%81%E5%88%86%E7%A6%BB/</url>
    
    <content type="html"><![CDATA[<p>代码分离是 webpack 中最引人注目的特性之一。此特性能够把代码分离到不同的 bundle 中，然后可以按需加载或并行加载这些文件。</p><p>代码分离可以用于获取更小的 bundle，以及控制资源加载优先级，如果使用合理，会极大影响加载时间。</p><p>有三种常用的代码分离方法：</p><ul><li>使用 entry 手动地分离</li><li>使用<code>SplitChunksPlugin</code></li><li>动态导入</li></ul><h2 id="入口起点-entry-points"><a href="#入口起点-entry-points" class="headerlink" title="入口起点(entry points)"></a>入口起点(entry points)</h2><p>在webpack.config.js中设置如下：</p><div class="hljs"><pre><code class="hljs js">entry: &#123;   index: <span class="hljs-string">'./src/index.js'</span>,   another: <span class="hljs-string">'./src/another-module.js'</span> &#125;,</code></pre></div><p>优点：简单直观</p><p>缺点：公共模块会被重复打包</p><h2 id="使用SplitChunksPlugin"><a href="#使用SplitChunksPlugin" class="headerlink" title="使用SplitChunksPlugin"></a>使用<code>SplitChunksPlugin</code></h2><p>在webpack.config.js中设置如下：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;    entry: &#123;        index: <span class="hljs-string">'./src/index.js'</span>,        another: <span class="hljs-string">'./src/another-module.js'</span>,    &#125;,    output: &#123;        filename: <span class="hljs-string">'[name].bundle.js'</span>,        path: path.resolve(__dirname, <span class="hljs-string">'dist'</span>),    &#125;,    optimization: &#123;        splitChunks: &#123;            chunks: <span class="hljs-string">'all'</span>,        &#125;,    &#125;,&#125;;</code></pre></div><h2 id="动态导入"><a href="#动态导入" class="headerlink" title="动态导入"></a>动态导入</h2><p>在index.js中按照以下形式：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getComponent</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">const</span> element = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'div'</span>);  <span class="hljs-keyword">const</span> &#123; <span class="hljs-attr">default</span>: _ &#125; = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackChunkName: "lodash" */</span> <span class="hljs-string">'lodash'</span>);  element.innerHTML = _.join([<span class="hljs-string">'Hello'</span>, <span class="hljs-string">'webpack'</span>], <span class="hljs-string">' '</span>);  <span class="hljs-keyword">return</span> element;&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack配置懒加载</title>
    <link href="/2019/11/03/notes/web/webpack/%E6%87%92%E5%8A%A0%E8%BD%BD/"/>
    <url>/2019/11/03/notes/web/webpack/%E6%87%92%E5%8A%A0%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.webpackjs.com/guides/lazy-loading/" target="_blank" rel="noopener">https://www.webpackjs.com/guides/lazy-loading/</a></p><p><a href="https://webpack.js.org/guides/code-splitting/" target="_blank" rel="noopener">https://webpack.js.org/guides/code-splitting/</a></p><p>懒加载或者按需加载，是一种很好的优化网页或应用的方式。</p><p>这种方式实际上是先把你的代码在一些逻辑断点处分离开，然后在一些代码块中完成某些操作后，立即引用或即将引用另外一些新的代码块。这样加快了应用的初始加载速度，减轻了它的总体体积。</p><h2 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h2><p>通过调用函数动态的<code>import</code></p><div class="hljs"><pre><code class="hljs js">button.onclick = <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackChunkName: "print" */</span> <span class="hljs-string">'./print'</span>).then(<span class="hljs-function"><span class="hljs-params">module</span> =&gt;</span> &#123;    <span class="hljs-comment">// 通过module.default加载export default</span>    <span class="hljs-keyword">var</span> print = <span class="hljs-built_in">module</span>.default;    print();    &#125;);</code></pre></div><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>可以设置<code>Prefetching</code>/<code>Preloading</code></p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackPrefetch: true */</span> <span class="hljs-string">'LoginModal'</span>);<span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackPreload: true */</span> <span class="hljs-string">'ChartingLibrary'</span>);</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack解决缓存问题</title>
    <link href="/2019/11/03/notes/web/webpack/%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98/"/>
    <url>/2019/11/03/notes/web/webpack/%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>由于浏览器缓存问题，我们修改文件可能不会立即更新页面，因此需要一些必要的配置。</p><h2 id="普通文件"><a href="#普通文件" class="headerlink" title="普通文件"></a>普通文件</h2><p>通过在输出文件中加入<code>[chunkhash]</code></p><div class="hljs"><pre><code class="hljs js">&#123;    output: &#123;        filename: <span class="hljs-string">'[name].[chunkhash].js'</span>,        path: path.resolve(__dirname, <span class="hljs-string">'dist'</span>)    &#125;&#125;</code></pre></div><h2 id="公共部分"><a href="#公共部分" class="headerlink" title="公共部分"></a>公共部分</h2><h3 id="将-webpack-的-runtime-信息单独打包出来"><a href="#将-webpack-的-runtime-信息单独打包出来" class="headerlink" title="将 webpack 的 runtime 信息单独打包出来"></a>将 webpack 的 runtime 信息单独打包出来</h3><div class="hljs"><pre><code class="hljs js">optimization: &#123;    runtimeChunk: <span class="hljs-string">'single'</span>,&#125;,</code></pre></div><p>设置了<code>runtimeChunk</code>，就会打包<code>runtime</code>，<code>single</code>为打包为一个，<code>true</code> 或 <code>multiple</code>会打包多个。</p><p>便于缓存。</p><h3 id="设置cacheGroups"><a href="#设置cacheGroups" class="headerlink" title="设置cacheGroups"></a>设置<code>cacheGroups</code></h3><p>将第三方库(library)（例如 lodash 或 react）提取到单独的 vendor chunk 文件中，是比较推荐的做法，这是因为，它们很少像本地的源代码那样频繁修改。</p><div class="hljs"><pre><code class="hljs js">splitChunks: &#123;    cacheGroups: &#123;        vendor: &#123;        test: <span class="hljs-regexp">/[\\/]node_modules[\\/]/</span>,        name: <span class="hljs-string">'vendors'</span>,        chunks: <span class="hljs-string">'all'</span>,        &#125;,    &#125;,&#125;,</code></pre></div><h2 id="模块标识符-Module-Identifiers"><a href="#模块标识符-Module-Identifiers" class="headerlink" title="模块标识符(Module Identifiers)"></a>模块标识符(Module Identifiers)</h2><p>在<code>index.js</code>中通过<code>import</code>引入<code>print.js</code>，会造成根据<code>cacheGroups</code>打包的<code>vendor</code>的<code>[chunkhash]</code>发生变化</p><p><code>vendor</code> bundle 会随着自身的 <code>module.id</code> 的修改，而发生变化</p><p>通过<code>moduleIds: &#39;hashed&#39;</code>可以修复。</p><div class="hljs"><pre><code class="hljs js">optimization: &#123;    moduleIds: <span class="hljs-string">'hashed'</span>,    runtimeChunk: <span class="hljs-string">'single'</span>,    splitChunks: &#123;        cacheGroups: &#123;          vendor: &#123;            test: <span class="hljs-regexp">/[\\/]node_modules[\\/]/</span>,            name: <span class="hljs-string">'vendors'</span>,            chunks: <span class="hljs-string">'all'</span>,          &#125;,        &#125;,    &#125;,&#125;,</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>优化</tag>
      
      <tag>webpack</tag>
      
      <tag>cache</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>将本机公钥添加到远程服务器</title>
    <link href="/2019/09/03/notes/linux/%E5%B0%86%E6%9C%AC%E6%9C%BA%E5%85%AC%E9%92%A5%E6%B7%BB%E5%8A%A0%E5%88%B0%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/2019/09/03/notes/linux/%E5%B0%86%E6%9C%AC%E6%9C%BA%E5%85%AC%E9%92%A5%E6%B7%BB%E5%8A%A0%E5%88%B0%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="生成密钥对"><a href="#生成密钥对" class="headerlink" title="生成密钥对"></a>生成密钥对</h2><p><code>ssh-keygen -t rsa -C &quot;备注&quot;</code></p><h2 id="本机发送公钥到user-host"><a href="#本机发送公钥到user-host" class="headerlink" title="本机发送公钥到user@host"></a>本机发送公钥到<code>user@host</code></h2><p><code>ssh-copy-id -i ~/.ssh/id_rsa.pub user@host</code></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p><code>ssh user@host</code></p>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>ssh</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker 安装</title>
    <link href="/2019/08/21/notes/docker/%E5%AE%89%E8%A3%85/"/>
    <url>/2019/08/21/notes/docker/%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h2 id="Uninstall-old-versions"><a href="#Uninstall-old-versions" class="headerlink" title="Uninstall old versions"></a>Uninstall old versions</h2><div class="hljs"><pre><code class="hljs bash">sudo apt-get remove docker docker-engine docker.io containerd runc</code></pre></div><h2 id="Install-using-the-repository"><a href="#Install-using-the-repository" class="headerlink" title="Install using the repository"></a>Install using the repository</h2><div class="hljs"><pre><code class="hljs bash">sudo apt-get updatesudo apt-get install \    apt-transport-https \    ca-certificates \    curl \    gnupg-agent \    software-properties-commoncurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -<span class="hljs-comment"># 官方源：https://download.docker.com/linux/ubuntu</span><span class="hljs-comment"># 清华源：https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/ubuntu</span><span class="hljs-comment"># 腾讯云公网源：http://mirrors.cloud.tencent.com/docker-ce/linux/ubuntu</span><span class="hljs-comment"># 腾讯云内网源：http://mirrors.tencentyun.com/docker-ce/linux/ubuntu</span><span class="hljs-comment"># 阿里云公网源：http://mirrors.aliyun.com/docker-ce/linux/ubuntu</span><span class="hljs-comment"># 阿里云内网源：http://mirrors.cloud.aliyuncs.com/docker-ce/linux/ubuntu</span>sudo add-apt-repository \   <span class="hljs-string">"deb [arch=amd64] https://download.docker.com/linux/ubuntu \</span><span class="hljs-string">   <span class="hljs-variable">$(lsb_release -cs)</span> \</span><span class="hljs-string">   stable"</span>sudo apt-get updatesudo apt-get install docker-ce docker-ce-cli containerd.io</code></pre></div><h2 id="use-Docker-as-a-non-root-user"><a href="#use-Docker-as-a-non-root-user" class="headerlink" title="use Docker as a non-root user"></a>use Docker as a non-root user</h2><div class="hljs"><pre><code class="hljs bash">sudo usermod -aG docker <span class="hljs-variable">$USER</span></code></pre></div><h2 id="Uninstall-Docker-Engine"><a href="#Uninstall-Docker-Engine" class="headerlink" title="Uninstall Docker Engine"></a>Uninstall Docker Engine</h2><div class="hljs"><pre><code class="hljs bash">sudo apt-get purge docker-ce docker-ce-cli containerd.io<span class="hljs-comment"># To delete all images, containers, and volumes:</span>sudo rm -rf /var/lib/docker</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>安装</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cmd常用指令</title>
    <link href="/2019/08/21/notes/%E5%91%BD%E4%BB%A4%E8%A1%8C/cmd%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
    <url>/2019/08/21/notes/%E5%91%BD%E4%BB%A4%E8%A1%8C/cmd%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="1-空行"><a href="#1-空行" class="headerlink" title="1 空行"></a>1 空行</h2><div class="hljs"><pre><code class="hljs cmd"><span class="hljs-built_in">echo</span>.</code></pre></div><h2 id="2-回显"><a href="#2-回显" class="headerlink" title="2 回显@"></a>2 回显<code>@</code></h2><p><code>@</code>一般在它之后紧跟一条命令或一条语句，则此命令或语句本身在执行的时候不会显示在屏幕上。</p><div class="hljs"><pre><code class="hljs cmd"><span class="hljs-built_in">echo</span> off:: 回显自身@ <span class="hljs-built_in">echo</span> off:: 不回显自身</code></pre></div><h2 id="3"><a href="#3" class="headerlink" title="3 %,%%"></a>3 <code>%</code>,<code>%%</code></h2><p>1</p><p>当百分号成对出现，并且其间包含非特殊字符时，一般做<strong>变量引用</strong>处理，比如：%var%、%str%。</p><div class="hljs"><pre><code class="hljs cmd"><span class="hljs-built_in">set</span> a=asdasd<span class="hljs-built_in">echo</span> <span class="hljs-variable">%a%</span>&gt;asdasd</code></pre></div><p>2<br>模运算，<strong>命令行窗口和批处理文件中的写法略有差异</strong>：在命令行窗口中，只需要单个的%，在批处理文件中，需要连续两个百分号，写成%%。</p><p>3</p><p>转义符号：如果要显示<code>%</code>本身时，需要在前面用<code>%</code>来转义。</p><h2 id="4-gt-、-gt-gt"><a href="#4-gt-、-gt-gt" class="headerlink" title="4 &gt;、&gt;&gt;"></a>4 <code>&gt;</code>、<code>&gt;&gt;</code></h2><p>一般而言，<code>&gt;</code>表示用新内容<strong>覆盖</strong>原文件内容，<code>&gt;&gt;</code>表示向原文件<strong>追加</strong>内容，此时，它们以重定向符号的身份出现；如果用在 <code>set /a</code>语句中，则<code>&gt;</code>表示分组，<code>&gt;&gt;</code>表示逻辑移位；</p><h2 id="5"><a href="#5" class="headerlink" title="5 |"></a>5 <code>|</code></h2><p>简而言之，就是<strong>把它之前的输出作为它之后的输入</strong>，例如：<code>echo abcd|findstr &quot;b&quot;</code>，表示把<code>echo abcd</code>的执行结果，作为<code>findstr &quot;b&quot;</code>的执行对象，也就是在字符串<code>abcd</code>中查找<code>b</code>字符；</p><h2 id="6-amp"><a href="#6-amp" class="headerlink" title="6 &amp;"></a>6 <code>&amp;</code></h2><p>一般而言，<code>&amp;</code>表示两条命令或语句同时执行的意思。如 <code>echo a&amp;echo b</code></p>]]></content>
    
    
    
    <tags>
      
      <tag>cmd</tag>
      
      <tag>bash</tag>
      
      <tag>shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
