<!DOCTYPE html><html lang=zh-CN><head><meta charset=UTF-8><link href=/img/favicon.png rel=apple-touch-icon sizes=76x76><link href=/img/favicon.png rel=icon type=image/png><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no" name=viewport><meta content="ie=edge" http-equiv=x-ua-compatible><meta content=#2f4154 name=theme-color><meta content=Blog name=description><meta content="Ai Zf" name=author><meta content="" name=keywords><title>构造函数、原型和原型链 - Blog</title><link href=https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css rel=stylesheet /><link href=https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css rel=stylesheet /><link href=/lib/hint/hint.min.css rel=stylesheet /><link href=https://cdn.staticfile.org/highlight.js/10.0.0/styles/atom-one-dark.min.css rel=stylesheet /><link href=//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css rel=stylesheet><link href=//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css rel=stylesheet><link href=/css/main.css rel=stylesheet /><script src=/js/utils.js></script><meta content="Hexo 4.2.1" name=generator></head><body><header style=height:70vh><nav class="fixed-top navbar navbar-dark navbar-expand-lg scrolling-navbar" id=navbar><div class=container><a href=/ class=navbar-brand>&nbsp;<strong>Aizf</strong>&nbsp;</a><button aria-label="Toggle navigation" class=navbar-toggler id=navbar-toggler-btn type=button aria-controls=navbarSupportedContent aria-expanded=false data-target=#navbarSupportedContent data-toggle=collapse><div class=animated-icon><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="text-center ml-auto navbar-nav"><li class=nav-item><a href=/ class=nav-link><i class="iconfont icon-home-fill"></i>首页</a></li><li class=nav-item><a href=/archives/ class=nav-link><i class="iconfont icon-archive-fill"></i>归档</a></li><li class=nav-item><a href=/categories/ class=nav-link><i class="iconfont icon-category-fill"></i>分类</a></li><li class=nav-item><a href=/tags/ class=nav-link><i class="iconfont icon-tags-fill"></i>标签</a></li><li class="nav-item dropdown"><a href=# class="nav-link dropdown-toggle" aria-expanded=false aria-haspopup=true data-toggle=dropdown role=button><i class="iconfont icon-books"></i>Projects</a><div class=dropdown-menu aria-labelledby=navbarDropdown><a href=/projects/exploratory-analysis-system/ class=dropdown-item>Exploratory Analysis System</a><a href=/projects/story-telling/ class=dropdown-item>Story Telling</a></div></li><li class=nav-item><a href=https://github.com/aizf/ class=nav-link rel=noopener target=_blank><i class="iconfont icon-github-fill"></i>GitHub</a></li><li class=nav-item id=search-btn><a class=nav-link data-toggle=modal data-target=#modalSearch>&nbsp;&nbsp;<i class="iconfont icon-search"></i>&nbsp;&nbsp;</a></li></ul></div></div></nav><div class="intro-2 view" id=background parallax=true style="background:url(/img/default.jpg) no-repeat center center;background-size:cover"><div class=full-bg-img><div class="flex-center mask" style=background-color:rgba(0,0,0,.3)><div class="text-center container fadeInUp white-text"><span class=h2 id=subtitle>构造函数、原型和原型链</span><div class=mt-1><span class="post-meta mr-2"><i class="iconfont icon-chart"></i>1.2k 字</span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i>13 分钟</span></div></div></div></div></div></header><main><div class=container-fluid><div class=row><div class="col-lg-2 d-lg-block d-none"></div><div class="nopadding-md col-lg-8"><div class="container nopadding-md" id=board-ctn><div class=py-5 id=board><div class="mx-auto post-content" id=post><article class=markdown-body><ul><li>所有实例对象需要<strong>共享</strong>的属性和方法，都放在<code>prototype</code>里面；</li><li>那些<strong>不需要共享</strong>的属性和方法，就放在<strong>构造函数</strong>里面。</li></ul><h2 id=构造函数><a href=#构造函数 class=headerlink title=构造函数></a>构造函数</h2><p><code>constructor</code>返回创建实例对象时构造函数的引用。此属性的值是对函数本身的引用，而不是一个包含函数名称的字符串。</p><div class=hljs><pre><code class="hljs js"><span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>Parent</span>(<span class=hljs-params>age</span>) </span>&#123;
    <span class=hljs-keyword>this</span>.age = age;
&#125;

<span class=hljs-keyword>var</span> p = <span class=hljs-keyword>new</span> Parent(<span class=hljs-number>50</span>);
p.constructor === Parent; <span class=hljs-comment>// true</span>
p.constructor === <span class=hljs-built_in>Object</span>; <span class=hljs-comment>// false</span></code></pre></div><p>构造函数和普通函数的<strong>区别</strong>在于，使用 new 生成实例的函数就是构造函数，直接调用的就是普通函数。</p><p>普通函数创建的实例没可能也有<code>constructor</code>属性</p><div class=hljs><pre><code class="hljs js"><span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>parent3</span>(<span class=hljs-params>age</span>) </span>&#123;
    <span class=hljs-keyword>return</span> &#123;
        age: age
    &#125;
&#125;
<span class=hljs-keyword>var</span> p3 = parent3(<span class=hljs-number>50</span>);
p3.constructor === <span class=hljs-built_in>Object</span>; <span class=hljs-comment>// true</span></code></pre></div><h3 id=constructor-值只读吗><a href=#constructor-值只读吗 class=headerlink title="constructor 值只读吗"></a>constructor 值只读吗</h3><p>对于引用类型来说 constructor 属性值是可以修改的，但是对于基本类型来说是只读的。</p><p>null 和 undefined 是没有 constructor 属性</p><h2 id=原型><a href=#原型 class=headerlink title=原型></a>原型</h2><h3 id=prototype><a href=#prototype class=headerlink title=prototype></a><code>prototype</code></h3><p><code>prototype</code>是<strong>函数才有的</strong>属性</p><p>每个对象拥有一个原型对象，对象以其原型为模板，从原型继承方法和属性，这些属性和方法定义在对象的构造器函数的<code>prototype</code>属性上，而非对象实例本身。</p><p>构造函数<code>Parent</code>有一个指向原型的指针，原型<code>Parent.prototype</code>有一个指向构造函数的指针<code>Parent.prototype.constructor</code></p><p><img alt=avatar src=http://pic.aizf.ink/md/js/1.jpg></p><h3 id=proto><a href=#proto class=headerlink title=__proto__></a><code>__proto__</code></h3><p>是每个对象都有的属性,可以理解为“构造器的原型”，即<code>__proto__===constructor.protype</code></p><p>这是一个访问器属性（即<code>getter</code>函数和<code>setter</code>函数），通过它可以访问到对象的内部<code>[[Prototype]]</code>(一个对象或<code>null</code>)。</p><p><code>__proto__</code>发音 dunder proto，最先被 Firefox使用，后来在 ES6 被列为 Javascript 的标准内建属性</p><p><code>[[Prototype]]</code>是对象的一个内部属性，外部代码无法直接访问。</p><div class=hljs><pre><code class="hljs js"><span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>Parent</span>(<span class=hljs-params></span>) </span>&#123;&#125;
<span class=hljs-keyword>var</span> p = <span class=hljs-keyword>new</span> Parent();
p.__proto__ === Parent.prototype
<span class=hljs-comment>// true</span></code></pre></div><p><code>__proto__</code>是每个实例上都有的属性，<code>prototype</code>是构造函数的属性，这两个并不一样，但<code>p.__proto__</code>和<code>Parent.prototype</code>指向同一个对象。</p><p>所以构造函数 Parent、Parent.prototype 和 p 的关系如下图</p><p><img alt=avatar src=http://pic.aizf.ink/md/js/2.jpg></p><h3 id=注意点><a href=#注意点 class=headerlink title=注意点></a>注意点</h3><p><code>__proto__</code>属性在 ES6 时才被标准化，以确保 Web 浏览器的兼容性，但是不推荐使用，除了标准化的原因之外还有性能问题。为了更好的支持，推荐使用<code>Object.getPrototypeOf()</code>。</p><p>如果要读取或修改对象的 [[Prototype]] 属性，建议使用如下方案，但是此时设置对象的 [[Prototype]] 依旧是一个缓慢的操作，如果性能是一个问题，就要避免这种操作。</p><div class=hljs><pre><code class="hljs js"><span class=hljs-comment>// 获取</span>
<span class=hljs-built_in>Object</span>.getPrototypeOf()
<span class=hljs-built_in>Reflect</span>.getPrototypeOf()

<span class=hljs-comment>// 修改</span>
<span class=hljs-built_in>Object</span>.setPrototypeOf()
<span class=hljs-built_in>Reflect</span>.setPrototypeOf()</code></pre></div><p>如果要创建一个新对象，同时继承另一个对象的 [[Prototype]] ，推荐使用 Object.create()。</p><div class=hljs><pre><code class="hljs js"><span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>Parent</span>(<span class=hljs-params></span>) </span>&#123;
    age: <span class=hljs-number>50</span>
&#125;;
<span class=hljs-keyword>var</span> p = <span class=hljs-keyword>new</span> Parent();
<span class=hljs-keyword>var</span> child = <span class=hljs-built_in>Object</span>.create(p);</code></pre></div><p>这里 child 是一个新的空对象，有一个指向对象<code>p</code>的指针<code>__proto__</code>。</p><h2 id=原型链><a href=#原型链 class=headerlink title=原型链></a>原型链</h2><p>每个对象拥有一个原型对象，<strong>通过<code>__proto__</code>指针指向上一个原型</strong>，并从中继承方法和属性，同时原型对象也可能拥有原型，这样一层一层，最终指向<code>null</code>。这种关系被称为原型链 (prototype chain)，通过原型链一个对象会拥有定义在其他对象中的属性和方法。</p><div class=hljs><pre><code class="hljs js"><span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>Parent</span>(<span class=hljs-params>age</span>) </span>&#123;
    <span class=hljs-keyword>this</span>.age = age;
&#125;

<span class=hljs-keyword>var</span> p = <span class=hljs-keyword>new</span> Parent(<span class=hljs-number>50</span>);
p.constructor === Parent; <span class=hljs-comment>// true</span></code></pre></div><p>这里 p.constructor 指向 Parent，那是不是意味着 p 实例存在 constructor 属性呢？并不是。</p><p>我们打印下 p 值就知道,可以看到实例对象<code>p</code>本身没有<code>constructor</code>属性，是通过原型链向上查找<code>__proto__</code>，最终查找到<code>constructor</code>属性，该属性指向<code>Parent</code>。</p><div class=hljs><pre><code class="hljs js"><span class=hljs-comment>// 木易杨</span>
<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>Parent</span>(<span class=hljs-params>age</span>) </span>&#123;
    <span class=hljs-keyword>this</span>.age = age;
&#125;
<span class=hljs-keyword>var</span> p = <span class=hljs-keyword>new</span> Parent(<span class=hljs-number>50</span>);

p;	<span class=hljs-comment>// Parent &#123;age: 50&#125;</span>
p.__proto__ === Parent.prototype; <span class=hljs-comment>// true</span>
p.__proto__.__proto__ === <span class=hljs-built_in>Object</span>.prototype; <span class=hljs-comment>// true</span>
p.__proto__.__proto__.__proto__ === <span class=hljs-literal>null</span>; <span class=hljs-comment>// true</span></code></pre></div><p>运作机制</p><p><img alt=avatar src=http://pic.aizf.ink/md/js/3.jpg></p><h2 id=prototype-和-proto><a href=#prototype-和-proto class=headerlink title="prototype 和 __proto__"></a><code>prototype</code>和<code>__proto__</code></h2><p>原型对象<code>prototype</code>是<strong>构造函数</strong>的属性，<code>__proto__</code>是每个实例上都有的属性，这两个并不一样，但<code>foo.__proto__</code>和<code>Foo.prototype</code>指向同一个对象。</p><p><img alt=avatar src=http://pic.aizf.ink/md/js/4.png></p><p>如上图，原型链的构建依赖于<code>__proto__</code>,通过<code>foo.__proto__</code>指向<code>Foo.prototype</code>，<code>foo.__proto__.__proto__</code>指向<code>Bichon.prototype</code>，如此一层一层最终链接到<code>null</code>。</p><blockquote><p>可以这么理解<code>Foo</code>，我是一个<code>constructor</code>，我也是一个<code>function</code>，我身上有着<code>prototype</code>的 reference，只要随时调用<code>foo = new Foo()</code>，我就会将<code>foo.__proto__</code>指向到我的<code>prototype</code>对象。</p></blockquote><h3 id=注意><a href=#注意 class=headerlink title=注意></a>注意</h3><p>在原型链上查找属性比较耗时，对性能有副作用，这在性能要求苛刻的情况下很重要。另外，试图访问不存在的属性时会遍历整个原型链。</p></article><hr><div><div class="mb-3 post-metas"><div class=post-meta><i class="iconfont icon-tags"></i><a href=/tags/js/ class=hover-with-bg>js</a></div></div><p class="note note-warning">本博客所有文章除特别声明外，均采用<a href=https://creativecommons.org/licenses/by-sa/4.0/deed.zh rel="nofollow noopener noopener" target=_blank>CC BY-SA 4.0 协议</a>，转载请注明出处！</p><div class="row post-prevnext"><div class="col-6 post-prev"><a href=/2020/08/10/notes/web/js/%E6%95%B0%E7%BB%84%E7%9A%84%E6%9F%A5%E6%89%BE%E6%96%B9%E6%B3%95/ ><i class="iconfont icon-arrowleft"></i><span class=hidden-mobile>js数组的查找方法汇总</span><span class=visible-mobile>上一篇</span></a></div><div class="col-6 post-next"><a href=/2020/08/10/notes/web/js/%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%96%B9%E6%A1%88/ ><span class=hidden-mobile>js模块加载方案</span><span class=visible-mobile>下一篇</span><i class="iconfont icon-arrowright"></i></a></div></div></div></div></div></div></div><div class="col-lg-2 d-lg-block d-none toc-container" id=toc-ctn><div id=toc><p class=toc-header><i class="iconfont icon-list"></i>&nbsp;目录</p><div id=tocbot></div></div></div></div></div></main><a href=# role=button id=scroll-top-button><i class="iconfont icon-arrowup" aria-hidden=true></i></a><div class="fade modal" id=modalSearch aria-hidden=true aria-labelledby=ModalLabel role=dialog tabindex=-1><div class="modal-dialog modal-dialog-scrollable modal-lg" role=document><div class=modal-content><div class="text-center modal-header"><h4 class="font-weight-bold modal-title w-100">搜索</h4><button aria-label=Close class=close id=local-search-close type=button data-dismiss=modal><span aria-hidden=true>&times;</span></button></div><div class="modal-body mx-3"><div class="mb-5 md-form"><input class="form-control validate" id=local-search-input><label data-error=x data-success=v for=local-search-input>关键词</label></div><div class=list-group id=local-search-result></div></div></div></div></div><footer class=mt-5><div class="text-center py-3"><div><a href=https://hexo.io rel="nofollow noopener" target=_blank><span>Hexo</span></a><i class="iconfont icon-love"></i><a href=https://github.com/fluid-dev/hexo-theme-fluid rel="nofollow noopener" target=_blank><span>Fluid</span></a></div><div class=beian><a href=http://beian.miit.gov.cn/ rel="nofollow noopener" target=_blank>冀ICP备20017493号</a></div></div></footer><script src=https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js></script><script src=https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js></script><script src=/js/debouncer.js></script><script src=/js/main.js></script><script src=https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js defer></script><script src=/js/clipboard-use.js></script><script src=https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js></script><script>$(document).ready(function(){var t=$("#board-ctn").offset().top;tocbot.init({tocSelector:"#tocbot",contentSelector:"article.markdown-body",headingSelector:"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",collapseDepth:0,scrollSmooth:!0,headingsOffset:-t}),0<$(".toc-list-item").length&&$("#toc").css("visibility","visible")})</script><script src=https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js></script><script>anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))</script><script src=/js/local-search.js></script><script>var path="/local-search.xml",inputArea=document.querySelector("#local-search-input");inputArea.onclick=function(){searchFunc(path,"local-search-input","local-search-result"),this.onclick=null}</script><script src=https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js></script><link href=https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css rel=stylesheet /><script>$("#post img:not(.no-zoom img, img[no-zoom]), img[zoom]").each(function(){var t=document.createElement("a");$(t).attr("data-fancybox","images"),$(t).attr("href",$(this).attr("src")),$(this).wrap(t)})</script><script defer>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?86884af79f8b6931e1e8d7ff92810a77";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></body></html>